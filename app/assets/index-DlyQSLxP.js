import{c as jc,g as Su}from"./react-vendor-P8ZuH1e3.js";var St={},Nn,hs;function Au(){if(hs)return Nn;hs=1;var b=function(E){if(E=E||{},this.Promise=E.Promise||Promise,this.queues=Object.create(null),this.domainReentrant=E.domainReentrant||!1,this.domainReentrant){if(typeof process>"u"||typeof process.domain>"u")throw new Error("Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill.");this.domains=Object.create(null)}this.timeout=E.timeout||b.DEFAULT_TIMEOUT,this.maxOccupationTime=E.maxOccupationTime||b.DEFAULT_MAX_OCCUPATION_TIME,this.maxExecutionTime=E.maxExecutionTime||b.DEFAULT_MAX_EXECUTION_TIME,E.maxPending===1/0||Number.isInteger(E.maxPending)&&E.maxPending>=0?this.maxPending=E.maxPending:this.maxPending=b.DEFAULT_MAX_PENDING};return b.DEFAULT_TIMEOUT=0,b.DEFAULT_MAX_OCCUPATION_TIME=0,b.DEFAULT_MAX_EXECUTION_TIME=0,b.DEFAULT_MAX_PENDING=1e3,b.prototype.acquire=function(E,D,R,C){if(Array.isArray(E))return this._acquireBatch(E,D,R,C);if(typeof D!="function")throw new Error("You must pass a function to execute");var A=null,T=null,m=null;typeof R!="function"&&(C=R,R=null,m=new this.Promise(function(L,at){A=L,T=at})),C=C||{};var g=!1,P=null,$=null,k=null,F=this,M=function(L,at,ht){$&&(clearTimeout($),$=null),k&&(clearTimeout(k),k=null),L&&(F.queues[E]&&F.queues[E].length===0&&delete F.queues[E],F.domainReentrant&&delete F.domains[E]),g||(m?at?T(at):A(ht):typeof R=="function"&&R(at,ht),g=!0),L&&F.queues[E]&&F.queues[E].length>0&&F.queues[E].shift()()},Q=function(L){if(g)return M(L);P&&(clearTimeout(P),P=null),F.domainReentrant&&L&&(F.domains[E]=process.domain);var at=C.maxExecutionTime||F.maxExecutionTime;if(at&&(k=setTimeout(function(){F.queues[E]&&M(L,new Error("Maximum execution time is exceeded "+E))},at)),D.length===1){var ht=!1;try{D(function(wt,W){ht||(ht=!0,M(L,wt,W))})}catch(wt){ht||(ht=!0,M(L,wt))}}else F._promiseTry(function(){return D()}).then(function(wt){M(L,void 0,wt)},function(wt){M(L,wt)})};F.domainReentrant&&process.domain&&(Q=process.domain.bind(Q));var ut=C.maxPending||F.maxPending;if(!F.queues[E])F.queues[E]=[],Q(!0);else if(F.domainReentrant&&process.domain&&process.domain===F.domains[E])Q(!1);else if(F.queues[E].length>=ut)M(!1,new Error("Too many pending tasks in queue "+E));else{var H=function(){Q(!0)};C.skipQueue?F.queues[E].unshift(H):F.queues[E].push(H);var G=C.timeout||F.timeout;G&&(P=setTimeout(function(){P=null,M(!1,new Error("async-lock timed out in queue "+E))},G))}var K=C.maxOccupationTime||F.maxOccupationTime;if(K&&($=setTimeout(function(){F.queues[E]&&M(!1,new Error("Maximum occupation time is exceeded in queue "+E))},K)),m)return m},b.prototype._acquireBatch=function(E,D,R,C){typeof R!="function"&&(C=R,R=null);var A=this,T=function(g,P){return function($){A.acquire(g,P,$,C)}},m=E.reduceRight(function(g,P){return T(P,g)},D);if(typeof R=="function")m(R);else return new this.Promise(function(g,P){m.length===1?m(function($,k){$?P($):g(k)}):g(m())})},b.prototype.isBusy=function(E){return E?!!this.queues[E]:Object.keys(this.queues).length>0},b.prototype._promiseTry=function(E){try{return this.Promise.resolve(E())}catch(D){return this.Promise.reject(D)}},Nn=b,Nn}var Mn,ds;function ku(){return ds||(ds=1,Mn=Au()),Mn}var dn={exports:{}},ps;function Ru(){return ps||(ps=1,typeof Object.create=="function"?dn.exports=function(E,D){D&&(E.super_=D,E.prototype=Object.create(D.prototype,{constructor:{value:E,enumerable:!1,writable:!0,configurable:!0}}))}:dn.exports=function(E,D){if(D){E.super_=D;var R=function(){};R.prototype=D.prototype,E.prototype=new R,E.prototype.constructor=E}}),dn.exports}var pn={exports:{}},jn={},Kr={},ws;function Tu(){if(ws)return Kr;ws=1,Kr.byteLength=m,Kr.toByteArray=P,Kr.fromByteArray=F;for(var b=[],E=[],D=typeof Uint8Array<"u"?Uint8Array:Array,R="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",C=0,A=R.length;C<A;++C)b[C]=R[C],E[R.charCodeAt(C)]=C;E[45]=62,E[95]=63;function T(M){var Q=M.length;if(Q%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var ut=M.indexOf("=");ut===-1&&(ut=Q);var H=ut===Q?0:4-ut%4;return[ut,H]}function m(M){var Q=T(M),ut=Q[0],H=Q[1];return(ut+H)*3/4-H}function g(M,Q,ut){return(Q+ut)*3/4-ut}function P(M){var Q,ut=T(M),H=ut[0],G=ut[1],K=new D(g(M,H,G)),L=0,at=G>0?H-4:H,ht;for(ht=0;ht<at;ht+=4)Q=E[M.charCodeAt(ht)]<<18|E[M.charCodeAt(ht+1)]<<12|E[M.charCodeAt(ht+2)]<<6|E[M.charCodeAt(ht+3)],K[L++]=Q>>16&255,K[L++]=Q>>8&255,K[L++]=Q&255;return G===2&&(Q=E[M.charCodeAt(ht)]<<2|E[M.charCodeAt(ht+1)]>>4,K[L++]=Q&255),G===1&&(Q=E[M.charCodeAt(ht)]<<10|E[M.charCodeAt(ht+1)]<<4|E[M.charCodeAt(ht+2)]>>2,K[L++]=Q>>8&255,K[L++]=Q&255),K}function $(M){return b[M>>18&63]+b[M>>12&63]+b[M>>6&63]+b[M&63]}function k(M,Q,ut){for(var H,G=[],K=Q;K<ut;K+=3)H=(M[K]<<16&16711680)+(M[K+1]<<8&65280)+(M[K+2]&255),G.push($(H));return G.join("")}function F(M){for(var Q,ut=M.length,H=ut%3,G=[],K=16383,L=0,at=ut-H;L<at;L+=K)G.push(k(M,L,L+K>at?at:L+K));return H===1?(Q=M[ut-1],G.push(b[Q>>2]+b[Q<<4&63]+"==")):H===2&&(Q=(M[ut-2]<<8)+M[ut-1],G.push(b[Q>>10]+b[Q>>4&63]+b[Q<<2&63]+"=")),G.join("")}return Kr}var wn={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */var ms;function Iu(){return ms||(ms=1,wn.read=function(b,E,D,R,C){var A,T,m=C*8-R-1,g=(1<<m)-1,P=g>>1,$=-7,k=D?C-1:0,F=D?-1:1,M=b[E+k];for(k+=F,A=M&(1<<-$)-1,M>>=-$,$+=m;$>0;A=A*256+b[E+k],k+=F,$-=8);for(T=A&(1<<-$)-1,A>>=-$,$+=R;$>0;T=T*256+b[E+k],k+=F,$-=8);if(A===0)A=1-P;else{if(A===g)return T?NaN:(M?-1:1)*(1/0);T=T+Math.pow(2,R),A=A-P}return(M?-1:1)*T*Math.pow(2,A-R)},wn.write=function(b,E,D,R,C,A){var T,m,g,P=A*8-C-1,$=(1<<P)-1,k=$>>1,F=C===23?Math.pow(2,-24)-Math.pow(2,-77):0,M=R?0:A-1,Q=R?1:-1,ut=E<0||E===0&&1/E<0?1:0;for(E=Math.abs(E),isNaN(E)||E===1/0?(m=isNaN(E)?1:0,T=$):(T=Math.floor(Math.log(E)/Math.LN2),E*(g=Math.pow(2,-T))<1&&(T--,g*=2),T+k>=1?E+=F/g:E+=F*Math.pow(2,1-k),E*g>=2&&(T++,g/=2),T+k>=$?(m=0,T=$):T+k>=1?(m=(E*g-1)*Math.pow(2,C),T=T+k):(m=E*Math.pow(2,k-1)*Math.pow(2,C),T=0));C>=8;b[D+M]=m&255,M+=Q,m/=256,C-=8);for(T=T<<C|m,P+=C;P>0;b[D+M]=T&255,M+=Q,T/=256,P-=8);b[D+M-Q]|=ut*128}),wn}/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var gs;function Bu(){return gs||(gs=1,(function(b){var E=Tu(),D=Iu(),R=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;b.Buffer=m,b.SlowBuffer=K,b.INSPECT_MAX_BYTES=50;var C=2147483647;b.kMaxLength=C,m.TYPED_ARRAY_SUPPORT=A(),!m.TYPED_ARRAY_SUPPORT&&typeof console<"u";function A(){try{var y=new Uint8Array(1),o={foo:function(){return 42}};return Object.setPrototypeOf(o,Uint8Array.prototype),Object.setPrototypeOf(y,o),y.foo()===42}catch{return!1}}Object.defineProperty(m.prototype,"parent",{enumerable:!0,get:function(){if(m.isBuffer(this))return this.buffer}}),Object.defineProperty(m.prototype,"offset",{enumerable:!0,get:function(){if(m.isBuffer(this))return this.byteOffset}});function T(y){if(y>C)throw new RangeError('The value "'+y+'" is invalid for option "size"');var o=new Uint8Array(y);return Object.setPrototypeOf(o,m.prototype),o}function m(y,o,f){if(typeof y=="number"){if(typeof o=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return k(y)}return g(y,o,f)}m.poolSize=8192;function g(y,o,f){if(typeof y=="string")return F(y,o);if(ArrayBuffer.isView(y))return Q(y);if(y==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof y);if(Lt(y,ArrayBuffer)||y&&Lt(y.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(Lt(y,SharedArrayBuffer)||y&&Lt(y.buffer,SharedArrayBuffer)))return ut(y,o,f);if(typeof y=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');var S=y.valueOf&&y.valueOf();if(S!=null&&S!==y)return m.from(S,o,f);var q=H(y);if(q)return q;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof y[Symbol.toPrimitive]=="function")return m.from(y[Symbol.toPrimitive]("string"),o,f);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof y)}m.from=function(y,o,f){return g(y,o,f)},Object.setPrototypeOf(m.prototype,Uint8Array.prototype),Object.setPrototypeOf(m,Uint8Array);function P(y){if(typeof y!="number")throw new TypeError('"size" argument must be of type number');if(y<0)throw new RangeError('The value "'+y+'" is invalid for option "size"')}function $(y,o,f){return P(y),y<=0?T(y):o!==void 0?typeof f=="string"?T(y).fill(o,f):T(y).fill(o):T(y)}m.alloc=function(y,o,f){return $(y,o,f)};function k(y){return P(y),T(y<0?0:G(y)|0)}m.allocUnsafe=function(y){return k(y)},m.allocUnsafeSlow=function(y){return k(y)};function F(y,o){if((typeof o!="string"||o==="")&&(o="utf8"),!m.isEncoding(o))throw new TypeError("Unknown encoding: "+o);var f=L(y,o)|0,S=T(f),q=S.write(y,o);return q!==f&&(S=S.slice(0,q)),S}function M(y){for(var o=y.length<0?0:G(y.length)|0,f=T(o),S=0;S<o;S+=1)f[S]=y[S]&255;return f}function Q(y){if(Lt(y,Uint8Array)){var o=new Uint8Array(y);return ut(o.buffer,o.byteOffset,o.byteLength)}return M(y)}function ut(y,o,f){if(o<0||y.byteLength<o)throw new RangeError('"offset" is outside of buffer bounds');if(y.byteLength<o+(f||0))throw new RangeError('"length" is outside of buffer bounds');var S;return o===void 0&&f===void 0?S=new Uint8Array(y):f===void 0?S=new Uint8Array(y,o):S=new Uint8Array(y,o,f),Object.setPrototypeOf(S,m.prototype),S}function H(y){if(m.isBuffer(y)){var o=G(y.length)|0,f=T(o);return f.length===0||y.copy(f,0,0,o),f}if(y.length!==void 0)return typeof y.length!="number"||ce(y.length)?T(0):M(y);if(y.type==="Buffer"&&Array.isArray(y.data))return M(y.data)}function G(y){if(y>=C)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+C.toString(16)+" bytes");return y|0}function K(y){return+y!=y&&(y=0),m.alloc(+y)}m.isBuffer=function(o){return o!=null&&o._isBuffer===!0&&o!==m.prototype},m.compare=function(o,f){if(Lt(o,Uint8Array)&&(o=m.from(o,o.offset,o.byteLength)),Lt(f,Uint8Array)&&(f=m.from(f,f.offset,f.byteLength)),!m.isBuffer(o)||!m.isBuffer(f))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(o===f)return 0;for(var S=o.length,q=f.length,nt=0,ct=Math.min(S,q);nt<ct;++nt)if(o[nt]!==f[nt]){S=o[nt],q=f[nt];break}return S<q?-1:q<S?1:0},m.isEncoding=function(o){switch(String(o).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},m.concat=function(o,f){if(!Array.isArray(o))throw new TypeError('"list" argument must be an Array of Buffers');if(o.length===0)return m.alloc(0);var S;if(f===void 0)for(f=0,S=0;S<o.length;++S)f+=o[S].length;var q=m.allocUnsafe(f),nt=0;for(S=0;S<o.length;++S){var ct=o[S];if(Lt(ct,Uint8Array))nt+ct.length>q.length?m.from(ct).copy(q,nt):Uint8Array.prototype.set.call(q,ct,nt);else if(m.isBuffer(ct))ct.copy(q,nt);else throw new TypeError('"list" argument must be an Array of Buffers');nt+=ct.length}return q};function L(y,o){if(m.isBuffer(y))return y.length;if(ArrayBuffer.isView(y)||Lt(y,ArrayBuffer))return y.byteLength;if(typeof y!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof y);var f=y.length,S=arguments.length>2&&arguments[2]===!0;if(!S&&f===0)return 0;for(var q=!1;;)switch(o){case"ascii":case"latin1":case"binary":return f;case"utf8":case"utf-8":return Nt(y).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return f*2;case"hex":return f>>>1;case"base64":return Kt(y).length;default:if(q)return S?-1:Nt(y).length;o=(""+o).toLowerCase(),q=!0}}m.byteLength=L;function at(y,o,f){var S=!1;if((o===void 0||o<0)&&(o=0),o>this.length||((f===void 0||f>this.length)&&(f=this.length),f<=0)||(f>>>=0,o>>>=0,f<=o))return"";for(y||(y="utf8");;)switch(y){case"hex":return st(this,o,f);case"utf8":case"utf-8":return Tt(this,o,f);case"ascii":return rt(this,o,f);case"latin1":case"binary":return ot(this,o,f);case"base64":return yt(this,o,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Mt(this,o,f);default:if(S)throw new TypeError("Unknown encoding: "+y);y=(y+"").toLowerCase(),S=!0}}m.prototype._isBuffer=!0;function ht(y,o,f){var S=y[o];y[o]=y[f],y[f]=S}m.prototype.swap16=function(){var o=this.length;if(o%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var f=0;f<o;f+=2)ht(this,f,f+1);return this},m.prototype.swap32=function(){var o=this.length;if(o%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var f=0;f<o;f+=4)ht(this,f,f+3),ht(this,f+1,f+2);return this},m.prototype.swap64=function(){var o=this.length;if(o%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var f=0;f<o;f+=8)ht(this,f,f+7),ht(this,f+1,f+6),ht(this,f+2,f+5),ht(this,f+3,f+4);return this},m.prototype.toString=function(){var o=this.length;return o===0?"":arguments.length===0?Tt(this,0,o):at.apply(this,arguments)},m.prototype.toLocaleString=m.prototype.toString,m.prototype.equals=function(o){if(!m.isBuffer(o))throw new TypeError("Argument must be a Buffer");return this===o?!0:m.compare(this,o)===0},m.prototype.inspect=function(){var o="",f=b.INSPECT_MAX_BYTES;return o=this.toString("hex",0,f).replace(/(.{2})/g,"$1 ").trim(),this.length>f&&(o+=" ... "),"<Buffer "+o+">"},R&&(m.prototype[R]=m.prototype.inspect),m.prototype.compare=function(o,f,S,q,nt){if(Lt(o,Uint8Array)&&(o=m.from(o,o.offset,o.byteLength)),!m.isBuffer(o))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof o);if(f===void 0&&(f=0),S===void 0&&(S=o?o.length:0),q===void 0&&(q=0),nt===void 0&&(nt=this.length),f<0||S>o.length||q<0||nt>this.length)throw new RangeError("out of range index");if(q>=nt&&f>=S)return 0;if(q>=nt)return-1;if(f>=S)return 1;if(f>>>=0,S>>>=0,q>>>=0,nt>>>=0,this===o)return 0;for(var ct=nt-q,qt=S-f,Gt=Math.min(ct,qt),Vt=this.slice(q,nt),oe=o.slice(f,S),te=0;te<Gt;++te)if(Vt[te]!==oe[te]){ct=Vt[te],qt=oe[te];break}return ct<qt?-1:qt<ct?1:0};function wt(y,o,f,S,q){if(y.length===0)return-1;if(typeof f=="string"?(S=f,f=0):f>2147483647?f=2147483647:f<-2147483648&&(f=-2147483648),f=+f,ce(f)&&(f=q?0:y.length-1),f<0&&(f=y.length+f),f>=y.length){if(q)return-1;f=y.length-1}else if(f<0)if(q)f=0;else return-1;if(typeof o=="string"&&(o=m.from(o,S)),m.isBuffer(o))return o.length===0?-1:W(y,o,f,S,q);if(typeof o=="number")return o=o&255,typeof Uint8Array.prototype.indexOf=="function"?q?Uint8Array.prototype.indexOf.call(y,o,f):Uint8Array.prototype.lastIndexOf.call(y,o,f):W(y,[o],f,S,q);throw new TypeError("val must be string, number or Buffer")}function W(y,o,f,S,q){var nt=1,ct=y.length,qt=o.length;if(S!==void 0&&(S=String(S).toLowerCase(),S==="ucs2"||S==="ucs-2"||S==="utf16le"||S==="utf-16le")){if(y.length<2||o.length<2)return-1;nt=2,ct/=2,qt/=2,f/=2}function Gt(ke,je){return nt===1?ke[je]:ke.readUInt16BE(je*nt)}var Vt;if(q){var oe=-1;for(Vt=f;Vt<ct;Vt++)if(Gt(y,Vt)===Gt(o,oe===-1?0:Vt-oe)){if(oe===-1&&(oe=Vt),Vt-oe+1===qt)return oe*nt}else oe!==-1&&(Vt-=Vt-oe),oe=-1}else for(f+qt>ct&&(f=ct-qt),Vt=f;Vt>=0;Vt--){for(var te=!0,de=0;de<qt;de++)if(Gt(y,Vt+de)!==Gt(o,de)){te=!1;break}if(te)return Vt}return-1}m.prototype.includes=function(o,f,S){return this.indexOf(o,f,S)!==-1},m.prototype.indexOf=function(o,f,S){return wt(this,o,f,S,!0)},m.prototype.lastIndexOf=function(o,f,S){return wt(this,o,f,S,!1)};function V(y,o,f,S){f=Number(f)||0;var q=y.length-f;S?(S=Number(S),S>q&&(S=q)):S=q;var nt=o.length;S>nt/2&&(S=nt/2);for(var ct=0;ct<S;++ct){var qt=parseInt(o.substr(ct*2,2),16);if(ce(qt))return ct;y[f+ct]=qt}return ct}function gt(y,o,f,S){return Ft(Nt(o,y.length-f),y,f,S)}function tt(y,o,f,S){return Ft(Xt(o),y,f,S)}function _t(y,o,f,S){return Ft(Kt(o),y,f,S)}function dt(y,o,f,S){return Ft(Ht(o,y.length-f),y,f,S)}m.prototype.write=function(o,f,S,q){if(f===void 0)q="utf8",S=this.length,f=0;else if(S===void 0&&typeof f=="string")q=f,S=this.length,f=0;else if(isFinite(f))f=f>>>0,isFinite(S)?(S=S>>>0,q===void 0&&(q="utf8")):(q=S,S=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var nt=this.length-f;if((S===void 0||S>nt)&&(S=nt),o.length>0&&(S<0||f<0)||f>this.length)throw new RangeError("Attempt to write outside buffer bounds");q||(q="utf8");for(var ct=!1;;)switch(q){case"hex":return V(this,o,f,S);case"utf8":case"utf-8":return gt(this,o,f,S);case"ascii":case"latin1":case"binary":return tt(this,o,f,S);case"base64":return _t(this,o,f,S);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return dt(this,o,f,S);default:if(ct)throw new TypeError("Unknown encoding: "+q);q=(""+q).toLowerCase(),ct=!0}},m.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function yt(y,o,f){return o===0&&f===y.length?E.fromByteArray(y):E.fromByteArray(y.slice(o,f))}function Tt(y,o,f){f=Math.min(y.length,f);for(var S=[],q=o;q<f;){var nt=y[q],ct=null,qt=nt>239?4:nt>223?3:nt>191?2:1;if(q+qt<=f){var Gt,Vt,oe,te;switch(qt){case 1:nt<128&&(ct=nt);break;case 2:Gt=y[q+1],(Gt&192)===128&&(te=(nt&31)<<6|Gt&63,te>127&&(ct=te));break;case 3:Gt=y[q+1],Vt=y[q+2],(Gt&192)===128&&(Vt&192)===128&&(te=(nt&15)<<12|(Gt&63)<<6|Vt&63,te>2047&&(te<55296||te>57343)&&(ct=te));break;case 4:Gt=y[q+1],Vt=y[q+2],oe=y[q+3],(Gt&192)===128&&(Vt&192)===128&&(oe&192)===128&&(te=(nt&15)<<18|(Gt&63)<<12|(Vt&63)<<6|oe&63,te>65535&&te<1114112&&(ct=te))}}ct===null?(ct=65533,qt=1):ct>65535&&(ct-=65536,S.push(ct>>>10&1023|55296),ct=56320|ct&1023),S.push(ct),q+=qt}return ae(S)}var Jt=4096;function ae(y){var o=y.length;if(o<=Jt)return String.fromCharCode.apply(String,y);for(var f="",S=0;S<o;)f+=String.fromCharCode.apply(String,y.slice(S,S+=Jt));return f}function rt(y,o,f){var S="";f=Math.min(y.length,f);for(var q=o;q<f;++q)S+=String.fromCharCode(y[q]&127);return S}function ot(y,o,f){var S="";f=Math.min(y.length,f);for(var q=o;q<f;++q)S+=String.fromCharCode(y[q]);return S}function st(y,o,f){var S=y.length;(!o||o<0)&&(o=0),(!f||f<0||f>S)&&(f=S);for(var q="",nt=o;nt<f;++nt)q+=he[y[nt]];return q}function Mt(y,o,f){for(var S=y.slice(o,f),q="",nt=0;nt<S.length-1;nt+=2)q+=String.fromCharCode(S[nt]+S[nt+1]*256);return q}m.prototype.slice=function(o,f){var S=this.length;o=~~o,f=f===void 0?S:~~f,o<0?(o+=S,o<0&&(o=0)):o>S&&(o=S),f<0?(f+=S,f<0&&(f=0)):f>S&&(f=S),f<o&&(f=o);var q=this.subarray(o,f);return Object.setPrototypeOf(q,m.prototype),q};function It(y,o,f){if(y%1!==0||y<0)throw new RangeError("offset is not uint");if(y+o>f)throw new RangeError("Trying to access beyond buffer length")}m.prototype.readUintLE=m.prototype.readUIntLE=function(o,f,S){o=o>>>0,f=f>>>0,S||It(o,f,this.length);for(var q=this[o],nt=1,ct=0;++ct<f&&(nt*=256);)q+=this[o+ct]*nt;return q},m.prototype.readUintBE=m.prototype.readUIntBE=function(o,f,S){o=o>>>0,f=f>>>0,S||It(o,f,this.length);for(var q=this[o+--f],nt=1;f>0&&(nt*=256);)q+=this[o+--f]*nt;return q},m.prototype.readUint8=m.prototype.readUInt8=function(o,f){return o=o>>>0,f||It(o,1,this.length),this[o]},m.prototype.readUint16LE=m.prototype.readUInt16LE=function(o,f){return o=o>>>0,f||It(o,2,this.length),this[o]|this[o+1]<<8},m.prototype.readUint16BE=m.prototype.readUInt16BE=function(o,f){return o=o>>>0,f||It(o,2,this.length),this[o]<<8|this[o+1]},m.prototype.readUint32LE=m.prototype.readUInt32LE=function(o,f){return o=o>>>0,f||It(o,4,this.length),(this[o]|this[o+1]<<8|this[o+2]<<16)+this[o+3]*16777216},m.prototype.readUint32BE=m.prototype.readUInt32BE=function(o,f){return o=o>>>0,f||It(o,4,this.length),this[o]*16777216+(this[o+1]<<16|this[o+2]<<8|this[o+3])},m.prototype.readIntLE=function(o,f,S){o=o>>>0,f=f>>>0,S||It(o,f,this.length);for(var q=this[o],nt=1,ct=0;++ct<f&&(nt*=256);)q+=this[o+ct]*nt;return nt*=128,q>=nt&&(q-=Math.pow(2,8*f)),q},m.prototype.readIntBE=function(o,f,S){o=o>>>0,f=f>>>0,S||It(o,f,this.length);for(var q=f,nt=1,ct=this[o+--q];q>0&&(nt*=256);)ct+=this[o+--q]*nt;return nt*=128,ct>=nt&&(ct-=Math.pow(2,8*f)),ct},m.prototype.readInt8=function(o,f){return o=o>>>0,f||It(o,1,this.length),this[o]&128?(255-this[o]+1)*-1:this[o]},m.prototype.readInt16LE=function(o,f){o=o>>>0,f||It(o,2,this.length);var S=this[o]|this[o+1]<<8;return S&32768?S|4294901760:S},m.prototype.readInt16BE=function(o,f){o=o>>>0,f||It(o,2,this.length);var S=this[o+1]|this[o]<<8;return S&32768?S|4294901760:S},m.prototype.readInt32LE=function(o,f){return o=o>>>0,f||It(o,4,this.length),this[o]|this[o+1]<<8|this[o+2]<<16|this[o+3]<<24},m.prototype.readInt32BE=function(o,f){return o=o>>>0,f||It(o,4,this.length),this[o]<<24|this[o+1]<<16|this[o+2]<<8|this[o+3]},m.prototype.readFloatLE=function(o,f){return o=o>>>0,f||It(o,4,this.length),D.read(this,o,!0,23,4)},m.prototype.readFloatBE=function(o,f){return o=o>>>0,f||It(o,4,this.length),D.read(this,o,!1,23,4)},m.prototype.readDoubleLE=function(o,f){return o=o>>>0,f||It(o,8,this.length),D.read(this,o,!0,52,8)},m.prototype.readDoubleBE=function(o,f){return o=o>>>0,f||It(o,8,this.length),D.read(this,o,!1,52,8)};function jt(y,o,f,S,q,nt){if(!m.isBuffer(y))throw new TypeError('"buffer" argument must be a Buffer instance');if(o>q||o<nt)throw new RangeError('"value" argument is out of bounds');if(f+S>y.length)throw new RangeError("Index out of range")}m.prototype.writeUintLE=m.prototype.writeUIntLE=function(o,f,S,q){if(o=+o,f=f>>>0,S=S>>>0,!q){var nt=Math.pow(2,8*S)-1;jt(this,o,f,S,nt,0)}var ct=1,qt=0;for(this[f]=o&255;++qt<S&&(ct*=256);)this[f+qt]=o/ct&255;return f+S},m.prototype.writeUintBE=m.prototype.writeUIntBE=function(o,f,S,q){if(o=+o,f=f>>>0,S=S>>>0,!q){var nt=Math.pow(2,8*S)-1;jt(this,o,f,S,nt,0)}var ct=S-1,qt=1;for(this[f+ct]=o&255;--ct>=0&&(qt*=256);)this[f+ct]=o/qt&255;return f+S},m.prototype.writeUint8=m.prototype.writeUInt8=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,1,255,0),this[f]=o&255,f+1},m.prototype.writeUint16LE=m.prototype.writeUInt16LE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,2,65535,0),this[f]=o&255,this[f+1]=o>>>8,f+2},m.prototype.writeUint16BE=m.prototype.writeUInt16BE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,2,65535,0),this[f]=o>>>8,this[f+1]=o&255,f+2},m.prototype.writeUint32LE=m.prototype.writeUInt32LE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,4,4294967295,0),this[f+3]=o>>>24,this[f+2]=o>>>16,this[f+1]=o>>>8,this[f]=o&255,f+4},m.prototype.writeUint32BE=m.prototype.writeUInt32BE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,4,4294967295,0),this[f]=o>>>24,this[f+1]=o>>>16,this[f+2]=o>>>8,this[f+3]=o&255,f+4},m.prototype.writeIntLE=function(o,f,S,q){if(o=+o,f=f>>>0,!q){var nt=Math.pow(2,8*S-1);jt(this,o,f,S,nt-1,-nt)}var ct=0,qt=1,Gt=0;for(this[f]=o&255;++ct<S&&(qt*=256);)o<0&&Gt===0&&this[f+ct-1]!==0&&(Gt=1),this[f+ct]=(o/qt>>0)-Gt&255;return f+S},m.prototype.writeIntBE=function(o,f,S,q){if(o=+o,f=f>>>0,!q){var nt=Math.pow(2,8*S-1);jt(this,o,f,S,nt-1,-nt)}var ct=S-1,qt=1,Gt=0;for(this[f+ct]=o&255;--ct>=0&&(qt*=256);)o<0&&Gt===0&&this[f+ct+1]!==0&&(Gt=1),this[f+ct]=(o/qt>>0)-Gt&255;return f+S},m.prototype.writeInt8=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,1,127,-128),o<0&&(o=255+o+1),this[f]=o&255,f+1},m.prototype.writeInt16LE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,2,32767,-32768),this[f]=o&255,this[f+1]=o>>>8,f+2},m.prototype.writeInt16BE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,2,32767,-32768),this[f]=o>>>8,this[f+1]=o&255,f+2},m.prototype.writeInt32LE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,4,2147483647,-2147483648),this[f]=o&255,this[f+1]=o>>>8,this[f+2]=o>>>16,this[f+3]=o>>>24,f+4},m.prototype.writeInt32BE=function(o,f,S){return o=+o,f=f>>>0,S||jt(this,o,f,4,2147483647,-2147483648),o<0&&(o=4294967295+o+1),this[f]=o>>>24,this[f+1]=o>>>16,this[f+2]=o>>>8,this[f+3]=o&255,f+4};function Yt(y,o,f,S,q,nt){if(f+S>y.length)throw new RangeError("Index out of range");if(f<0)throw new RangeError("Index out of range")}function le(y,o,f,S,q){return o=+o,f=f>>>0,q||Yt(y,o,f,4),D.write(y,o,f,S,23,4),f+4}m.prototype.writeFloatLE=function(o,f,S){return le(this,o,f,!0,S)},m.prototype.writeFloatBE=function(o,f,S){return le(this,o,f,!1,S)};function ne(y,o,f,S,q){return o=+o,f=f>>>0,q||Yt(y,o,f,8),D.write(y,o,f,S,52,8),f+8}m.prototype.writeDoubleLE=function(o,f,S){return ne(this,o,f,!0,S)},m.prototype.writeDoubleBE=function(o,f,S){return ne(this,o,f,!1,S)},m.prototype.copy=function(o,f,S,q){if(!m.isBuffer(o))throw new TypeError("argument should be a Buffer");if(S||(S=0),!q&&q!==0&&(q=this.length),f>=o.length&&(f=o.length),f||(f=0),q>0&&q<S&&(q=S),q===S||o.length===0||this.length===0)return 0;if(f<0)throw new RangeError("targetStart out of bounds");if(S<0||S>=this.length)throw new RangeError("Index out of range");if(q<0)throw new RangeError("sourceEnd out of bounds");q>this.length&&(q=this.length),o.length-f<q-S&&(q=o.length-f+S);var nt=q-S;return this===o&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(f,S,q):Uint8Array.prototype.set.call(o,this.subarray(S,q),f),nt},m.prototype.fill=function(o,f,S,q){if(typeof o=="string"){if(typeof f=="string"?(q=f,f=0,S=this.length):typeof S=="string"&&(q=S,S=this.length),q!==void 0&&typeof q!="string")throw new TypeError("encoding must be a string");if(typeof q=="string"&&!m.isEncoding(q))throw new TypeError("Unknown encoding: "+q);if(o.length===1){var nt=o.charCodeAt(0);(q==="utf8"&&nt<128||q==="latin1")&&(o=nt)}}else typeof o=="number"?o=o&255:typeof o=="boolean"&&(o=Number(o));if(f<0||this.length<f||this.length<S)throw new RangeError("Out of range index");if(S<=f)return this;f=f>>>0,S=S===void 0?this.length:S>>>0,o||(o=0);var ct;if(typeof o=="number")for(ct=f;ct<S;++ct)this[ct]=o;else{var qt=m.isBuffer(o)?o:m.from(o,q),Gt=qt.length;if(Gt===0)throw new TypeError('The value "'+o+'" is invalid for argument "value"');for(ct=0;ct<S-f;++ct)this[ct+f]=qt[ct%Gt]}return this};var Wt=/[^+/0-9A-Za-z-_]/g;function Dt(y){if(y=y.split("=")[0],y=y.trim().replace(Wt,""),y.length<2)return"";for(;y.length%4!==0;)y=y+"=";return y}function Nt(y,o){o=o||1/0;for(var f,S=y.length,q=null,nt=[],ct=0;ct<S;++ct){if(f=y.charCodeAt(ct),f>55295&&f<57344){if(!q){if(f>56319){(o-=3)>-1&&nt.push(239,191,189);continue}else if(ct+1===S){(o-=3)>-1&&nt.push(239,191,189);continue}q=f;continue}if(f<56320){(o-=3)>-1&&nt.push(239,191,189),q=f;continue}f=(q-55296<<10|f-56320)+65536}else q&&(o-=3)>-1&&nt.push(239,191,189);if(q=null,f<128){if((o-=1)<0)break;nt.push(f)}else if(f<2048){if((o-=2)<0)break;nt.push(f>>6|192,f&63|128)}else if(f<65536){if((o-=3)<0)break;nt.push(f>>12|224,f>>6&63|128,f&63|128)}else if(f<1114112){if((o-=4)<0)break;nt.push(f>>18|240,f>>12&63|128,f>>6&63|128,f&63|128)}else throw new Error("Invalid code point")}return nt}function Xt(y){for(var o=[],f=0;f<y.length;++f)o.push(y.charCodeAt(f)&255);return o}function Ht(y,o){for(var f,S,q,nt=[],ct=0;ct<y.length&&!((o-=2)<0);++ct)f=y.charCodeAt(ct),S=f>>8,q=f%256,nt.push(q),nt.push(S);return nt}function Kt(y){return E.toByteArray(Dt(y))}function Ft(y,o,f,S){for(var q=0;q<S&&!(q+f>=o.length||q>=y.length);++q)o[q+f]=y[q];return q}function Lt(y,o){return y instanceof o||y!=null&&y.constructor!=null&&y.constructor.name!=null&&y.constructor.name===o.name}function ce(y){return y!==y}var he=(function(){for(var y="0123456789abcdef",o=new Array(256),f=0;f<16;++f)for(var S=f*16,q=0;q<16;++q)o[S+q]=y[f]+y[q];return o})()})(jn)),jn}/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var ys;function ea(){return ys||(ys=1,(function(b,E){var D=Bu(),R=D.Buffer;function C(T,m){for(var g in T)m[g]=T[g]}R.from&&R.alloc&&R.allocUnsafe&&R.allocUnsafeSlow?b.exports=D:(C(D,E),E.Buffer=A);function A(T,m,g){return R(T,m,g)}A.prototype=Object.create(R.prototype),C(R,A),A.from=function(T,m,g){if(typeof T=="number")throw new TypeError("Argument must not be a number");return R(T,m,g)},A.alloc=function(T,m,g){if(typeof T!="number")throw new TypeError("Argument must be a number");var P=R(T);return m!==void 0?typeof g=="string"?P.fill(m,g):P.fill(m):P.fill(0),P},A.allocUnsafe=function(T){if(typeof T!="number")throw new TypeError("Argument must be a number");return R(T)},A.allocUnsafeSlow=function(T){if(typeof T!="number")throw new TypeError("Argument must be a number");return D.SlowBuffer(T)}})(pn,pn.exports)),pn.exports}var qn,vs;function Ou(){if(vs)return qn;vs=1;var b={}.toString;return qn=Array.isArray||function(E){return b.call(E)=="[object Array]"},qn}var Ln,_s;function Jr(){return _s||(_s=1,Ln=TypeError),Ln}var zn,bs;function qc(){return bs||(bs=1,zn=Object),zn}var Hn,xs;function $u(){return xs||(xs=1,Hn=Error),Hn}var Gn,Es;function Cu(){return Es||(Es=1,Gn=EvalError),Gn}var Zn,Ss;function Pu(){return Ss||(Ss=1,Zn=RangeError),Zn}var Wn,As;function Fu(){return As||(As=1,Wn=ReferenceError),Wn}var Xn,ks;function Lc(){return ks||(ks=1,Xn=SyntaxError),Xn}var Vn,Rs;function Du(){return Rs||(Rs=1,Vn=URIError),Vn}var Yn,Ts;function Uu(){return Ts||(Ts=1,Yn=Math.abs),Yn}var Kn,Is;function Nu(){return Is||(Is=1,Kn=Math.floor),Kn}var Jn,Bs;function Mu(){return Bs||(Bs=1,Jn=Math.max),Jn}var Qn,Os;function ju(){return Os||(Os=1,Qn=Math.min),Qn}var ti,$s;function qu(){return $s||($s=1,ti=Math.pow),ti}var ei,Cs;function Lu(){return Cs||(Cs=1,ei=Math.round),ei}var ri,Ps;function zu(){return Ps||(Ps=1,ri=Number.isNaN||function(E){return E!==E}),ri}var ni,Fs;function Hu(){if(Fs)return ni;Fs=1;var b=zu();return ni=function(D){return b(D)||D===0?D:D<0?-1:1},ni}var ii,Ds;function Gu(){return Ds||(Ds=1,ii=Object.getOwnPropertyDescriptor),ii}var ai,Us;function Qr(){if(Us)return ai;Us=1;var b=Gu();if(b)try{b([],"length")}catch{b=null}return ai=b,ai}var oi,Ns;function mn(){if(Ns)return oi;Ns=1;var b=Object.defineProperty||!1;if(b)try{b({},"a",{value:1})}catch{b=!1}return oi=b,oi}var si,Ms;function zc(){return Ms||(Ms=1,si=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var E={},D=Symbol("test"),R=Object(D);if(typeof D=="string"||Object.prototype.toString.call(D)!=="[object Symbol]"||Object.prototype.toString.call(R)!=="[object Symbol]")return!1;var C=42;E[D]=C;for(var A in E)return!1;if(typeof Object.keys=="function"&&Object.keys(E).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(E).length!==0)return!1;var T=Object.getOwnPropertySymbols(E);if(T.length!==1||T[0]!==D||!Object.prototype.propertyIsEnumerable.call(E,D))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var m=Object.getOwnPropertyDescriptor(E,D);if(m.value!==C||m.enumerable!==!0)return!1}return!0}),si}var ci,js;function Zu(){if(js)return ci;js=1;var b=typeof Symbol<"u"&&Symbol,E=zc();return ci=function(){return typeof b!="function"||typeof Symbol!="function"||typeof b("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:E()},ci}var fi,qs;function Hc(){return qs||(qs=1,fi=typeof Reflect<"u"&&Reflect.getPrototypeOf||null),fi}var ui,Ls;function Gc(){if(Ls)return ui;Ls=1;var b=qc();return ui=b.getPrototypeOf||null,ui}var li,zs;function Wu(){if(zs)return li;zs=1;var b="Function.prototype.bind called on incompatible ",E=Object.prototype.toString,D=Math.max,R="[object Function]",C=function(g,P){for(var $=[],k=0;k<g.length;k+=1)$[k]=g[k];for(var F=0;F<P.length;F+=1)$[F+g.length]=P[F];return $},A=function(g,P){for(var $=[],k=P,F=0;k<g.length;k+=1,F+=1)$[F]=g[k];return $},T=function(m,g){for(var P="",$=0;$<m.length;$+=1)P+=m[$],$+1<m.length&&(P+=g);return P};return li=function(g){var P=this;if(typeof P!="function"||E.apply(P)!==R)throw new TypeError(b+P);for(var $=A(arguments,1),k,F=function(){if(this instanceof k){var G=P.apply(this,C($,arguments));return Object(G)===G?G:this}return P.apply(g,C($,arguments))},M=D(0,P.length-$.length),Q=[],ut=0;ut<M;ut++)Q[ut]="$"+ut;if(k=Function("binder","return function ("+T(Q,",")+"){ return binder.apply(this,arguments); }")(F),P.prototype){var H=function(){};H.prototype=P.prototype,k.prototype=new H,H.prototype=null}return k},li}var hi,Hs;function tn(){if(Hs)return hi;Hs=1;var b=Wu();return hi=Function.prototype.bind||b,hi}var di,Gs;function ra(){return Gs||(Gs=1,di=Function.prototype.call),di}var pi,Zs;function na(){return Zs||(Zs=1,pi=Function.prototype.apply),pi}var wi,Ws;function Xu(){return Ws||(Ws=1,wi=typeof Reflect<"u"&&Reflect&&Reflect.apply),wi}var mi,Xs;function Zc(){if(Xs)return mi;Xs=1;var b=tn(),E=na(),D=ra(),R=Xu();return mi=R||b.call(D,E),mi}var gi,Vs;function ia(){if(Vs)return gi;Vs=1;var b=tn(),E=Jr(),D=ra(),R=Zc();return gi=function(A){if(A.length<1||typeof A[0]!="function")throw new E("a function is required");return R(b,D,A)},gi}var yi,Ys;function Vu(){if(Ys)return yi;Ys=1;var b=ia(),E=Qr(),D;try{D=[].__proto__===Array.prototype}catch(T){if(!T||typeof T!="object"||!("code"in T)||T.code!=="ERR_PROTO_ACCESS")throw T}var R=!!D&&E&&E(Object.prototype,"__proto__"),C=Object,A=C.getPrototypeOf;return yi=R&&typeof R.get=="function"?b([R.get]):typeof A=="function"?function(m){return A(m==null?m:C(m))}:!1,yi}var vi,Ks;function Wc(){if(Ks)return vi;Ks=1;var b=Hc(),E=Gc(),D=Vu();return vi=b?function(C){return b(C)}:E?function(C){if(!C||typeof C!="object"&&typeof C!="function")throw new TypeError("getProto: not an object");return E(C)}:D?function(C){return D(C)}:null,vi}var _i,Js;function Yu(){if(Js)return _i;Js=1;var b=Function.prototype.call,E=Object.prototype.hasOwnProperty,D=tn();return _i=D.call(b,E),_i}var bi,Qs;function Xc(){if(Qs)return bi;Qs=1;var b,E=qc(),D=$u(),R=Cu(),C=Pu(),A=Fu(),T=Lc(),m=Jr(),g=Du(),P=Uu(),$=Nu(),k=Mu(),F=ju(),M=qu(),Q=Lu(),ut=Hu(),H=Function,G=function(Xt){try{return H('"use strict"; return ('+Xt+").constructor;")()}catch{}},K=Qr(),L=mn(),at=function(){throw new m},ht=K?(function(){try{return arguments.callee,at}catch{try{return K(arguments,"callee").get}catch{return at}}})():at,wt=Zu()(),W=Wc(),V=Gc(),gt=Hc(),tt=na(),_t=ra(),dt={},yt=typeof Uint8Array>"u"||!W?b:W(Uint8Array),Tt={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?b:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?b:ArrayBuffer,"%ArrayIteratorPrototype%":wt&&W?W([][Symbol.iterator]()):b,"%AsyncFromSyncIteratorPrototype%":b,"%AsyncFunction%":dt,"%AsyncGenerator%":dt,"%AsyncGeneratorFunction%":dt,"%AsyncIteratorPrototype%":dt,"%Atomics%":typeof Atomics>"u"?b:Atomics,"%BigInt%":typeof BigInt>"u"?b:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?b:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?b:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?b:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":D,"%eval%":eval,"%EvalError%":R,"%Float16Array%":typeof Float16Array>"u"?b:Float16Array,"%Float32Array%":typeof Float32Array>"u"?b:Float32Array,"%Float64Array%":typeof Float64Array>"u"?b:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?b:FinalizationRegistry,"%Function%":H,"%GeneratorFunction%":dt,"%Int8Array%":typeof Int8Array>"u"?b:Int8Array,"%Int16Array%":typeof Int16Array>"u"?b:Int16Array,"%Int32Array%":typeof Int32Array>"u"?b:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":wt&&W?W(W([][Symbol.iterator]())):b,"%JSON%":typeof JSON=="object"?JSON:b,"%Map%":typeof Map>"u"?b:Map,"%MapIteratorPrototype%":typeof Map>"u"||!wt||!W?b:W(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":E,"%Object.getOwnPropertyDescriptor%":K,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?b:Promise,"%Proxy%":typeof Proxy>"u"?b:Proxy,"%RangeError%":C,"%ReferenceError%":A,"%Reflect%":typeof Reflect>"u"?b:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?b:Set,"%SetIteratorPrototype%":typeof Set>"u"||!wt||!W?b:W(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?b:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":wt&&W?W(""[Symbol.iterator]()):b,"%Symbol%":wt?Symbol:b,"%SyntaxError%":T,"%ThrowTypeError%":ht,"%TypedArray%":yt,"%TypeError%":m,"%Uint8Array%":typeof Uint8Array>"u"?b:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?b:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?b:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?b:Uint32Array,"%URIError%":g,"%WeakMap%":typeof WeakMap>"u"?b:WeakMap,"%WeakRef%":typeof WeakRef>"u"?b:WeakRef,"%WeakSet%":typeof WeakSet>"u"?b:WeakSet,"%Function.prototype.call%":_t,"%Function.prototype.apply%":tt,"%Object.defineProperty%":L,"%Object.getPrototypeOf%":V,"%Math.abs%":P,"%Math.floor%":$,"%Math.max%":k,"%Math.min%":F,"%Math.pow%":M,"%Math.round%":Q,"%Math.sign%":ut,"%Reflect.getPrototypeOf%":gt};if(W)try{null.error}catch(Xt){var Jt=W(W(Xt));Tt["%Error.prototype%"]=Jt}var ae=function Xt(Ht){var Kt;if(Ht==="%AsyncFunction%")Kt=G("async function () {}");else if(Ht==="%GeneratorFunction%")Kt=G("function* () {}");else if(Ht==="%AsyncGeneratorFunction%")Kt=G("async function* () {}");else if(Ht==="%AsyncGenerator%"){var Ft=Xt("%AsyncGeneratorFunction%");Ft&&(Kt=Ft.prototype)}else if(Ht==="%AsyncIteratorPrototype%"){var Lt=Xt("%AsyncGenerator%");Lt&&W&&(Kt=W(Lt.prototype))}return Tt[Ht]=Kt,Kt},rt={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},ot=tn(),st=Yu(),Mt=ot.call(_t,Array.prototype.concat),It=ot.call(tt,Array.prototype.splice),jt=ot.call(_t,String.prototype.replace),Yt=ot.call(_t,String.prototype.slice),le=ot.call(_t,RegExp.prototype.exec),ne=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Wt=/\\(\\)?/g,Dt=function(Ht){var Kt=Yt(Ht,0,1),Ft=Yt(Ht,-1);if(Kt==="%"&&Ft!=="%")throw new T("invalid intrinsic syntax, expected closing `%`");if(Ft==="%"&&Kt!=="%")throw new T("invalid intrinsic syntax, expected opening `%`");var Lt=[];return jt(Ht,ne,function(ce,he,y,o){Lt[Lt.length]=y?jt(o,Wt,"$1"):he||ce}),Lt},Nt=function(Ht,Kt){var Ft=Ht,Lt;if(st(rt,Ft)&&(Lt=rt[Ft],Ft="%"+Lt[0]+"%"),st(Tt,Ft)){var ce=Tt[Ft];if(ce===dt&&(ce=ae(Ft)),typeof ce>"u"&&!Kt)throw new m("intrinsic "+Ht+" exists, but is not available. Please file an issue!");return{alias:Lt,name:Ft,value:ce}}throw new T("intrinsic "+Ht+" does not exist!")};return bi=function(Ht,Kt){if(typeof Ht!="string"||Ht.length===0)throw new m("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof Kt!="boolean")throw new m('"allowMissing" argument must be a boolean');if(le(/^%?[^%]*%?$/,Ht)===null)throw new T("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Ft=Dt(Ht),Lt=Ft.length>0?Ft[0]:"",ce=Nt("%"+Lt+"%",Kt),he=ce.name,y=ce.value,o=!1,f=ce.alias;f&&(Lt=f[0],It(Ft,Mt([0,1],f)));for(var S=1,q=!0;S<Ft.length;S+=1){var nt=Ft[S],ct=Yt(nt,0,1),qt=Yt(nt,-1);if((ct==='"'||ct==="'"||ct==="`"||qt==='"'||qt==="'"||qt==="`")&&ct!==qt)throw new T("property names with quotes must have matching quotes");if((nt==="constructor"||!q)&&(o=!0),Lt+="."+nt,he="%"+Lt+"%",st(Tt,he))y=Tt[he];else if(y!=null){if(!(nt in y)){if(!Kt)throw new m("base intrinsic for "+Ht+" exists, but the property is not available.");return}if(K&&S+1>=Ft.length){var Gt=K(y,nt);q=!!Gt,q&&"get"in Gt&&!("originalValue"in Gt.get)?y=Gt.get:y=y[nt]}else q=st(y,nt),y=y[nt];q&&!o&&(Tt[he]=y)}}return y},bi}var xi,tc;function Vc(){if(tc)return xi;tc=1;var b=Xc(),E=ia(),D=E([b("%String.prototype.indexOf%")]);return xi=function(C,A){var T=b(C,!!A);return typeof T=="function"&&D(C,".prototype.")>-1?E([T]):T},xi}var Ei,ec;function Ku(){if(ec)return Ei;ec=1;var b=Function.prototype.toString,E=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,D,R;if(typeof E=="function"&&typeof Object.defineProperty=="function")try{D=Object.defineProperty({},"length",{get:function(){throw R}}),R={},E(function(){throw 42},null,D)}catch(K){K!==R&&(E=null)}else E=null;var C=/^\s*class\b/,A=function(L){try{var at=b.call(L);return C.test(at)}catch{return!1}},T=function(L){try{return A(L)?!1:(b.call(L),!0)}catch{return!1}},m=Object.prototype.toString,g="[object Object]",P="[object Function]",$="[object GeneratorFunction]",k="[object HTMLAllCollection]",F="[object HTML document.all class]",M="[object HTMLCollection]",Q=typeof Symbol=="function"&&!!Symbol.toStringTag,ut=!(0 in[,]),H=function(){return!1};if(typeof document=="object"){var G=document.all;m.call(G)===m.call(document.all)&&(H=function(L){if((ut||!L)&&(typeof L>"u"||typeof L=="object"))try{var at=m.call(L);return(at===k||at===F||at===M||at===g)&&L("")==null}catch{}return!1})}return Ei=E?function(L){if(H(L))return!0;if(!L||typeof L!="function"&&typeof L!="object")return!1;try{E(L,null,D)}catch(at){if(at!==R)return!1}return!A(L)&&T(L)}:function(L){if(H(L))return!0;if(!L||typeof L!="function"&&typeof L!="object")return!1;if(Q)return T(L);if(A(L))return!1;var at=m.call(L);return at!==P&&at!==$&&!/^\[object HTML/.test(at)?!1:T(L)},Ei}var Si,rc;function Ju(){if(rc)return Si;rc=1;var b=Ku(),E=Object.prototype.toString,D=Object.prototype.hasOwnProperty,R=function(g,P,$){for(var k=0,F=g.length;k<F;k++)D.call(g,k)&&($==null?P(g[k],k,g):P.call($,g[k],k,g))},C=function(g,P,$){for(var k=0,F=g.length;k<F;k++)$==null?P(g.charAt(k),k,g):P.call($,g.charAt(k),k,g)},A=function(g,P,$){for(var k in g)D.call(g,k)&&($==null?P(g[k],k,g):P.call($,g[k],k,g))};function T(m){return E.call(m)==="[object Array]"}return Si=function(g,P,$){if(!b(P))throw new TypeError("iterator must be a function");var k;arguments.length>=3&&(k=$),T(g)?R(g,P,k):typeof g=="string"?C(g,P,k):A(g,P,k)},Si}var Ai,nc;function Qu(){return nc||(nc=1,Ai=["Float16Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]),Ai}var ki,ic;function tl(){if(ic)return ki;ic=1;var b=Qu(),E=typeof globalThis>"u"?jc:globalThis;return ki=function(){for(var R=[],C=0;C<b.length;C++)typeof E[b[C]]=="function"&&(R[R.length]=b[C]);return R},ki}var Ri={exports:{}},Ti,ac;function el(){if(ac)return Ti;ac=1;var b=mn(),E=Lc(),D=Jr(),R=Qr();return Ti=function(A,T,m){if(!A||typeof A!="object"&&typeof A!="function")throw new D("`obj` must be an object or a function`");if(typeof T!="string"&&typeof T!="symbol")throw new D("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new D("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new D("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new D("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new D("`loose`, if provided, must be a boolean");var g=arguments.length>3?arguments[3]:null,P=arguments.length>4?arguments[4]:null,$=arguments.length>5?arguments[5]:null,k=arguments.length>6?arguments[6]:!1,F=!!R&&R(A,T);if(b)b(A,T,{configurable:$===null&&F?F.configurable:!$,enumerable:g===null&&F?F.enumerable:!g,value:m,writable:P===null&&F?F.writable:!P});else if(k||!g&&!P&&!$)A[T]=m;else throw new E("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")},Ti}var Ii,oc;function rl(){if(oc)return Ii;oc=1;var b=mn(),E=function(){return!!b};return E.hasArrayLengthDefineBug=function(){if(!b)return null;try{return b([],"length",{value:1}).length!==1}catch{return!0}},Ii=E,Ii}var Bi,sc;function nl(){if(sc)return Bi;sc=1;var b=Xc(),E=el(),D=rl()(),R=Qr(),C=Jr(),A=b("%Math.floor%");return Bi=function(m,g){if(typeof m!="function")throw new C("`fn` is not a function");if(typeof g!="number"||g<0||g>4294967295||A(g)!==g)throw new C("`length` must be a positive 32-bit integer");var P=arguments.length>2&&!!arguments[2],$=!0,k=!0;if("length"in m&&R){var F=R(m,"length");F&&!F.configurable&&($=!1),F&&!F.writable&&(k=!1)}return($||k||!P)&&(D?E(m,"length",g,!0,!0):E(m,"length",g)),m},Bi}var Oi,cc;function il(){if(cc)return Oi;cc=1;var b=tn(),E=na(),D=Zc();return Oi=function(){return D(b,E,arguments)},Oi}var fc;function al(){return fc||(fc=1,(function(b){var E=nl(),D=mn(),R=ia(),C=il();b.exports=function(T){var m=R(arguments),g=T.length-(arguments.length-1);return E(m,1+(g>0?g:0),!0)},D?D(b.exports,"apply",{value:C}):b.exports.apply=C})(Ri)),Ri.exports}var $i,uc;function ol(){if(uc)return $i;uc=1;var b=zc();return $i=function(){return b()&&!!Symbol.toStringTag},$i}var Ci,lc;function sl(){if(lc)return Ci;lc=1;var b=Ju(),E=tl(),D=al(),R=Vc(),C=Qr(),A=Wc(),T=R("Object.prototype.toString"),m=ol()(),g=typeof globalThis>"u"?jc:globalThis,P=E(),$=R("String.prototype.slice"),k=R("Array.prototype.indexOf",!0)||function(H,G){for(var K=0;K<H.length;K+=1)if(H[K]===G)return K;return-1},F={__proto__:null};m&&C&&A?b(P,function(ut){var H=new g[ut];if(Symbol.toStringTag in H&&A){var G=A(H),K=C(G,Symbol.toStringTag);if(!K&&G){var L=A(G);K=C(L,Symbol.toStringTag)}if(K&&K.get){var at=D(K.get);F["$"+ut]=at}}}):b(P,function(ut){var H=new g[ut],G=H.slice||H.set;if(G){var K=D(G);F["$"+ut]=K}});var M=function(H){var G=!1;return b(F,function(K,L){if(!G)try{"$"+K(H)===L&&(G=$(L,1))}catch{}}),G},Q=function(H){var G=!1;return b(F,function(K,L){if(!G)try{K(H),G=$(L,1)}catch{}}),G};return Ci=function(H){if(!H||typeof H!="object")return!1;if(!m){var G=$(T(H),8,-1);return k(P,G)>-1?G:G!=="Object"?!1:Q(H)}return C?M(H):null},Ci}var Pi,hc;function cl(){if(hc)return Pi;hc=1;var b=sl();return Pi=function(D){return!!b(D)},Pi}var Fi,dc;function fl(){if(dc)return Fi;dc=1;var b=Jr(),E=Vc(),D=E("TypedArray.prototype.buffer",!0),R=cl();return Fi=D||function(A){if(!R(A))throw new b("Not a Typed Array");return A.buffer},Fi}var Di,pc;function ul(){if(pc)return Di;pc=1;var b=ea().Buffer,E=Ou(),D=fl(),R=ArrayBuffer.isView||function(g){try{return D(g),!0}catch{return!1}},C=typeof Uint8Array<"u",A=typeof ArrayBuffer<"u"&&typeof Uint8Array<"u",T=A&&(b.prototype instanceof Uint8Array||b.TYPED_ARRAY_SUPPORT);return Di=function(g,P){if(b.isBuffer(g))return g.constructor&&!("isBuffer"in g)?b.from(g):g;if(typeof g=="string")return b.from(g,P);if(A&&R(g)){if(g.byteLength===0)return b.alloc(0);if(T){var $=b.from(g.buffer,g.byteOffset,g.byteLength);if($.byteLength===g.byteLength)return $}var k=g instanceof Uint8Array?g:new Uint8Array(g.buffer,g.byteOffset,g.byteLength),F=b.from(k);if(F.length===g.byteLength)return F}if(C&&g instanceof Uint8Array)return b.from(g);var M=E(g);if(M)for(var Q=0;Q<g.length;Q+=1){var ut=g[Q];if(typeof ut!="number"||ut<0||ut>255||~~ut!==ut)throw new RangeError("Array items must be numbers in the range 0-255.")}if(M||b.isBuffer(g)&&g.constructor&&typeof g.constructor.isBuffer=="function"&&g.constructor.isBuffer(g))return b.from(g);throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.')},Di}var Ui,wc;function ll(){if(wc)return Ui;wc=1;var b=ea().Buffer,E=ul();function D(R,C){this._block=b.alloc(R),this._finalSize=C,this._blockSize=R,this._len=0}return D.prototype.update=function(R,C){R=E(R,C||"utf8");for(var A=this._block,T=this._blockSize,m=R.length,g=this._len,P=0;P<m;){for(var $=g%T,k=Math.min(m-P,T-$),F=0;F<k;F++)A[$+F]=R[P+F];g+=k,P+=k,g%T===0&&this._update(A)}return this._len+=m,this},D.prototype.digest=function(R){var C=this._len%this._blockSize;this._block[C]=128,this._block.fill(0,C+1),C>=this._finalSize&&(this._update(this._block),this._block.fill(0));var A=this._len*8;if(A<=4294967295)this._block.writeUInt32BE(A,this._blockSize-4);else{var T=(A&4294967295)>>>0,m=(A-T)/4294967296;this._block.writeUInt32BE(m,this._blockSize-8),this._block.writeUInt32BE(T,this._blockSize-4)}this._update(this._block);var g=this._hash();return R?g.toString(R):g},D.prototype._update=function(){throw new Error("_update must be implemented by subclass")},Ui=D,Ui}var Ni,mc;function hl(){if(mc)return Ni;mc=1;var b=Ru(),E=ll(),D=ea().Buffer,R=[1518500249,1859775393,-1894007588,-899497514],C=new Array(80);function A(){this.init(),this._w=C,E.call(this,64,56)}b(A,E),A.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this};function T($){return $<<1|$>>>31}function m($){return $<<5|$>>>27}function g($){return $<<30|$>>>2}function P($,k,F,M){return $===0?k&F|~k&M:$===2?k&F|k&M|F&M:k^F^M}return A.prototype._update=function($){for(var k=this._w,F=this._a|0,M=this._b|0,Q=this._c|0,ut=this._d|0,H=this._e|0,G=0;G<16;++G)k[G]=$.readInt32BE(G*4);for(;G<80;++G)k[G]=T(k[G-3]^k[G-8]^k[G-14]^k[G-16]);for(var K=0;K<80;++K){var L=~~(K/20),at=m(F)+P(L,M,Q,ut)+H+k[K]+R[L]|0;H=ut,ut=Q,Q=g(M),M=F,F=at}this._a=F+this._a|0,this._b=M+this._b|0,this._c=Q+this._c|0,this._d=ut+this._d|0,this._e=H+this._e|0},A.prototype._hash=function(){var $=D.allocUnsafe(20);return $.writeInt32BE(this._a|0,0),$.writeInt32BE(this._b|0,4),$.writeInt32BE(this._c|0,8),$.writeInt32BE(this._d|0,12),$.writeInt32BE(this._e|0,16),$},Ni=A,Ni}var Mi={};/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */var gc;function dl(){return gc||(gc=1,(function(b){(function(E){E(typeof DO_NOT_EXPORT_CRC>"u"?b:{})})(function(E){E.version="1.2.2";function D(){for(var V=0,gt=new Array(256),tt=0;tt!=256;++tt)V=tt,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,V=V&1?-306674912^V>>>1:V>>>1,gt[tt]=V;return typeof Int32Array<"u"?new Int32Array(gt):gt}var R=D();function C(V){var gt=0,tt=0,_t=0,dt=typeof Int32Array<"u"?new Int32Array(4096):new Array(4096);for(_t=0;_t!=256;++_t)dt[_t]=V[_t];for(_t=0;_t!=256;++_t)for(tt=V[_t],gt=256+_t;gt<4096;gt+=256)tt=dt[gt]=tt>>>8^V[tt&255];var yt=[];for(_t=1;_t!=16;++_t)yt[_t-1]=typeof Int32Array<"u"?dt.subarray(_t*256,_t*256+256):dt.slice(_t*256,_t*256+256);return yt}var A=C(R),T=A[0],m=A[1],g=A[2],P=A[3],$=A[4],k=A[5],F=A[6],M=A[7],Q=A[8],ut=A[9],H=A[10],G=A[11],K=A[12],L=A[13],at=A[14];function ht(V,gt){for(var tt=gt^-1,_t=0,dt=V.length;_t<dt;)tt=tt>>>8^R[(tt^V.charCodeAt(_t++))&255];return~tt}function wt(V,gt){for(var tt=gt^-1,_t=V.length-15,dt=0;dt<_t;)tt=at[V[dt++]^tt&255]^L[V[dt++]^tt>>8&255]^K[V[dt++]^tt>>16&255]^G[V[dt++]^tt>>>24]^H[V[dt++]]^ut[V[dt++]]^Q[V[dt++]]^M[V[dt++]]^F[V[dt++]]^k[V[dt++]]^$[V[dt++]]^P[V[dt++]]^g[V[dt++]]^m[V[dt++]]^T[V[dt++]]^R[V[dt++]];for(_t+=15;dt<_t;)tt=tt>>>8^R[(tt^V[dt++])&255];return~tt}function W(V,gt){for(var tt=gt^-1,_t=0,dt=V.length,yt=0,Tt=0;_t<dt;)yt=V.charCodeAt(_t++),yt<128?tt=tt>>>8^R[(tt^yt)&255]:yt<2048?(tt=tt>>>8^R[(tt^(192|yt>>6&31))&255],tt=tt>>>8^R[(tt^(128|yt&63))&255]):yt>=55296&&yt<57344?(yt=(yt&1023)+64,Tt=V.charCodeAt(_t++)&1023,tt=tt>>>8^R[(tt^(240|yt>>8&7))&255],tt=tt>>>8^R[(tt^(128|yt>>2&63))&255],tt=tt>>>8^R[(tt^(128|Tt>>6&15|(yt&3)<<4))&255],tt=tt>>>8^R[(tt^(128|Tt&63))&255]):(tt=tt>>>8^R[(tt^(224|yt>>12&15))&255],tt=tt>>>8^R[(tt^(128|yt>>6&63))&255],tt=tt>>>8^R[(tt^(128|yt&63))&255]);return~tt}E.table=R,E.bstr=ht,E.buf=wt,E.str=W})})(Mi)),Mi}var ji={},yc;function tr(){return yc||(yc=1,(function(b){var E=typeof Uint8Array<"u"&&typeof Uint16Array<"u"&&typeof Int32Array<"u";function D(A,T){return Object.prototype.hasOwnProperty.call(A,T)}b.assign=function(A){for(var T=Array.prototype.slice.call(arguments,1);T.length;){var m=T.shift();if(m){if(typeof m!="object")throw new TypeError(m+"must be non-object");for(var g in m)D(m,g)&&(A[g]=m[g])}}return A},b.shrinkBuf=function(A,T){return A.length===T?A:A.subarray?A.subarray(0,T):(A.length=T,A)};var R={arraySet:function(A,T,m,g,P){if(T.subarray&&A.subarray){A.set(T.subarray(m,m+g),P);return}for(var $=0;$<g;$++)A[P+$]=T[m+$]},flattenChunks:function(A){var T,m,g,P,$,k;for(g=0,T=0,m=A.length;T<m;T++)g+=A[T].length;for(k=new Uint8Array(g),P=0,T=0,m=A.length;T<m;T++)$=A[T],k.set($,P),P+=$.length;return k}},C={arraySet:function(A,T,m,g,P){for(var $=0;$<g;$++)A[P+$]=T[m+$]},flattenChunks:function(A){return[].concat.apply([],A)}};b.setTyped=function(A){A?(b.Buf8=Uint8Array,b.Buf16=Uint16Array,b.Buf32=Int32Array,b.assign(b,R)):(b.Buf8=Array,b.Buf16=Array,b.Buf32=Array,b.assign(b,C))},b.setTyped(E)})(ji)),ji}var Sr={},ze={},lr={},vc;function pl(){if(vc)return lr;vc=1;var b=tr(),E=4,D=0,R=1,C=2;function A(v){for(var ft=v.length;--ft>=0;)v[ft]=0}var T=0,m=1,g=2,P=3,$=258,k=29,F=256,M=F+1+k,Q=30,ut=19,H=2*M+1,G=15,K=16,L=7,at=256,ht=16,wt=17,W=18,V=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],gt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],tt=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],_t=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],dt=512,yt=new Array((M+2)*2);A(yt);var Tt=new Array(Q*2);A(Tt);var Jt=new Array(dt);A(Jt);var ae=new Array($-P+1);A(ae);var rt=new Array(k);A(rt);var ot=new Array(Q);A(ot);function st(v,ft,pt,Rt,N){this.static_tree=v,this.extra_bits=ft,this.extra_base=pt,this.elems=Rt,this.max_length=N,this.has_stree=v&&v.length}var Mt,It,jt;function Yt(v,ft){this.dyn_tree=v,this.max_code=0,this.stat_desc=ft}function le(v){return v<256?Jt[v]:Jt[256+(v>>>7)]}function ne(v,ft){v.pending_buf[v.pending++]=ft&255,v.pending_buf[v.pending++]=ft>>>8&255}function Wt(v,ft,pt){v.bi_valid>K-pt?(v.bi_buf|=ft<<v.bi_valid&65535,ne(v,v.bi_buf),v.bi_buf=ft>>K-v.bi_valid,v.bi_valid+=pt-K):(v.bi_buf|=ft<<v.bi_valid&65535,v.bi_valid+=pt)}function Dt(v,ft,pt){Wt(v,pt[ft*2],pt[ft*2+1])}function Nt(v,ft){var pt=0;do pt|=v&1,v>>>=1,pt<<=1;while(--ft>0);return pt>>>1}function Xt(v){v.bi_valid===16?(ne(v,v.bi_buf),v.bi_buf=0,v.bi_valid=0):v.bi_valid>=8&&(v.pending_buf[v.pending++]=v.bi_buf&255,v.bi_buf>>=8,v.bi_valid-=8)}function Ht(v,ft){var pt=ft.dyn_tree,Rt=ft.max_code,N=ft.stat_desc.static_tree,Z=ft.stat_desc.has_stree,h=ft.stat_desc.extra_bits,lt=ft.stat_desc.extra_base,Ut=ft.stat_desc.max_length,s,I,Y,p,O,z,Pt=0;for(p=0;p<=G;p++)v.bl_count[p]=0;for(pt[v.heap[v.heap_max]*2+1]=0,s=v.heap_max+1;s<H;s++)I=v.heap[s],p=pt[pt[I*2+1]*2+1]+1,p>Ut&&(p=Ut,Pt++),pt[I*2+1]=p,!(I>Rt)&&(v.bl_count[p]++,O=0,I>=lt&&(O=h[I-lt]),z=pt[I*2],v.opt_len+=z*(p+O),Z&&(v.static_len+=z*(N[I*2+1]+O)));if(Pt!==0){do{for(p=Ut-1;v.bl_count[p]===0;)p--;v.bl_count[p]--,v.bl_count[p+1]+=2,v.bl_count[Ut]--,Pt-=2}while(Pt>0);for(p=Ut;p!==0;p--)for(I=v.bl_count[p];I!==0;)Y=v.heap[--s],!(Y>Rt)&&(pt[Y*2+1]!==p&&(v.opt_len+=(p-pt[Y*2+1])*pt[Y*2],pt[Y*2+1]=p),I--)}}function Kt(v,ft,pt){var Rt=new Array(G+1),N=0,Z,h;for(Z=1;Z<=G;Z++)Rt[Z]=N=N+pt[Z-1]<<1;for(h=0;h<=ft;h++){var lt=v[h*2+1];lt!==0&&(v[h*2]=Nt(Rt[lt]++,lt))}}function Ft(){var v,ft,pt,Rt,N,Z=new Array(G+1);for(pt=0,Rt=0;Rt<k-1;Rt++)for(rt[Rt]=pt,v=0;v<1<<V[Rt];v++)ae[pt++]=Rt;for(ae[pt-1]=Rt,N=0,Rt=0;Rt<16;Rt++)for(ot[Rt]=N,v=0;v<1<<gt[Rt];v++)Jt[N++]=Rt;for(N>>=7;Rt<Q;Rt++)for(ot[Rt]=N<<7,v=0;v<1<<gt[Rt]-7;v++)Jt[256+N++]=Rt;for(ft=0;ft<=G;ft++)Z[ft]=0;for(v=0;v<=143;)yt[v*2+1]=8,v++,Z[8]++;for(;v<=255;)yt[v*2+1]=9,v++,Z[9]++;for(;v<=279;)yt[v*2+1]=7,v++,Z[7]++;for(;v<=287;)yt[v*2+1]=8,v++,Z[8]++;for(Kt(yt,M+1,Z),v=0;v<Q;v++)Tt[v*2+1]=5,Tt[v*2]=Nt(v,5);Mt=new st(yt,V,F+1,M,G),It=new st(Tt,gt,0,Q,G),jt=new st(new Array(0),tt,0,ut,L)}function Lt(v){var ft;for(ft=0;ft<M;ft++)v.dyn_ltree[ft*2]=0;for(ft=0;ft<Q;ft++)v.dyn_dtree[ft*2]=0;for(ft=0;ft<ut;ft++)v.bl_tree[ft*2]=0;v.dyn_ltree[at*2]=1,v.opt_len=v.static_len=0,v.last_lit=v.matches=0}function ce(v){v.bi_valid>8?ne(v,v.bi_buf):v.bi_valid>0&&(v.pending_buf[v.pending++]=v.bi_buf),v.bi_buf=0,v.bi_valid=0}function he(v,ft,pt,Rt){ce(v),ne(v,pt),ne(v,~pt),b.arraySet(v.pending_buf,v.window,ft,pt,v.pending),v.pending+=pt}function y(v,ft,pt,Rt){var N=ft*2,Z=pt*2;return v[N]<v[Z]||v[N]===v[Z]&&Rt[ft]<=Rt[pt]}function o(v,ft,pt){for(var Rt=v.heap[pt],N=pt<<1;N<=v.heap_len&&(N<v.heap_len&&y(ft,v.heap[N+1],v.heap[N],v.depth)&&N++,!y(ft,Rt,v.heap[N],v.depth));)v.heap[pt]=v.heap[N],pt=N,N<<=1;v.heap[pt]=Rt}function f(v,ft,pt){var Rt,N,Z=0,h,lt;if(v.last_lit!==0)do Rt=v.pending_buf[v.d_buf+Z*2]<<8|v.pending_buf[v.d_buf+Z*2+1],N=v.pending_buf[v.l_buf+Z],Z++,Rt===0?Dt(v,N,ft):(h=ae[N],Dt(v,h+F+1,ft),lt=V[h],lt!==0&&(N-=rt[h],Wt(v,N,lt)),Rt--,h=le(Rt),Dt(v,h,pt),lt=gt[h],lt!==0&&(Rt-=ot[h],Wt(v,Rt,lt)));while(Z<v.last_lit);Dt(v,at,ft)}function S(v,ft){var pt=ft.dyn_tree,Rt=ft.stat_desc.static_tree,N=ft.stat_desc.has_stree,Z=ft.stat_desc.elems,h,lt,Ut=-1,s;for(v.heap_len=0,v.heap_max=H,h=0;h<Z;h++)pt[h*2]!==0?(v.heap[++v.heap_len]=Ut=h,v.depth[h]=0):pt[h*2+1]=0;for(;v.heap_len<2;)s=v.heap[++v.heap_len]=Ut<2?++Ut:0,pt[s*2]=1,v.depth[s]=0,v.opt_len--,N&&(v.static_len-=Rt[s*2+1]);for(ft.max_code=Ut,h=v.heap_len>>1;h>=1;h--)o(v,pt,h);s=Z;do h=v.heap[1],v.heap[1]=v.heap[v.heap_len--],o(v,pt,1),lt=v.heap[1],v.heap[--v.heap_max]=h,v.heap[--v.heap_max]=lt,pt[s*2]=pt[h*2]+pt[lt*2],v.depth[s]=(v.depth[h]>=v.depth[lt]?v.depth[h]:v.depth[lt])+1,pt[h*2+1]=pt[lt*2+1]=s,v.heap[1]=s++,o(v,pt,1);while(v.heap_len>=2);v.heap[--v.heap_max]=v.heap[1],Ht(v,ft),Kt(pt,Ut,v.bl_count)}function q(v,ft,pt){var Rt,N=-1,Z,h=ft[1],lt=0,Ut=7,s=4;for(h===0&&(Ut=138,s=3),ft[(pt+1)*2+1]=65535,Rt=0;Rt<=pt;Rt++)Z=h,h=ft[(Rt+1)*2+1],!(++lt<Ut&&Z===h)&&(lt<s?v.bl_tree[Z*2]+=lt:Z!==0?(Z!==N&&v.bl_tree[Z*2]++,v.bl_tree[ht*2]++):lt<=10?v.bl_tree[wt*2]++:v.bl_tree[W*2]++,lt=0,N=Z,h===0?(Ut=138,s=3):Z===h?(Ut=6,s=3):(Ut=7,s=4))}function nt(v,ft,pt){var Rt,N=-1,Z,h=ft[1],lt=0,Ut=7,s=4;for(h===0&&(Ut=138,s=3),Rt=0;Rt<=pt;Rt++)if(Z=h,h=ft[(Rt+1)*2+1],!(++lt<Ut&&Z===h)){if(lt<s)do Dt(v,Z,v.bl_tree);while(--lt!==0);else Z!==0?(Z!==N&&(Dt(v,Z,v.bl_tree),lt--),Dt(v,ht,v.bl_tree),Wt(v,lt-3,2)):lt<=10?(Dt(v,wt,v.bl_tree),Wt(v,lt-3,3)):(Dt(v,W,v.bl_tree),Wt(v,lt-11,7));lt=0,N=Z,h===0?(Ut=138,s=3):Z===h?(Ut=6,s=3):(Ut=7,s=4)}}function ct(v){var ft;for(q(v,v.dyn_ltree,v.l_desc.max_code),q(v,v.dyn_dtree,v.d_desc.max_code),S(v,v.bl_desc),ft=ut-1;ft>=3&&v.bl_tree[_t[ft]*2+1]===0;ft--);return v.opt_len+=3*(ft+1)+5+5+4,ft}function qt(v,ft,pt,Rt){var N;for(Wt(v,ft-257,5),Wt(v,pt-1,5),Wt(v,Rt-4,4),N=0;N<Rt;N++)Wt(v,v.bl_tree[_t[N]*2+1],3);nt(v,v.dyn_ltree,ft-1),nt(v,v.dyn_dtree,pt-1)}function Gt(v){var ft=4093624447,pt;for(pt=0;pt<=31;pt++,ft>>>=1)if(ft&1&&v.dyn_ltree[pt*2]!==0)return D;if(v.dyn_ltree[18]!==0||v.dyn_ltree[20]!==0||v.dyn_ltree[26]!==0)return R;for(pt=32;pt<F;pt++)if(v.dyn_ltree[pt*2]!==0)return R;return D}var Vt=!1;function oe(v){Vt||(Ft(),Vt=!0),v.l_desc=new Yt(v.dyn_ltree,Mt),v.d_desc=new Yt(v.dyn_dtree,It),v.bl_desc=new Yt(v.bl_tree,jt),v.bi_buf=0,v.bi_valid=0,Lt(v)}function te(v,ft,pt,Rt){Wt(v,(T<<1)+(Rt?1:0),3),he(v,ft,pt)}function de(v){Wt(v,m<<1,3),Dt(v,at,yt),Xt(v)}function ke(v,ft,pt,Rt){var N,Z,h=0;v.level>0?(v.strm.data_type===C&&(v.strm.data_type=Gt(v)),S(v,v.l_desc),S(v,v.d_desc),h=ct(v),N=v.opt_len+3+7>>>3,Z=v.static_len+3+7>>>3,Z<=N&&(N=Z)):N=Z=pt+5,pt+4<=N&&ft!==-1?te(v,ft,pt,Rt):v.strategy===E||Z===N?(Wt(v,(m<<1)+(Rt?1:0),3),f(v,yt,Tt)):(Wt(v,(g<<1)+(Rt?1:0),3),qt(v,v.l_desc.max_code+1,v.d_desc.max_code+1,h+1),f(v,v.dyn_ltree,v.dyn_dtree)),Lt(v),Rt&&ce(v)}function je(v,ft,pt){return v.pending_buf[v.d_buf+v.last_lit*2]=ft>>>8&255,v.pending_buf[v.d_buf+v.last_lit*2+1]=ft&255,v.pending_buf[v.l_buf+v.last_lit]=pt&255,v.last_lit++,ft===0?v.dyn_ltree[pt*2]++:(v.matches++,ft--,v.dyn_ltree[(ae[pt]+F+1)*2]++,v.dyn_dtree[le(ft)*2]++),v.last_lit===v.lit_bufsize-1}return lr._tr_init=oe,lr._tr_stored_block=te,lr._tr_flush_block=ke,lr._tr_tally=je,lr._tr_align=de,lr}var qi,_c;function Yc(){if(_c)return qi;_c=1;function b(E,D,R,C){for(var A=E&65535|0,T=E>>>16&65535|0,m=0;R!==0;){m=R>2e3?2e3:R,R-=m;do A=A+D[C++]|0,T=T+A|0;while(--m);A%=65521,T%=65521}return A|T<<16|0}return qi=b,qi}var Li,bc;function Kc(){if(bc)return Li;bc=1;function b(){for(var R,C=[],A=0;A<256;A++){R=A;for(var T=0;T<8;T++)R=R&1?3988292384^R>>>1:R>>>1;C[A]=R}return C}var E=b();function D(R,C,A,T){var m=E,g=T+A;R^=-1;for(var P=T;P<g;P++)R=R>>>8^m[(R^C[P])&255];return R^-1}return Li=D,Li}var zi,xc;function aa(){return xc||(xc=1,zi={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}),zi}var Ec;function wl(){if(Ec)return ze;Ec=1;var b=tr(),E=pl(),D=Yc(),R=Kc(),C=aa(),A=0,T=1,m=3,g=4,P=5,$=0,k=1,F=-2,M=-3,Q=-5,ut=-1,H=1,G=2,K=3,L=4,at=0,ht=2,wt=8,W=9,V=15,gt=8,tt=29,_t=256,dt=_t+1+tt,yt=30,Tt=19,Jt=2*dt+1,ae=15,rt=3,ot=258,st=ot+rt+1,Mt=32,It=42,jt=69,Yt=73,le=91,ne=103,Wt=113,Dt=666,Nt=1,Xt=2,Ht=3,Kt=4,Ft=3;function Lt(s,I){return s.msg=C[I],I}function ce(s){return(s<<1)-(s>4?9:0)}function he(s){for(var I=s.length;--I>=0;)s[I]=0}function y(s){var I=s.state,Y=I.pending;Y>s.avail_out&&(Y=s.avail_out),Y!==0&&(b.arraySet(s.output,I.pending_buf,I.pending_out,Y,s.next_out),s.next_out+=Y,I.pending_out+=Y,s.total_out+=Y,s.avail_out-=Y,I.pending-=Y,I.pending===0&&(I.pending_out=0))}function o(s,I){E._tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,I),s.block_start=s.strstart,y(s.strm)}function f(s,I){s.pending_buf[s.pending++]=I}function S(s,I){s.pending_buf[s.pending++]=I>>>8&255,s.pending_buf[s.pending++]=I&255}function q(s,I,Y,p){var O=s.avail_in;return O>p&&(O=p),O===0?0:(s.avail_in-=O,b.arraySet(I,s.input,s.next_in,O,Y),s.state.wrap===1?s.adler=D(s.adler,I,O,Y):s.state.wrap===2&&(s.adler=R(s.adler,I,O,Y)),s.next_in+=O,s.total_in+=O,O)}function nt(s,I){var Y=s.max_chain_length,p=s.strstart,O,z,Pt=s.prev_length,At=s.nice_match,xt=s.strstart>s.w_size-st?s.strstart-(s.w_size-st):0,Zt=s.window,Fe=s.w_mask,fe=s.prev,Qt=s.strstart+ot,we=Zt[p+Pt-1],ye=Zt[p+Pt];s.prev_length>=s.good_match&&(Y>>=2),At>s.lookahead&&(At=s.lookahead);do if(O=I,!(Zt[O+Pt]!==ye||Zt[O+Pt-1]!==we||Zt[O]!==Zt[p]||Zt[++O]!==Zt[p+1])){p+=2,O++;do;while(Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&Zt[++p]===Zt[++O]&&p<Qt);if(z=ot-(Qt-p),p=Qt-ot,z>Pt){if(s.match_start=I,Pt=z,z>=At)break;we=Zt[p+Pt-1],ye=Zt[p+Pt]}}while((I=fe[I&Fe])>xt&&--Y!==0);return Pt<=s.lookahead?Pt:s.lookahead}function ct(s){var I=s.w_size,Y,p,O,z,Pt;do{if(z=s.window_size-s.lookahead-s.strstart,s.strstart>=I+(I-st)){b.arraySet(s.window,s.window,I,I,0),s.match_start-=I,s.strstart-=I,s.block_start-=I,p=s.hash_size,Y=p;do O=s.head[--Y],s.head[Y]=O>=I?O-I:0;while(--p);p=I,Y=p;do O=s.prev[--Y],s.prev[Y]=O>=I?O-I:0;while(--p);z+=I}if(s.strm.avail_in===0)break;if(p=q(s.strm,s.window,s.strstart+s.lookahead,z),s.lookahead+=p,s.lookahead+s.insert>=rt)for(Pt=s.strstart-s.insert,s.ins_h=s.window[Pt],s.ins_h=(s.ins_h<<s.hash_shift^s.window[Pt+1])&s.hash_mask;s.insert&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[Pt+rt-1])&s.hash_mask,s.prev[Pt&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=Pt,Pt++,s.insert--,!(s.lookahead+s.insert<rt)););}while(s.lookahead<st&&s.strm.avail_in!==0)}function qt(s,I){var Y=65535;for(Y>s.pending_buf_size-5&&(Y=s.pending_buf_size-5);;){if(s.lookahead<=1){if(ct(s),s.lookahead===0&&I===A)return Nt;if(s.lookahead===0)break}s.strstart+=s.lookahead,s.lookahead=0;var p=s.block_start+Y;if((s.strstart===0||s.strstart>=p)&&(s.lookahead=s.strstart-p,s.strstart=p,o(s,!1),s.strm.avail_out===0)||s.strstart-s.block_start>=s.w_size-st&&(o(s,!1),s.strm.avail_out===0))return Nt}return s.insert=0,I===g?(o(s,!0),s.strm.avail_out===0?Ht:Kt):(s.strstart>s.block_start&&(o(s,!1),s.strm.avail_out===0),Nt)}function Gt(s,I){for(var Y,p;;){if(s.lookahead<st){if(ct(s),s.lookahead<st&&I===A)return Nt;if(s.lookahead===0)break}if(Y=0,s.lookahead>=rt&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+rt-1])&s.hash_mask,Y=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),Y!==0&&s.strstart-Y<=s.w_size-st&&(s.match_length=nt(s,Y)),s.match_length>=rt)if(p=E._tr_tally(s,s.strstart-s.match_start,s.match_length-rt),s.lookahead-=s.match_length,s.match_length<=s.max_lazy_match&&s.lookahead>=rt){s.match_length--;do s.strstart++,s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+rt-1])&s.hash_mask,Y=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart;while(--s.match_length!==0);s.strstart++}else s.strstart+=s.match_length,s.match_length=0,s.ins_h=s.window[s.strstart],s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+1])&s.hash_mask;else p=E._tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++;if(p&&(o(s,!1),s.strm.avail_out===0))return Nt}return s.insert=s.strstart<rt-1?s.strstart:rt-1,I===g?(o(s,!0),s.strm.avail_out===0?Ht:Kt):s.last_lit&&(o(s,!1),s.strm.avail_out===0)?Nt:Xt}function Vt(s,I){for(var Y,p,O;;){if(s.lookahead<st){if(ct(s),s.lookahead<st&&I===A)return Nt;if(s.lookahead===0)break}if(Y=0,s.lookahead>=rt&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+rt-1])&s.hash_mask,Y=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),s.prev_length=s.match_length,s.prev_match=s.match_start,s.match_length=rt-1,Y!==0&&s.prev_length<s.max_lazy_match&&s.strstart-Y<=s.w_size-st&&(s.match_length=nt(s,Y),s.match_length<=5&&(s.strategy===H||s.match_length===rt&&s.strstart-s.match_start>4096)&&(s.match_length=rt-1)),s.prev_length>=rt&&s.match_length<=s.prev_length){O=s.strstart+s.lookahead-rt,p=E._tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-rt),s.lookahead-=s.prev_length-1,s.prev_length-=2;do++s.strstart<=O&&(s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+rt-1])&s.hash_mask,Y=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart);while(--s.prev_length!==0);if(s.match_available=0,s.match_length=rt-1,s.strstart++,p&&(o(s,!1),s.strm.avail_out===0))return Nt}else if(s.match_available){if(p=E._tr_tally(s,0,s.window[s.strstart-1]),p&&o(s,!1),s.strstart++,s.lookahead--,s.strm.avail_out===0)return Nt}else s.match_available=1,s.strstart++,s.lookahead--}return s.match_available&&(p=E._tr_tally(s,0,s.window[s.strstart-1]),s.match_available=0),s.insert=s.strstart<rt-1?s.strstart:rt-1,I===g?(o(s,!0),s.strm.avail_out===0?Ht:Kt):s.last_lit&&(o(s,!1),s.strm.avail_out===0)?Nt:Xt}function oe(s,I){for(var Y,p,O,z,Pt=s.window;;){if(s.lookahead<=ot){if(ct(s),s.lookahead<=ot&&I===A)return Nt;if(s.lookahead===0)break}if(s.match_length=0,s.lookahead>=rt&&s.strstart>0&&(O=s.strstart-1,p=Pt[O],p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O])){z=s.strstart+ot;do;while(p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&p===Pt[++O]&&O<z);s.match_length=ot-(z-O),s.match_length>s.lookahead&&(s.match_length=s.lookahead)}if(s.match_length>=rt?(Y=E._tr_tally(s,1,s.match_length-rt),s.lookahead-=s.match_length,s.strstart+=s.match_length,s.match_length=0):(Y=E._tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++),Y&&(o(s,!1),s.strm.avail_out===0))return Nt}return s.insert=0,I===g?(o(s,!0),s.strm.avail_out===0?Ht:Kt):s.last_lit&&(o(s,!1),s.strm.avail_out===0)?Nt:Xt}function te(s,I){for(var Y;;){if(s.lookahead===0&&(ct(s),s.lookahead===0)){if(I===A)return Nt;break}if(s.match_length=0,Y=E._tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++,Y&&(o(s,!1),s.strm.avail_out===0))return Nt}return s.insert=0,I===g?(o(s,!0),s.strm.avail_out===0?Ht:Kt):s.last_lit&&(o(s,!1),s.strm.avail_out===0)?Nt:Xt}function de(s,I,Y,p,O){this.good_length=s,this.max_lazy=I,this.nice_length=Y,this.max_chain=p,this.func=O}var ke;ke=[new de(0,0,0,0,qt),new de(4,4,8,4,Gt),new de(4,5,16,8,Gt),new de(4,6,32,32,Gt),new de(4,4,16,16,Vt),new de(8,16,32,32,Vt),new de(8,16,128,128,Vt),new de(8,32,128,256,Vt),new de(32,128,258,1024,Vt),new de(32,258,258,4096,Vt)];function je(s){s.window_size=2*s.w_size,he(s.head),s.max_lazy_match=ke[s.level].max_lazy,s.good_match=ke[s.level].good_length,s.nice_match=ke[s.level].nice_length,s.max_chain_length=ke[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=rt-1,s.match_available=0,s.ins_h=0}function v(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=wt,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new b.Buf16(Jt*2),this.dyn_dtree=new b.Buf16((2*yt+1)*2),this.bl_tree=new b.Buf16((2*Tt+1)*2),he(this.dyn_ltree),he(this.dyn_dtree),he(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new b.Buf16(ae+1),this.heap=new b.Buf16(2*dt+1),he(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new b.Buf16(2*dt+1),he(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function ft(s){var I;return!s||!s.state?Lt(s,F):(s.total_in=s.total_out=0,s.data_type=ht,I=s.state,I.pending=0,I.pending_out=0,I.wrap<0&&(I.wrap=-I.wrap),I.status=I.wrap?It:Wt,s.adler=I.wrap===2?0:1,I.last_flush=A,E._tr_init(I),$)}function pt(s){var I=ft(s);return I===$&&je(s.state),I}function Rt(s,I){return!s||!s.state||s.state.wrap!==2?F:(s.state.gzhead=I,$)}function N(s,I,Y,p,O,z){if(!s)return F;var Pt=1;if(I===ut&&(I=6),p<0?(Pt=0,p=-p):p>15&&(Pt=2,p-=16),O<1||O>W||Y!==wt||p<8||p>15||I<0||I>9||z<0||z>L)return Lt(s,F);p===8&&(p=9);var At=new v;return s.state=At,At.strm=s,At.wrap=Pt,At.gzhead=null,At.w_bits=p,At.w_size=1<<At.w_bits,At.w_mask=At.w_size-1,At.hash_bits=O+7,At.hash_size=1<<At.hash_bits,At.hash_mask=At.hash_size-1,At.hash_shift=~~((At.hash_bits+rt-1)/rt),At.window=new b.Buf8(At.w_size*2),At.head=new b.Buf16(At.hash_size),At.prev=new b.Buf16(At.w_size),At.lit_bufsize=1<<O+6,At.pending_buf_size=At.lit_bufsize*4,At.pending_buf=new b.Buf8(At.pending_buf_size),At.d_buf=1*At.lit_bufsize,At.l_buf=3*At.lit_bufsize,At.level=I,At.strategy=z,At.method=Y,pt(s)}function Z(s,I){return N(s,I,wt,V,gt,at)}function h(s,I){var Y,p,O,z;if(!s||!s.state||I>P||I<0)return s?Lt(s,F):F;if(p=s.state,!s.output||!s.input&&s.avail_in!==0||p.status===Dt&&I!==g)return Lt(s,s.avail_out===0?Q:F);if(p.strm=s,Y=p.last_flush,p.last_flush=I,p.status===It)if(p.wrap===2)s.adler=0,f(p,31),f(p,139),f(p,8),p.gzhead?(f(p,(p.gzhead.text?1:0)+(p.gzhead.hcrc?2:0)+(p.gzhead.extra?4:0)+(p.gzhead.name?8:0)+(p.gzhead.comment?16:0)),f(p,p.gzhead.time&255),f(p,p.gzhead.time>>8&255),f(p,p.gzhead.time>>16&255),f(p,p.gzhead.time>>24&255),f(p,p.level===9?2:p.strategy>=G||p.level<2?4:0),f(p,p.gzhead.os&255),p.gzhead.extra&&p.gzhead.extra.length&&(f(p,p.gzhead.extra.length&255),f(p,p.gzhead.extra.length>>8&255)),p.gzhead.hcrc&&(s.adler=R(s.adler,p.pending_buf,p.pending,0)),p.gzindex=0,p.status=jt):(f(p,0),f(p,0),f(p,0),f(p,0),f(p,0),f(p,p.level===9?2:p.strategy>=G||p.level<2?4:0),f(p,Ft),p.status=Wt);else{var Pt=wt+(p.w_bits-8<<4)<<8,At=-1;p.strategy>=G||p.level<2?At=0:p.level<6?At=1:p.level===6?At=2:At=3,Pt|=At<<6,p.strstart!==0&&(Pt|=Mt),Pt+=31-Pt%31,p.status=Wt,S(p,Pt),p.strstart!==0&&(S(p,s.adler>>>16),S(p,s.adler&65535)),s.adler=1}if(p.status===jt)if(p.gzhead.extra){for(O=p.pending;p.gzindex<(p.gzhead.extra.length&65535)&&!(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),y(s),O=p.pending,p.pending===p.pending_buf_size));)f(p,p.gzhead.extra[p.gzindex]&255),p.gzindex++;p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),p.gzindex===p.gzhead.extra.length&&(p.gzindex=0,p.status=Yt)}else p.status=Yt;if(p.status===Yt)if(p.gzhead.name){O=p.pending;do{if(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),y(s),O=p.pending,p.pending===p.pending_buf_size)){z=1;break}p.gzindex<p.gzhead.name.length?z=p.gzhead.name.charCodeAt(p.gzindex++)&255:z=0,f(p,z)}while(z!==0);p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),z===0&&(p.gzindex=0,p.status=le)}else p.status=le;if(p.status===le)if(p.gzhead.comment){O=p.pending;do{if(p.pending===p.pending_buf_size&&(p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),y(s),O=p.pending,p.pending===p.pending_buf_size)){z=1;break}p.gzindex<p.gzhead.comment.length?z=p.gzhead.comment.charCodeAt(p.gzindex++)&255:z=0,f(p,z)}while(z!==0);p.gzhead.hcrc&&p.pending>O&&(s.adler=R(s.adler,p.pending_buf,p.pending-O,O)),z===0&&(p.status=ne)}else p.status=ne;if(p.status===ne&&(p.gzhead.hcrc?(p.pending+2>p.pending_buf_size&&y(s),p.pending+2<=p.pending_buf_size&&(f(p,s.adler&255),f(p,s.adler>>8&255),s.adler=0,p.status=Wt)):p.status=Wt),p.pending!==0){if(y(s),s.avail_out===0)return p.last_flush=-1,$}else if(s.avail_in===0&&ce(I)<=ce(Y)&&I!==g)return Lt(s,Q);if(p.status===Dt&&s.avail_in!==0)return Lt(s,Q);if(s.avail_in!==0||p.lookahead!==0||I!==A&&p.status!==Dt){var xt=p.strategy===G?te(p,I):p.strategy===K?oe(p,I):ke[p.level].func(p,I);if((xt===Ht||xt===Kt)&&(p.status=Dt),xt===Nt||xt===Ht)return s.avail_out===0&&(p.last_flush=-1),$;if(xt===Xt&&(I===T?E._tr_align(p):I!==P&&(E._tr_stored_block(p,0,0,!1),I===m&&(he(p.head),p.lookahead===0&&(p.strstart=0,p.block_start=0,p.insert=0))),y(s),s.avail_out===0))return p.last_flush=-1,$}return I!==g?$:p.wrap<=0?k:(p.wrap===2?(f(p,s.adler&255),f(p,s.adler>>8&255),f(p,s.adler>>16&255),f(p,s.adler>>24&255),f(p,s.total_in&255),f(p,s.total_in>>8&255),f(p,s.total_in>>16&255),f(p,s.total_in>>24&255)):(S(p,s.adler>>>16),S(p,s.adler&65535)),y(s),p.wrap>0&&(p.wrap=-p.wrap),p.pending!==0?$:k)}function lt(s){var I;return!s||!s.state?F:(I=s.state.status,I!==It&&I!==jt&&I!==Yt&&I!==le&&I!==ne&&I!==Wt&&I!==Dt?Lt(s,F):(s.state=null,I===Wt?Lt(s,M):$))}function Ut(s,I){var Y=I.length,p,O,z,Pt,At,xt,Zt,Fe;if(!s||!s.state||(p=s.state,Pt=p.wrap,Pt===2||Pt===1&&p.status!==It||p.lookahead))return F;for(Pt===1&&(s.adler=D(s.adler,I,Y,0)),p.wrap=0,Y>=p.w_size&&(Pt===0&&(he(p.head),p.strstart=0,p.block_start=0,p.insert=0),Fe=new b.Buf8(p.w_size),b.arraySet(Fe,I,Y-p.w_size,p.w_size,0),I=Fe,Y=p.w_size),At=s.avail_in,xt=s.next_in,Zt=s.input,s.avail_in=Y,s.next_in=0,s.input=I,ct(p);p.lookahead>=rt;){O=p.strstart,z=p.lookahead-(rt-1);do p.ins_h=(p.ins_h<<p.hash_shift^p.window[O+rt-1])&p.hash_mask,p.prev[O&p.w_mask]=p.head[p.ins_h],p.head[p.ins_h]=O,O++;while(--z);p.strstart=O,p.lookahead=rt-1,ct(p)}return p.strstart+=p.lookahead,p.block_start=p.strstart,p.insert=p.lookahead,p.lookahead=0,p.match_length=p.prev_length=rt-1,p.match_available=0,s.next_in=xt,s.input=Zt,s.avail_in=At,p.wrap=Pt,$}return ze.deflateInit=Z,ze.deflateInit2=N,ze.deflateReset=pt,ze.deflateResetKeep=ft,ze.deflateSetHeader=Rt,ze.deflate=h,ze.deflateEnd=lt,ze.deflateSetDictionary=Ut,ze.deflateInfo="pako deflate (from Nodeca project)",ze}var hr={},Sc;function Jc(){if(Sc)return hr;Sc=1;var b=tr(),E=!0,D=!0;try{String.fromCharCode.apply(null,[0])}catch{E=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{D=!1}for(var R=new b.Buf8(256),C=0;C<256;C++)R[C]=C>=252?6:C>=248?5:C>=240?4:C>=224?3:C>=192?2:1;R[254]=R[254]=1,hr.string2buf=function(T){var m,g,P,$,k,F=T.length,M=0;for($=0;$<F;$++)g=T.charCodeAt($),(g&64512)===55296&&$+1<F&&(P=T.charCodeAt($+1),(P&64512)===56320&&(g=65536+(g-55296<<10)+(P-56320),$++)),M+=g<128?1:g<2048?2:g<65536?3:4;for(m=new b.Buf8(M),k=0,$=0;k<M;$++)g=T.charCodeAt($),(g&64512)===55296&&$+1<F&&(P=T.charCodeAt($+1),(P&64512)===56320&&(g=65536+(g-55296<<10)+(P-56320),$++)),g<128?m[k++]=g:g<2048?(m[k++]=192|g>>>6,m[k++]=128|g&63):g<65536?(m[k++]=224|g>>>12,m[k++]=128|g>>>6&63,m[k++]=128|g&63):(m[k++]=240|g>>>18,m[k++]=128|g>>>12&63,m[k++]=128|g>>>6&63,m[k++]=128|g&63);return m};function A(T,m){if(m<65534&&(T.subarray&&D||!T.subarray&&E))return String.fromCharCode.apply(null,b.shrinkBuf(T,m));for(var g="",P=0;P<m;P++)g+=String.fromCharCode(T[P]);return g}return hr.buf2binstring=function(T){return A(T,T.length)},hr.binstring2buf=function(T){for(var m=new b.Buf8(T.length),g=0,P=m.length;g<P;g++)m[g]=T.charCodeAt(g);return m},hr.buf2string=function(T,m){var g,P,$,k,F=m||T.length,M=new Array(F*2);for(P=0,g=0;g<F;){if($=T[g++],$<128){M[P++]=$;continue}if(k=R[$],k>4){M[P++]=65533,g+=k-1;continue}for($&=k===2?31:k===3?15:7;k>1&&g<F;)$=$<<6|T[g++]&63,k--;if(k>1){M[P++]=65533;continue}$<65536?M[P++]=$:($-=65536,M[P++]=55296|$>>10&1023,M[P++]=56320|$&1023)}return A(M,P)},hr.utf8border=function(T,m){var g;for(m=m||T.length,m>T.length&&(m=T.length),g=m-1;g>=0&&(T[g]&192)===128;)g--;return g<0||g===0?m:g+R[T[g]]>m?g:m},hr}var Hi,Ac;function Qc(){if(Ac)return Hi;Ac=1;function b(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}return Hi=b,Hi}var kc;function ml(){if(kc)return Sr;kc=1;var b=wl(),E=tr(),D=Jc(),R=aa(),C=Qc(),A=Object.prototype.toString,T=0,m=4,g=0,P=1,$=2,k=-1,F=0,M=8;function Q(K){if(!(this instanceof Q))return new Q(K);this.options=E.assign({level:k,method:M,chunkSize:16384,windowBits:15,memLevel:8,strategy:F,to:""},K||{});var L=this.options;L.raw&&L.windowBits>0?L.windowBits=-L.windowBits:L.gzip&&L.windowBits>0&&L.windowBits<16&&(L.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new C,this.strm.avail_out=0;var at=b.deflateInit2(this.strm,L.level,L.method,L.windowBits,L.memLevel,L.strategy);if(at!==g)throw new Error(R[at]);if(L.header&&b.deflateSetHeader(this.strm,L.header),L.dictionary){var ht;if(typeof L.dictionary=="string"?ht=D.string2buf(L.dictionary):A.call(L.dictionary)==="[object ArrayBuffer]"?ht=new Uint8Array(L.dictionary):ht=L.dictionary,at=b.deflateSetDictionary(this.strm,ht),at!==g)throw new Error(R[at]);this._dict_set=!0}}Q.prototype.push=function(K,L){var at=this.strm,ht=this.options.chunkSize,wt,W;if(this.ended)return!1;W=L===~~L?L:L===!0?m:T,typeof K=="string"?at.input=D.string2buf(K):A.call(K)==="[object ArrayBuffer]"?at.input=new Uint8Array(K):at.input=K,at.next_in=0,at.avail_in=at.input.length;do{if(at.avail_out===0&&(at.output=new E.Buf8(ht),at.next_out=0,at.avail_out=ht),wt=b.deflate(at,W),wt!==P&&wt!==g)return this.onEnd(wt),this.ended=!0,!1;(at.avail_out===0||at.avail_in===0&&(W===m||W===$))&&(this.options.to==="string"?this.onData(D.buf2binstring(E.shrinkBuf(at.output,at.next_out))):this.onData(E.shrinkBuf(at.output,at.next_out)))}while((at.avail_in>0||at.avail_out===0)&&wt!==P);return W===m?(wt=b.deflateEnd(this.strm),this.onEnd(wt),this.ended=!0,wt===g):(W===$&&(this.onEnd(g),at.avail_out=0),!0)},Q.prototype.onData=function(K){this.chunks.push(K)},Q.prototype.onEnd=function(K){K===g&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=E.flattenChunks(this.chunks)),this.chunks=[],this.err=K,this.msg=this.strm.msg};function ut(K,L){var at=new Q(L);if(at.push(K,!0),at.err)throw at.msg||R[at.err];return at.result}function H(K,L){return L=L||{},L.raw=!0,ut(K,L)}function G(K,L){return L=L||{},L.gzip=!0,ut(K,L)}return Sr.Deflate=Q,Sr.deflate=ut,Sr.deflateRaw=H,Sr.gzip=G,Sr}var Ar={},Me={},Gi,Rc;function gl(){if(Rc)return Gi;Rc=1;var b=30,E=12;return Gi=function(R,C){var A,T,m,g,P,$,k,F,M,Q,ut,H,G,K,L,at,ht,wt,W,V,gt,tt,_t,dt,yt;A=R.state,T=R.next_in,dt=R.input,m=T+(R.avail_in-5),g=R.next_out,yt=R.output,P=g-(C-R.avail_out),$=g+(R.avail_out-257),k=A.dmax,F=A.wsize,M=A.whave,Q=A.wnext,ut=A.window,H=A.hold,G=A.bits,K=A.lencode,L=A.distcode,at=(1<<A.lenbits)-1,ht=(1<<A.distbits)-1;t:do{G<15&&(H+=dt[T++]<<G,G+=8,H+=dt[T++]<<G,G+=8),wt=K[H&at];e:for(;;){if(W=wt>>>24,H>>>=W,G-=W,W=wt>>>16&255,W===0)yt[g++]=wt&65535;else if(W&16){V=wt&65535,W&=15,W&&(G<W&&(H+=dt[T++]<<G,G+=8),V+=H&(1<<W)-1,H>>>=W,G-=W),G<15&&(H+=dt[T++]<<G,G+=8,H+=dt[T++]<<G,G+=8),wt=L[H&ht];r:for(;;){if(W=wt>>>24,H>>>=W,G-=W,W=wt>>>16&255,W&16){if(gt=wt&65535,W&=15,G<W&&(H+=dt[T++]<<G,G+=8,G<W&&(H+=dt[T++]<<G,G+=8)),gt+=H&(1<<W)-1,gt>k){R.msg="invalid distance too far back",A.mode=b;break t}if(H>>>=W,G-=W,W=g-P,gt>W){if(W=gt-W,W>M&&A.sane){R.msg="invalid distance too far back",A.mode=b;break t}if(tt=0,_t=ut,Q===0){if(tt+=F-W,W<V){V-=W;do yt[g++]=ut[tt++];while(--W);tt=g-gt,_t=yt}}else if(Q<W){if(tt+=F+Q-W,W-=Q,W<V){V-=W;do yt[g++]=ut[tt++];while(--W);if(tt=0,Q<V){W=Q,V-=W;do yt[g++]=ut[tt++];while(--W);tt=g-gt,_t=yt}}}else if(tt+=Q-W,W<V){V-=W;do yt[g++]=ut[tt++];while(--W);tt=g-gt,_t=yt}for(;V>2;)yt[g++]=_t[tt++],yt[g++]=_t[tt++],yt[g++]=_t[tt++],V-=3;V&&(yt[g++]=_t[tt++],V>1&&(yt[g++]=_t[tt++]))}else{tt=g-gt;do yt[g++]=yt[tt++],yt[g++]=yt[tt++],yt[g++]=yt[tt++],V-=3;while(V>2);V&&(yt[g++]=yt[tt++],V>1&&(yt[g++]=yt[tt++]))}}else if((W&64)===0){wt=L[(wt&65535)+(H&(1<<W)-1)];continue r}else{R.msg="invalid distance code",A.mode=b;break t}break}}else if((W&64)===0){wt=K[(wt&65535)+(H&(1<<W)-1)];continue e}else if(W&32){A.mode=E;break t}else{R.msg="invalid literal/length code",A.mode=b;break t}break}}while(T<m&&g<$);V=G>>3,T-=V,G-=V<<3,H&=(1<<G)-1,R.next_in=T,R.next_out=g,R.avail_in=T<m?5+(m-T):5-(T-m),R.avail_out=g<$?257+($-g):257-(g-$),A.hold=H,A.bits=G},Gi}var Zi,Tc;function yl(){if(Tc)return Zi;Tc=1;var b=tr(),E=15,D=852,R=592,C=0,A=1,T=2,m=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],g=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],P=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],$=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];return Zi=function(F,M,Q,ut,H,G,K,L){var at=L.bits,ht=0,wt=0,W=0,V=0,gt=0,tt=0,_t=0,dt=0,yt=0,Tt=0,Jt,ae,rt,ot,st,Mt=null,It=0,jt,Yt=new b.Buf16(E+1),le=new b.Buf16(E+1),ne=null,Wt=0,Dt,Nt,Xt;for(ht=0;ht<=E;ht++)Yt[ht]=0;for(wt=0;wt<ut;wt++)Yt[M[Q+wt]]++;for(gt=at,V=E;V>=1&&Yt[V]===0;V--);if(gt>V&&(gt=V),V===0)return H[G++]=1<<24|64<<16|0,H[G++]=1<<24|64<<16|0,L.bits=1,0;for(W=1;W<V&&Yt[W]===0;W++);for(gt<W&&(gt=W),dt=1,ht=1;ht<=E;ht++)if(dt<<=1,dt-=Yt[ht],dt<0)return-1;if(dt>0&&(F===C||V!==1))return-1;for(le[1]=0,ht=1;ht<E;ht++)le[ht+1]=le[ht]+Yt[ht];for(wt=0;wt<ut;wt++)M[Q+wt]!==0&&(K[le[M[Q+wt]]++]=wt);if(F===C?(Mt=ne=K,jt=19):F===A?(Mt=m,It-=257,ne=g,Wt-=257,jt=256):(Mt=P,ne=$,jt=-1),Tt=0,wt=0,ht=W,st=G,tt=gt,_t=0,rt=-1,yt=1<<gt,ot=yt-1,F===A&&yt>D||F===T&&yt>R)return 1;for(;;){Dt=ht-_t,K[wt]<jt?(Nt=0,Xt=K[wt]):K[wt]>jt?(Nt=ne[Wt+K[wt]],Xt=Mt[It+K[wt]]):(Nt=96,Xt=0),Jt=1<<ht-_t,ae=1<<tt,W=ae;do ae-=Jt,H[st+(Tt>>_t)+ae]=Dt<<24|Nt<<16|Xt|0;while(ae!==0);for(Jt=1<<ht-1;Tt&Jt;)Jt>>=1;if(Jt!==0?(Tt&=Jt-1,Tt+=Jt):Tt=0,wt++,--Yt[ht]===0){if(ht===V)break;ht=M[Q+K[wt]]}if(ht>gt&&(Tt&ot)!==rt){for(_t===0&&(_t=gt),st+=W,tt=ht-_t,dt=1<<tt;tt+_t<V&&(dt-=Yt[tt+_t],!(dt<=0));)tt++,dt<<=1;if(yt+=1<<tt,F===A&&yt>D||F===T&&yt>R)return 1;rt=Tt&ot,H[rt]=gt<<24|tt<<16|st-G|0}}return Tt!==0&&(H[st+Tt]=ht-_t<<24|64<<16|0),L.bits=gt,0},Zi}var Ic;function vl(){if(Ic)return Me;Ic=1;var b=tr(),E=Yc(),D=Kc(),R=gl(),C=yl(),A=0,T=1,m=2,g=4,P=5,$=6,k=0,F=1,M=2,Q=-2,ut=-3,H=-4,G=-5,K=8,L=1,at=2,ht=3,wt=4,W=5,V=6,gt=7,tt=8,_t=9,dt=10,yt=11,Tt=12,Jt=13,ae=14,rt=15,ot=16,st=17,Mt=18,It=19,jt=20,Yt=21,le=22,ne=23,Wt=24,Dt=25,Nt=26,Xt=27,Ht=28,Kt=29,Ft=30,Lt=31,ce=32,he=852,y=592,o=15,f=o;function S(N){return(N>>>24&255)+(N>>>8&65280)+((N&65280)<<8)+((N&255)<<24)}function q(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new b.Buf16(320),this.work=new b.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function nt(N){var Z;return!N||!N.state?Q:(Z=N.state,N.total_in=N.total_out=Z.total=0,N.msg="",Z.wrap&&(N.adler=Z.wrap&1),Z.mode=L,Z.last=0,Z.havedict=0,Z.dmax=32768,Z.head=null,Z.hold=0,Z.bits=0,Z.lencode=Z.lendyn=new b.Buf32(he),Z.distcode=Z.distdyn=new b.Buf32(y),Z.sane=1,Z.back=-1,k)}function ct(N){var Z;return!N||!N.state?Q:(Z=N.state,Z.wsize=0,Z.whave=0,Z.wnext=0,nt(N))}function qt(N,Z){var h,lt;return!N||!N.state||(lt=N.state,Z<0?(h=0,Z=-Z):(h=(Z>>4)+1,Z<48&&(Z&=15)),Z&&(Z<8||Z>15))?Q:(lt.window!==null&&lt.wbits!==Z&&(lt.window=null),lt.wrap=h,lt.wbits=Z,ct(N))}function Gt(N,Z){var h,lt;return N?(lt=new q,N.state=lt,lt.window=null,h=qt(N,Z),h!==k&&(N.state=null),h):Q}function Vt(N){return Gt(N,f)}var oe=!0,te,de;function ke(N){if(oe){var Z;for(te=new b.Buf32(512),de=new b.Buf32(32),Z=0;Z<144;)N.lens[Z++]=8;for(;Z<256;)N.lens[Z++]=9;for(;Z<280;)N.lens[Z++]=7;for(;Z<288;)N.lens[Z++]=8;for(C(T,N.lens,0,288,te,0,N.work,{bits:9}),Z=0;Z<32;)N.lens[Z++]=5;C(m,N.lens,0,32,de,0,N.work,{bits:5}),oe=!1}N.lencode=te,N.lenbits=9,N.distcode=de,N.distbits=5}function je(N,Z,h,lt){var Ut,s=N.state;return s.window===null&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new b.Buf8(s.wsize)),lt>=s.wsize?(b.arraySet(s.window,Z,h-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(Ut=s.wsize-s.wnext,Ut>lt&&(Ut=lt),b.arraySet(s.window,Z,h-lt,Ut,s.wnext),lt-=Ut,lt?(b.arraySet(s.window,Z,h-lt,lt,0),s.wnext=lt,s.whave=s.wsize):(s.wnext+=Ut,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=Ut))),0}function v(N,Z){var h,lt,Ut,s,I,Y,p,O,z,Pt,At,xt,Zt,Fe,fe=0,Qt,we,ye,Re,er,rr,me,Be,ve=new b.Buf8(4),De,Ue,en=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!N||!N.state||!N.output||!N.input&&N.avail_in!==0)return Q;h=N.state,h.mode===Tt&&(h.mode=Jt),I=N.next_out,Ut=N.output,p=N.avail_out,s=N.next_in,lt=N.input,Y=N.avail_in,O=h.hold,z=h.bits,Pt=Y,At=p,Be=k;t:for(;;)switch(h.mode){case L:if(h.wrap===0){h.mode=Jt;break}for(;z<16;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(h.wrap&2&&O===35615){h.check=0,ve[0]=O&255,ve[1]=O>>>8&255,h.check=D(h.check,ve,2,0),O=0,z=0,h.mode=at;break}if(h.flags=0,h.head&&(h.head.done=!1),!(h.wrap&1)||(((O&255)<<8)+(O>>8))%31){N.msg="incorrect header check",h.mode=Ft;break}if((O&15)!==K){N.msg="unknown compression method",h.mode=Ft;break}if(O>>>=4,z-=4,me=(O&15)+8,h.wbits===0)h.wbits=me;else if(me>h.wbits){N.msg="invalid window size",h.mode=Ft;break}h.dmax=1<<me,N.adler=h.check=1,h.mode=O&512?dt:Tt,O=0,z=0;break;case at:for(;z<16;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(h.flags=O,(h.flags&255)!==K){N.msg="unknown compression method",h.mode=Ft;break}if(h.flags&57344){N.msg="unknown header flags set",h.mode=Ft;break}h.head&&(h.head.text=O>>8&1),h.flags&512&&(ve[0]=O&255,ve[1]=O>>>8&255,h.check=D(h.check,ve,2,0)),O=0,z=0,h.mode=ht;case ht:for(;z<32;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.head&&(h.head.time=O),h.flags&512&&(ve[0]=O&255,ve[1]=O>>>8&255,ve[2]=O>>>16&255,ve[3]=O>>>24&255,h.check=D(h.check,ve,4,0)),O=0,z=0,h.mode=wt;case wt:for(;z<16;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.head&&(h.head.xflags=O&255,h.head.os=O>>8),h.flags&512&&(ve[0]=O&255,ve[1]=O>>>8&255,h.check=D(h.check,ve,2,0)),O=0,z=0,h.mode=W;case W:if(h.flags&1024){for(;z<16;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.length=O,h.head&&(h.head.extra_len=O),h.flags&512&&(ve[0]=O&255,ve[1]=O>>>8&255,h.check=D(h.check,ve,2,0)),O=0,z=0}else h.head&&(h.head.extra=null);h.mode=V;case V:if(h.flags&1024&&(xt=h.length,xt>Y&&(xt=Y),xt&&(h.head&&(me=h.head.extra_len-h.length,h.head.extra||(h.head.extra=new Array(h.head.extra_len)),b.arraySet(h.head.extra,lt,s,xt,me)),h.flags&512&&(h.check=D(h.check,lt,xt,s)),Y-=xt,s+=xt,h.length-=xt),h.length))break t;h.length=0,h.mode=gt;case gt:if(h.flags&2048){if(Y===0)break t;xt=0;do me=lt[s+xt++],h.head&&me&&h.length<65536&&(h.head.name+=String.fromCharCode(me));while(me&&xt<Y);if(h.flags&512&&(h.check=D(h.check,lt,xt,s)),Y-=xt,s+=xt,me)break t}else h.head&&(h.head.name=null);h.length=0,h.mode=tt;case tt:if(h.flags&4096){if(Y===0)break t;xt=0;do me=lt[s+xt++],h.head&&me&&h.length<65536&&(h.head.comment+=String.fromCharCode(me));while(me&&xt<Y);if(h.flags&512&&(h.check=D(h.check,lt,xt,s)),Y-=xt,s+=xt,me)break t}else h.head&&(h.head.comment=null);h.mode=_t;case _t:if(h.flags&512){for(;z<16;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(O!==(h.check&65535)){N.msg="header crc mismatch",h.mode=Ft;break}O=0,z=0}h.head&&(h.head.hcrc=h.flags>>9&1,h.head.done=!0),N.adler=h.check=0,h.mode=Tt;break;case dt:for(;z<32;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}N.adler=h.check=S(O),O=0,z=0,h.mode=yt;case yt:if(h.havedict===0)return N.next_out=I,N.avail_out=p,N.next_in=s,N.avail_in=Y,h.hold=O,h.bits=z,M;N.adler=h.check=1,h.mode=Tt;case Tt:if(Z===P||Z===$)break t;case Jt:if(h.last){O>>>=z&7,z-=z&7,h.mode=Xt;break}for(;z<3;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}switch(h.last=O&1,O>>>=1,z-=1,O&3){case 0:h.mode=ae;break;case 1:if(ke(h),h.mode=jt,Z===$){O>>>=2,z-=2;break t}break;case 2:h.mode=st;break;case 3:N.msg="invalid block type",h.mode=Ft}O>>>=2,z-=2;break;case ae:for(O>>>=z&7,z-=z&7;z<32;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if((O&65535)!==(O>>>16^65535)){N.msg="invalid stored block lengths",h.mode=Ft;break}if(h.length=O&65535,O=0,z=0,h.mode=rt,Z===$)break t;case rt:h.mode=ot;case ot:if(xt=h.length,xt){if(xt>Y&&(xt=Y),xt>p&&(xt=p),xt===0)break t;b.arraySet(Ut,lt,s,xt,I),Y-=xt,s+=xt,p-=xt,I+=xt,h.length-=xt;break}h.mode=Tt;break;case st:for(;z<14;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(h.nlen=(O&31)+257,O>>>=5,z-=5,h.ndist=(O&31)+1,O>>>=5,z-=5,h.ncode=(O&15)+4,O>>>=4,z-=4,h.nlen>286||h.ndist>30){N.msg="too many length or distance symbols",h.mode=Ft;break}h.have=0,h.mode=Mt;case Mt:for(;h.have<h.ncode;){for(;z<3;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.lens[en[h.have++]]=O&7,O>>>=3,z-=3}for(;h.have<19;)h.lens[en[h.have++]]=0;if(h.lencode=h.lendyn,h.lenbits=7,De={bits:h.lenbits},Be=C(A,h.lens,0,19,h.lencode,0,h.work,De),h.lenbits=De.bits,Be){N.msg="invalid code lengths set",h.mode=Ft;break}h.have=0,h.mode=It;case It:for(;h.have<h.nlen+h.ndist;){for(;fe=h.lencode[O&(1<<h.lenbits)-1],Qt=fe>>>24,we=fe>>>16&255,ye=fe&65535,!(Qt<=z);){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(ye<16)O>>>=Qt,z-=Qt,h.lens[h.have++]=ye;else{if(ye===16){for(Ue=Qt+2;z<Ue;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(O>>>=Qt,z-=Qt,h.have===0){N.msg="invalid bit length repeat",h.mode=Ft;break}me=h.lens[h.have-1],xt=3+(O&3),O>>>=2,z-=2}else if(ye===17){for(Ue=Qt+3;z<Ue;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}O>>>=Qt,z-=Qt,me=0,xt=3+(O&7),O>>>=3,z-=3}else{for(Ue=Qt+7;z<Ue;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}O>>>=Qt,z-=Qt,me=0,xt=11+(O&127),O>>>=7,z-=7}if(h.have+xt>h.nlen+h.ndist){N.msg="invalid bit length repeat",h.mode=Ft;break}for(;xt--;)h.lens[h.have++]=me}}if(h.mode===Ft)break;if(h.lens[256]===0){N.msg="invalid code -- missing end-of-block",h.mode=Ft;break}if(h.lenbits=9,De={bits:h.lenbits},Be=C(T,h.lens,0,h.nlen,h.lencode,0,h.work,De),h.lenbits=De.bits,Be){N.msg="invalid literal/lengths set",h.mode=Ft;break}if(h.distbits=6,h.distcode=h.distdyn,De={bits:h.distbits},Be=C(m,h.lens,h.nlen,h.ndist,h.distcode,0,h.work,De),h.distbits=De.bits,Be){N.msg="invalid distances set",h.mode=Ft;break}if(h.mode=jt,Z===$)break t;case jt:h.mode=Yt;case Yt:if(Y>=6&&p>=258){N.next_out=I,N.avail_out=p,N.next_in=s,N.avail_in=Y,h.hold=O,h.bits=z,R(N,At),I=N.next_out,Ut=N.output,p=N.avail_out,s=N.next_in,lt=N.input,Y=N.avail_in,O=h.hold,z=h.bits,h.mode===Tt&&(h.back=-1);break}for(h.back=0;fe=h.lencode[O&(1<<h.lenbits)-1],Qt=fe>>>24,we=fe>>>16&255,ye=fe&65535,!(Qt<=z);){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(we&&(we&240)===0){for(Re=Qt,er=we,rr=ye;fe=h.lencode[rr+((O&(1<<Re+er)-1)>>Re)],Qt=fe>>>24,we=fe>>>16&255,ye=fe&65535,!(Re+Qt<=z);){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}O>>>=Re,z-=Re,h.back+=Re}if(O>>>=Qt,z-=Qt,h.back+=Qt,h.length=ye,we===0){h.mode=Nt;break}if(we&32){h.back=-1,h.mode=Tt;break}if(we&64){N.msg="invalid literal/length code",h.mode=Ft;break}h.extra=we&15,h.mode=le;case le:if(h.extra){for(Ue=h.extra;z<Ue;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.length+=O&(1<<h.extra)-1,O>>>=h.extra,z-=h.extra,h.back+=h.extra}h.was=h.length,h.mode=ne;case ne:for(;fe=h.distcode[O&(1<<h.distbits)-1],Qt=fe>>>24,we=fe>>>16&255,ye=fe&65535,!(Qt<=z);){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if((we&240)===0){for(Re=Qt,er=we,rr=ye;fe=h.distcode[rr+((O&(1<<Re+er)-1)>>Re)],Qt=fe>>>24,we=fe>>>16&255,ye=fe&65535,!(Re+Qt<=z);){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}O>>>=Re,z-=Re,h.back+=Re}if(O>>>=Qt,z-=Qt,h.back+=Qt,we&64){N.msg="invalid distance code",h.mode=Ft;break}h.offset=ye,h.extra=we&15,h.mode=Wt;case Wt:if(h.extra){for(Ue=h.extra;z<Ue;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}h.offset+=O&(1<<h.extra)-1,O>>>=h.extra,z-=h.extra,h.back+=h.extra}if(h.offset>h.dmax){N.msg="invalid distance too far back",h.mode=Ft;break}h.mode=Dt;case Dt:if(p===0)break t;if(xt=At-p,h.offset>xt){if(xt=h.offset-xt,xt>h.whave&&h.sane){N.msg="invalid distance too far back",h.mode=Ft;break}xt>h.wnext?(xt-=h.wnext,Zt=h.wsize-xt):Zt=h.wnext-xt,xt>h.length&&(xt=h.length),Fe=h.window}else Fe=Ut,Zt=I-h.offset,xt=h.length;xt>p&&(xt=p),p-=xt,h.length-=xt;do Ut[I++]=Fe[Zt++];while(--xt);h.length===0&&(h.mode=Yt);break;case Nt:if(p===0)break t;Ut[I++]=h.length,p--,h.mode=Yt;break;case Xt:if(h.wrap){for(;z<32;){if(Y===0)break t;Y--,O|=lt[s++]<<z,z+=8}if(At-=p,N.total_out+=At,h.total+=At,At&&(N.adler=h.check=h.flags?D(h.check,Ut,At,I-At):E(h.check,Ut,At,I-At)),At=p,(h.flags?O:S(O))!==h.check){N.msg="incorrect data check",h.mode=Ft;break}O=0,z=0}h.mode=Ht;case Ht:if(h.wrap&&h.flags){for(;z<32;){if(Y===0)break t;Y--,O+=lt[s++]<<z,z+=8}if(O!==(h.total&4294967295)){N.msg="incorrect length check",h.mode=Ft;break}O=0,z=0}h.mode=Kt;case Kt:Be=F;break t;case Ft:Be=ut;break t;case Lt:return H;case ce:default:return Q}return N.next_out=I,N.avail_out=p,N.next_in=s,N.avail_in=Y,h.hold=O,h.bits=z,(h.wsize||At!==N.avail_out&&h.mode<Ft&&(h.mode<Xt||Z!==g))&&je(N,N.output,N.next_out,At-N.avail_out),Pt-=N.avail_in,At-=N.avail_out,N.total_in+=Pt,N.total_out+=At,h.total+=At,h.wrap&&At&&(N.adler=h.check=h.flags?D(h.check,Ut,At,N.next_out-At):E(h.check,Ut,At,N.next_out-At)),N.data_type=h.bits+(h.last?64:0)+(h.mode===Tt?128:0)+(h.mode===jt||h.mode===rt?256:0),(Pt===0&&At===0||Z===g)&&Be===k&&(Be=G),Be}function ft(N){if(!N||!N.state)return Q;var Z=N.state;return Z.window&&(Z.window=null),N.state=null,k}function pt(N,Z){var h;return!N||!N.state||(h=N.state,(h.wrap&2)===0)?Q:(h.head=Z,Z.done=!1,k)}function Rt(N,Z){var h=Z.length,lt,Ut,s;return!N||!N.state||(lt=N.state,lt.wrap!==0&&lt.mode!==yt)?Q:lt.mode===yt&&(Ut=1,Ut=E(Ut,Z,h,0),Ut!==lt.check)?ut:(s=je(N,Z,h,h),s?(lt.mode=Lt,H):(lt.havedict=1,k))}return Me.inflateReset=ct,Me.inflateReset2=qt,Me.inflateResetKeep=nt,Me.inflateInit=Vt,Me.inflateInit2=Gt,Me.inflate=v,Me.inflateEnd=ft,Me.inflateGetHeader=pt,Me.inflateSetDictionary=Rt,Me.inflateInfo="pako inflate (from Nodeca project)",Me}var Wi,Bc;function tf(){return Bc||(Bc=1,Wi={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}),Wi}var Xi,Oc;function _l(){if(Oc)return Xi;Oc=1;function b(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}return Xi=b,Xi}var $c;function bl(){if($c)return Ar;$c=1;var b=vl(),E=tr(),D=Jc(),R=tf(),C=aa(),A=Qc(),T=_l(),m=Object.prototype.toString;function g(k){if(!(this instanceof g))return new g(k);this.options=E.assign({chunkSize:16384,windowBits:0,to:""},k||{});var F=this.options;F.raw&&F.windowBits>=0&&F.windowBits<16&&(F.windowBits=-F.windowBits,F.windowBits===0&&(F.windowBits=-15)),F.windowBits>=0&&F.windowBits<16&&!(k&&k.windowBits)&&(F.windowBits+=32),F.windowBits>15&&F.windowBits<48&&(F.windowBits&15)===0&&(F.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new A,this.strm.avail_out=0;var M=b.inflateInit2(this.strm,F.windowBits);if(M!==R.Z_OK)throw new Error(C[M]);if(this.header=new T,b.inflateGetHeader(this.strm,this.header),F.dictionary&&(typeof F.dictionary=="string"?F.dictionary=D.string2buf(F.dictionary):m.call(F.dictionary)==="[object ArrayBuffer]"&&(F.dictionary=new Uint8Array(F.dictionary)),F.raw&&(M=b.inflateSetDictionary(this.strm,F.dictionary),M!==R.Z_OK)))throw new Error(C[M])}g.prototype.push=function(k,F){var M=this.strm,Q=this.options.chunkSize,ut=this.options.dictionary,H,G,K,L,at,ht=!1;if(this.ended)return!1;G=F===~~F?F:F===!0?R.Z_FINISH:R.Z_NO_FLUSH,typeof k=="string"?M.input=D.binstring2buf(k):m.call(k)==="[object ArrayBuffer]"?M.input=new Uint8Array(k):M.input=k,M.next_in=0,M.avail_in=M.input.length;do{if(M.avail_out===0&&(M.output=new E.Buf8(Q),M.next_out=0,M.avail_out=Q),H=b.inflate(M,R.Z_NO_FLUSH),H===R.Z_NEED_DICT&&ut&&(H=b.inflateSetDictionary(this.strm,ut)),H===R.Z_BUF_ERROR&&ht===!0&&(H=R.Z_OK,ht=!1),H!==R.Z_STREAM_END&&H!==R.Z_OK)return this.onEnd(H),this.ended=!0,!1;M.next_out&&(M.avail_out===0||H===R.Z_STREAM_END||M.avail_in===0&&(G===R.Z_FINISH||G===R.Z_SYNC_FLUSH))&&(this.options.to==="string"?(K=D.utf8border(M.output,M.next_out),L=M.next_out-K,at=D.buf2string(M.output,K),M.next_out=L,M.avail_out=Q-L,L&&E.arraySet(M.output,M.output,K,L,0),this.onData(at)):this.onData(E.shrinkBuf(M.output,M.next_out))),M.avail_in===0&&M.avail_out===0&&(ht=!0)}while((M.avail_in>0||M.avail_out===0)&&H!==R.Z_STREAM_END);return H===R.Z_STREAM_END&&(G=R.Z_FINISH),G===R.Z_FINISH?(H=b.inflateEnd(this.strm),this.onEnd(H),this.ended=!0,H===R.Z_OK):(G===R.Z_SYNC_FLUSH&&(this.onEnd(R.Z_OK),M.avail_out=0),!0)},g.prototype.onData=function(k){this.chunks.push(k)},g.prototype.onEnd=function(k){k===R.Z_OK&&(this.options.to==="string"?this.result=this.chunks.join(""):this.result=E.flattenChunks(this.chunks)),this.chunks=[],this.err=k,this.msg=this.strm.msg};function P(k,F){var M=new g(F);if(M.push(k,!0),M.err)throw M.msg||C[M.err];return M.result}function $(k,F){return F=F||{},F.raw=!0,P(k,F)}return Ar.Inflate=g,Ar.inflate=P,Ar.inflateRaw=$,Ar.ungzip=P,Ar}var Vi,Cc;function xl(){if(Cc)return Vi;Cc=1;var b=tr().assign,E=ml(),D=bl(),R=tf(),C={};return b(C,E,D,R),Vi=C,Vi}var Yi,Pc;function El(){if(Pc)return Yi;Pc=1;const b=(E,D)=>function(...R){const C=D.promiseModule;return new C((A,T)=>{D.multiArgs?R.push((...m)=>{D.errorFirst?m[0]?T(m):(m.shift(),A(m)):A(m)}):D.errorFirst?R.push((m,g)=>{m?T(m):A(g)}):R.push(A),E.apply(this,R)})};return Yi=(E,D)=>{D=Object.assign({exclude:[/.+(Sync|Stream)$/],errorFirst:!0,promiseModule:Promise},D);const R=typeof E;if(!(E!==null&&(R==="object"||R==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${E===null?"null":R}\``);const C=T=>{const m=g=>typeof g=="string"?T===g:g.test(T);return D.include?D.include.some(m):!D.exclude.some(m)};let A;R==="function"?A=function(...T){return D.excludeMain?E(...T):b(E,D).apply(this,T)}:A=Object.create(Object.getPrototypeOf(E));for(const T in E){const m=E[T];A[T]=typeof m=="function"&&C(T)?b(m,D):m}return A},Yi}var Ki,Fc;function Sl(){if(Fc)return Ki;Fc=1;var b={};function E(rt){return Array.isArray(rt)?rt:[rt]}const D="",R=" ",C="\\",A=/^\s+$/,T=/(?:[^\\]|^)\\$/,m=/^\\!/,g=/^\\#/,P=/\r?\n/g,$=/^\.*\/|^\.+$/,k="/";let F="node-ignore";typeof Symbol<"u"&&(F=Symbol.for("node-ignore"));const M=F,Q=(rt,ot,st)=>Object.defineProperty(rt,ot,{value:st}),ut=/([0-z])-([0-z])/g,H=()=>!1,G=rt=>rt.replace(ut,(ot,st,Mt)=>st.charCodeAt(0)<=Mt.charCodeAt(0)?ot:D),K=rt=>{const{length:ot}=rt;return rt.slice(0,ot-ot%2)},L=[[/^\uFEFF/,()=>D],[/((?:\\\\)*?)(\\?\s+)$/,(rt,ot,st)=>ot+(st.indexOf("\\")===0?R:D)],[/(\\+?)\s/g,(rt,ot)=>{const{length:st}=ot;return ot.slice(0,st-st%2)+R}],[/[\\$.|*+(){^]/g,rt=>`\\${rt}`],[/(?!\\)\?/g,()=>"[^/]"],[/^\//,()=>"^"],[/\//g,()=>"\\/"],[/^\^*\\\*\\\*\\\//,()=>"^(?:.*\\/)?"],[/^(?=[^^])/,function(){return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}],[/\\\/\\\*\\\*(?=\\\/|$)/g,(rt,ot,st)=>ot+6<st.length?"(?:\\/[^\\/]+)*":"\\/.+"],[/(^|[^\\]+)(\\\*)+(?=.+)/g,(rt,ot,st)=>{const Mt=st.replace(/\\\*/g,"[^\\/]*");return ot+Mt}],[/\\\\\\(?=[$.|*+(){^])/g,()=>C],[/\\\\/g,()=>C],[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,(rt,ot,st,Mt,It)=>ot===C?`\\[${st}${K(Mt)}${It}`:It==="]"&&Mt.length%2===0?`[${G(st)}${Mt}]`:"[]"],[/(?:[^*])$/,rt=>/\/$/.test(rt)?`${rt}$`:`${rt}(?=$|\\/$)`],[/(\^|\\\/)?\\\*$/,(rt,ot)=>`${ot?`${ot}[^/]+`:"[^/]*"}(?=$|\\/$)`]],at=Object.create(null),ht=(rt,ot)=>{let st=at[rt];return st||(st=L.reduce((Mt,[It,jt])=>Mt.replace(It,jt.bind(rt)),rt),at[rt]=st),ot?new RegExp(st,"i"):new RegExp(st)},wt=rt=>typeof rt=="string",W=rt=>rt&&wt(rt)&&!A.test(rt)&&!T.test(rt)&&rt.indexOf("#")!==0,V=rt=>rt.split(P);class gt{constructor(ot,st,Mt,It){this.origin=ot,this.pattern=st,this.negative=Mt,this.regex=It}}const tt=(rt,ot)=>{const st=rt;let Mt=!1;rt.indexOf("!")===0&&(Mt=!0,rt=rt.substr(1)),rt=rt.replace(m,"!").replace(g,"#");const It=ht(rt,ot);return new gt(st,rt,Mt,It)},_t=(rt,ot)=>{throw new ot(rt)},dt=(rt,ot,st)=>wt(rt)?rt?dt.isNotRelative(rt)?st(`path should be a \`path.relative()\`d string, but got "${ot}"`,RangeError):!0:st("path must not be empty",TypeError):st(`path must be a string, but got \`${ot}\``,TypeError),yt=rt=>$.test(rt);dt.isNotRelative=yt,dt.convert=rt=>rt;class Tt{constructor({ignorecase:ot=!0,ignoreCase:st=ot,allowRelativePaths:Mt=!1}={}){Q(this,M,!0),this._rules=[],this._ignoreCase=st,this._allowRelativePaths=Mt,this._initCache()}_initCache(){this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}_addPattern(ot){if(ot&&ot[M]){this._rules=this._rules.concat(ot._rules),this._added=!0;return}if(W(ot)){const st=tt(ot,this._ignoreCase);this._added=!0,this._rules.push(st)}}add(ot){return this._added=!1,E(wt(ot)?V(ot):ot).forEach(this._addPattern,this),this._added&&this._initCache(),this}addPattern(ot){return this.add(ot)}_testOne(ot,st){let Mt=!1,It=!1;return this._rules.forEach(jt=>{const{negative:Yt}=jt;if(It===Yt&&Mt!==It||Yt&&!Mt&&!It&&!st)return;jt.regex.test(ot)&&(Mt=!Yt,It=Yt)}),{ignored:Mt,unignored:It}}_test(ot,st,Mt,It){const jt=ot&&dt.convert(ot);return dt(jt,ot,this._allowRelativePaths?H:_t),this._t(jt,st,Mt,It)}_t(ot,st,Mt,It){if(ot in st)return st[ot];if(It||(It=ot.split(k)),It.pop(),!It.length)return st[ot]=this._testOne(ot,Mt);const jt=this._t(It.join(k)+k,st,Mt,It);return st[ot]=jt.ignored?jt:this._testOne(ot,Mt)}ignores(ot){return this._test(ot,this._ignoreCache,!1).ignored}createFilter(){return ot=>!this.ignores(ot)}filter(ot){return E(ot).filter(this.createFilter())}test(ot){return this._test(ot,this._testCache,!0)}}const Jt=rt=>new Tt(rt),ae=rt=>dt(rt&&dt.convert(rt),rt,H);if(Jt.isPathValid=ae,Jt.default=Jt,Ki=Jt,typeof process<"u"&&(b&&b.IGNORE_TEST_WIN32||process.platform==="win32")){const rt=st=>/^\\\\\?\\/.test(st)||/["<>|\u0000-\u001F]+/u.test(st)?st:st.replace(/\\/g,"/");dt.convert=rt;const ot=/^[a-z]:\//i;dt.isNotRelative=st=>ot.test(st)||yt(st)}return Ki}var Ji,Dc;function Al(){if(Dc)return Ji;Dc=1;function b(R){return R.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(R,C,A){return C=C instanceof RegExp?C:new RegExp(b(C),"g"),R.replace(C,A)}var D={clean:function(C){if(typeof C!="string")throw new Error("Expected a string, received: "+C);return C=E(C,"./","/"),C=E(C,"..","."),C=E(C," ","-"),C=E(C,/^[~^:?*\\\-]/g,""),C=E(C,/[~^:?*\\]/g,"-"),C=E(C,/[~^:?*\\\-]$/g,""),C=E(C,"@{","-"),C=E(C,/\.$/g,""),C=E(C,/\/$/g,""),C=E(C,/\.lock$/g,""),C}};return Ji=D,Ji}var Qi,Uc;function kl(){return Uc||(Uc=1,Qi=function(b,E){var D=b,R=E,C=D.length,A=R.length,T=!1,m=null,g=C+1,P=[],$=[],k=[],F="",M=-1,Q=0,ut=1,H,G,K=function(){C>=A&&(H=D,G=C,D=R,R=H,C=A,A=G,T=!0,g=C+1)},L=function(W,V,gt){return{x:W,y:V,k:gt}},at=function(W,V){return{elem:W,t:V}},ht=function(W,V,gt){var tt,_t,dt;for(V>gt?tt=P[W-1+g]:tt=P[W+1+g],dt=Math.max(V,gt),_t=dt-W;_t<C&&dt<A&&D[_t]===R[dt];)++_t,++dt;return P[W+g]=$.length,$[$.length]=new L(_t,dt,tt),dt},wt=function(W){var V,gt,tt;for(V=gt=0,tt=W.length-1;tt>=0;--tt)for(;V<W[tt].x||gt<W[tt].y;)W[tt].y-W[tt].x>gt-V?(T?k[k.length]=new at(R[gt],M):k[k.length]=new at(R[gt],ut),++gt):W[tt].y-W[tt].x<gt-V?(T?k[k.length]=new at(D[V],ut):k[k.length]=new at(D[V],M),++V):(k[k.length]=new at(D[V],Q),F+=D[V],++V,++gt)};return K(),{SES_DELETE:-1,SES_COMMON:0,SES_ADD:1,editdistance:function(){return m},getlcs:function(){return F},getses:function(){return k},compose:function(){var W,V,gt,tt,_t,dt,yt,Tt;for(W=A-C,V=C+A+3,gt={},yt=0;yt<V;++yt)gt[yt]=-1,P[yt]=-1;tt=-1;do{for(++tt,Tt=-tt;Tt<=W-1;++Tt)gt[Tt+g]=ht(Tt,gt[Tt-1+g]+1,gt[Tt+1+g]);for(Tt=W+tt;Tt>=W+1;--Tt)gt[Tt+g]=ht(Tt,gt[Tt-1+g]+1,gt[Tt+1+g]);gt[W+g]=ht(W,gt[W-1+g]+1,gt[W+1+g])}while(gt[W+g]!==A);for(m=W+2*tt,_t=P[W+g],dt=[];_t!==-1;)dt[dt.length]=new L($[_t].x,$[_t].y,null),_t=$[_t].k;wt(dt)}}}),Qi}var ta,Nc;function Rl(){if(Nc)return ta;Nc=1;var b=kl();function E(A,T){var m=new b(A,T);m.compose();for(var g=m.getses(),P,$,k=A.length-1,F=T.length-1,M=g.length-1;M>=0;--M)g[M].t===m.SES_COMMON?($?($.chain={file1index:k,file2index:F,chain:null},$=$.chain):(P={file1index:k,file2index:F,chain:null},$=P),k--,F--):g[M].t===m.SES_DELETE?k--:g[M].t===m.SES_ADD&&F--;var Q={file1index:-1,file2index:-1,chain:null};return $?($.chain=Q,P):Q}function D(A,T){for(var m=[],g=A.length,P=T.length,$=E(A,T);$!==null;$=$.chain){var k=g-$.file1index-1,F=P-$.file2index-1;g=$.file1index,P=$.file2index,(k||F)&&m.push({file1:[g+1,k],file2:[P+1,F]})}return m.reverse(),m}function R(A,T,m){var g,P=D(T,A),$=D(T,m),k=[];function F(ot,st){k.push([ot.file1[0],st,ot.file1[1],ot.file2[0],ot.file2[1]])}for(g=0;g<P.length;g++)F(P[g],0);for(g=0;g<$.length;g++)F($[g],2);k.sort(function(ot,st){return ot[0]-st[0]});var M=[],Q=0;function ut(ot){ot>Q&&(M.push([1,Q,ot-Q]),Q=ot)}for(var H=0;H<k.length;H++){for(var G=H,K=k[H],L=K[0],at=L+K[2];H<k.length-1;){var ht=k[H+1],wt=ht[0];if(wt>at)break;at=Math.max(at,wt+ht[2]),H++}if(ut(L),G==H)K[4]>0&&M.push([K[1],K[3],K[4]]);else{var W={0:[A.length,-1,T.length,-1],2:[m.length,-1,T.length,-1]};for(g=G;g<=H;g++){K=k[g];var V=K[1],gt=W[V],tt=K[0],_t=tt+K[2],dt=K[3],yt=dt+K[4];gt[0]=Math.min(dt,gt[0]),gt[1]=Math.max(yt,gt[1]),gt[2]=Math.min(tt,gt[2]),gt[3]=Math.max(_t,gt[3])}var Tt=W[0][0]+(L-W[0][2]),Jt=W[0][1]+(at-W[0][3]),ae=W[2][0]+(L-W[2][2]),rt=W[2][1]+(at-W[2][3]);M.push([-1,Tt,Jt-Tt,L,at-L,ae,rt-ae])}Q=at}return ut(T.length),M}function C(A,T,m){var g=[],P=[A,T,m],$=R(A,T,m),k=[];function F(){k.length&&g.push({ok:k}),k=[]}function M(K){for(var L=0;L<K.length;L++)k.push(K[L])}function Q(K){if(K[2]!=K[6])return!0;for(var L=K[1],at=K[5],ht=0;ht<K[2];ht++)if(A[ht+L]!=m[ht+at])return!0;return!1}for(var ut=0;ut<$.length;ut++){var H=$[ut],G=H[0];G==-1?Q(H)?(F(),g.push({conflict:{a:A.slice(H[1],H[1]+H[2]),aIndex:H[1],o:T.slice(H[3],H[3]+H[4]),oIndex:H[3],b:m.slice(H[5],H[5]+H[6]),bIndex:H[5]}})):M(P[0].slice(H[1],H[1]+H[2])):M(P[G].slice(H[1],H[1]+H[2]))}return F(),g}return ta=C,ta}var Mc;function Tl(){if(Mc)return St;Mc=1,Object.defineProperty(St,"__esModule",{value:!0});function b(r){return r&&typeof r=="object"&&"default"in r?r.default:r}var E=b(ku()),D=b(hl()),R=b(dl()),C=b(xl()),A=b(El()),T=b(Sl()),m=b(Al()),g=b(Rl());class P extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new P(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class $ extends P{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=$.code,this.data={filepaths:t}}}$.code="UnmergedPathsError";class k extends P{constructor(t){super(`An internal error caused this command to fail.

If you're not a developer, report the bug to the developers of the application you're using. If this is a bug in isomorphic-git then you should create a proper bug yourselves. The bug should include a minimal reproduction and details about the version and environment.

Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=k.code,this.data={message:t}}}k.code="InternalError";class F extends P{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=F.code,this.data={filepath:t}}}F.code="UnsafeFilepathError";class M{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const n=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,n}write(t,e,n){const i=this.buffer.write(t,this._start,e,n);return this._start+=e,i}copy(t,e,n){const i=t.copy(this.buffer,this._start,e,n);return this._start+=i,i}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function Q(r,t){return-(r<t)||+(r>t)}function ut(r,t){return Q(r.path,t.path)}function H(r){let t=r>0?r>>12:0;t!==4&&t!==8&&t!==10&&t!==14&&(t=8);let e=r&511;return e&73?e=493:e=420,t!==8&&(e=0),(t<<12)+e}const G=2**32;function K(r,t,e,n){if(r!==void 0&&t!==void 0)return[r,t];e===void 0&&(e=n.valueOf());const i=Math.floor(e/1e3),a=(e-i*1e3)*1e6;return[i,a]}function L(r){const[t,e]=K(r.ctimeSeconds,r.ctimeNanoseconds,r.ctimeMs,r.ctime),[n,i]=K(r.mtimeSeconds,r.mtimeNanoseconds,r.mtimeMs,r.mtime);return{ctimeSeconds:t%G,ctimeNanoseconds:e%G,mtimeSeconds:n%G,mtimeNanoseconds:i%G,dev:r.dev%G,ino:r.ino%G,mode:H(r.mode%G),uid:r.uid%G,gid:r.gid%G,size:r.size>-1?r.size%G:0}}function at(r){let t="";for(const e of new Uint8Array(r))e<16&&(t+="0"),t+=e.toString(16);return t}let ht=null;async function wt(r){return ht===null&&(ht=await gt()),ht?V(r):W(r)}function W(r){return new D().update(r).digest("hex")}async function V(r){const t=await crypto.subtle.digest("SHA-1",r);return at(t)}async function gt(){try{return await V(new Uint8Array([]))==="da39a3ee5e6b4b0d3255bfef95601890afd80709"}catch{}return!1}function tt(r){return{assumeValid:!!(r&32768),extended:!!(r&16384),stage:(r&12288)>>12,nameLength:r&4095}}function _t(r){const t=r.flags;return t.extended=!1,t.nameLength=Math.min(Buffer.from(r.path).length,4095),(t.assumeValid?32768:0)+(t.extended?16384:0)+((t.stage&3)<<12)+(t.nameLength&4095)}class dt{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(t.flags.stage===0)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(Buffer.isBuffer(t))return dt.fromBuffer(t);if(t===null)return new dt(null);throw new k("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(t.length===0)throw new k("Index file is empty (.git/index)");const e=new dt,n=new M(t),i=n.toString("utf8",4);if(i!=="DIRC")throw new k(`Invalid dircache magic file number: ${i}`);const a=await wt(t.slice(0,-20)),c=t.slice(-20).toString("hex");if(c!==a)throw new k(`Invalid checksum in GitIndex buffer: expected ${c} but saw ${a}`);const u=n.readUInt32BE();if(u!==2)throw new k(`Unsupported dircache version: ${u}`);const d=n.readUInt32BE();let w=0;for(;!n.eof()&&w<d;){const l={};l.ctimeSeconds=n.readUInt32BE(),l.ctimeNanoseconds=n.readUInt32BE(),l.mtimeSeconds=n.readUInt32BE(),l.mtimeNanoseconds=n.readUInt32BE(),l.dev=n.readUInt32BE(),l.ino=n.readUInt32BE(),l.mode=n.readUInt32BE(),l.uid=n.readUInt32BE(),l.gid=n.readUInt32BE(),l.size=n.readUInt32BE(),l.oid=n.slice(20).toString("hex");const _=n.readUInt16BE();l.flags=tt(_);const x=t.indexOf(0,n.tell()+1)-n.tell();if(x<1)throw new k(`Got a path length of: ${x}`);if(l.path=n.toString("utf8",x),l.path.includes("..\\")||l.path.includes("../"))throw new F(l.path);let B=8-(n.tell()-12)%8;for(B===0&&(B=8);B--;){const j=n.readUInt8();if(j!==0)throw new k(`Expected 1-8 null characters but got '${j}' after ${l.path}`);if(n.eof())throw new k("Unexpected end of file")}l.stages=[],e._addEntry(l),w++}return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(ut)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap(t=>t.stages.length>1?t.stages.filter(e=>e):t)}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:n,stage:i=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=L(e);const a=Buffer.from(t),c={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:n,flags:{assumeValid:!1,extended:!1,stage:i,nameLength:a.length<4095?a.length:4095},stages:[]};this._addEntry(c),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map(t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`)}static async _entryToBuffer(t){const e=Buffer.from(t.path),n=Math.ceil((62+e.length+1)/8)*8,i=Buffer.alloc(n),a=new M(i),c=L(t);return a.writeUInt32BE(c.ctimeSeconds),a.writeUInt32BE(c.ctimeNanoseconds),a.writeUInt32BE(c.mtimeSeconds),a.writeUInt32BE(c.mtimeNanoseconds),a.writeUInt32BE(c.dev),a.writeUInt32BE(c.ino),a.writeUInt32BE(c.mode),a.writeUInt32BE(c.uid),a.writeUInt32BE(c.gid),a.writeUInt32BE(c.size),a.write(t.oid,20,"hex"),a.writeUInt16BE(_t(t)),a.write(t.path,e.length,"utf8"),i}async toObject(){const t=Buffer.alloc(12),e=new M(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let n=[];for(const u of this.entries)if(n.push(dt._entryToBuffer(u)),u.stages.length>1)for(const d of u.stages)d&&d!==u&&n.push(dt._entryToBuffer(d));n=await Promise.all(n);const i=Buffer.concat(n),a=Buffer.concat([t,i]),c=await wt(a);return Buffer.concat([a,Buffer.from(c,"hex")])}}function yt(r,t,e=!0,n=!0){const i=L(r),a=L(t);return e&&i.mode!==a.mode||i.mtimeSeconds!==a.mtimeSeconds||i.ctimeSeconds!==a.ctimeSeconds||i.uid!==a.uid||i.gid!==a.gid||n&&i.ino!==a.ino||i.size!==a.size}let Tt=null;const Jt=Symbol("IndexCache");function ae(){return{map:new Map,stats:new Map}}async function rt(r,t,e){const[n,i]=await Promise.all([r.lstat(t),r.read(t)]),a=await dt.from(i);e.map.set(t,a),e.stats.set(t,n)}async function ot(r,t,e){const n=e.stats.get(t);if(n===void 0)return!0;if(n===null)return!1;const i=await r.lstat(t);return i===null?!1:yt(n,i)}class st{static async acquire({fs:t,gitdir:e,cache:n,allowUnmerged:i=!0},a){n[Jt]||(n[Jt]=ae());const c=`${e}/index`;Tt===null&&(Tt=new E({maxPending:1/0}));let u,d=[];return await Tt.acquire(c,async()=>{const w=n[Jt];await ot(t,c,w)&&await rt(t,c,w);const l=w.map.get(c);if(d=l.unmergedPaths,d.length&&!i)throw new $(d);if(u=await a(l),l._dirty){const _=await l.toObject();await t.write(c,_),w.stats.set(c,await t.lstat(c)),l._dirty=!1}}),u}}function Mt(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t>-1&&(r=r.slice(t+1)),r}function It(r){const t=Math.max(r.lastIndexOf("/"),r.lastIndexOf("\\"));return t===-1?".":t===0?"/":r.slice(0,t)}function jt(r){const t=new Map,e=function(i){if(!t.has(i)){const a={type:"tree",fullpath:i,basename:Mt(i),metadata:{},children:[]};t.set(i,a),a.parent=e(It(i)),a.parent&&a.parent!==a&&a.parent.children.push(a)}return t.get(i)},n=function(i,a){if(!t.has(i)){const c={type:"blob",fullpath:i,basename:Mt(i),metadata:a,parent:e(It(i)),children:[]};c.parent&&c.parent.children.push(c),t.set(i,c)}return t.get(i)};e(".");for(const i of r)n(i.path,i);return t}function Yt(r){switch(r){case 16384:return"tree";case 33188:return"blob";case 33261:return"blob";case 40960:return"blob";case 57344:return"commit"}throw new k(`Unexpected GitTree entry mode: ${r.toString(8)}`)}class le{constructor({fs:t,gitdir:e,cache:n}){this.treePromise=st.acquire({fs:t,gitdir:e,cache:n},async function(a){return jt(a.entries)});const i=this;this.ConstructEntry=class{constructor(c){this._fullpath=c,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,i=(await this.treePromise).get(e);if(!i||i.type==="blob")return null;if(i.type!=="tree")throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const a=i.children.map(c=>c.fullpath);return a.sort(Q),a}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const n=(await this.treePromise).get(t._fullpath);if(!n)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const i=n.type==="tree"?{}:L(n.metadata);t._type=n.type==="tree"?"tree":Yt(i.mode),t._mode=i.mode,n.type==="tree"?t._stat=void 0:t._stat=i}return t._stat}async content(t){}async oid(t){if(t._oid===!1){const n=(await this.treePromise).get(t._fullpath);t._oid=n.metadata.oid}return t._oid}}const ne=Symbol("GitWalkSymbol");function Wt(){const r=Object.create(null);return Object.defineProperty(r,ne,{value:function({fs:t,gitdir:e,cache:n}){return new le({fs:t,gitdir:e,cache:n})}}),Object.freeze(r),r}class Dt extends P{constructor(t){super(`Could not find ${t}.`),this.code=this.name=Dt.code,this.data={what:t}}}Dt.code="NotFoundError";class Nt extends P{constructor(t,e,n,i){super(`Object ${t} ${i?`at ${i}`:""}was anticipated to be a ${n} but it is a ${e}.`),this.code=this.name=Nt.code,this.data={oid:t,actual:e,expected:n,filepath:i}}}Nt.code="ObjectTypeError";class Xt extends P{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=Xt.code,this.data={value:t}}}Xt.code="InvalidOidError";class Ht extends P{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:
[remote "${t}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`),this.code=this.name=Ht.code,this.data={remote:t}}}Ht.code="NoRefspecError";class Kt{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split(`
`).map(n=>{if(/^\s*#/.test(n))return{line:n,comment:!0};const i=n.indexOf(" ");if(n.startsWith("^")){const a=n.slice(1);return this.refs.set(e+"^{}",a),{line:n,ref:e,peeled:a}}else{const a=n.slice(0,i);return e=n.slice(i+1),this.refs.set(e,a),{line:n,ref:e,oid:a}}})}return this}static from(t){return new Kt(t)}delete(t){this.parsedConfig=this.parsedConfig.filter(e=>e.ref!==t),this.refs.delete(t)}toString(){return this.parsedConfig.map(({line:t})=>t).join(`
`)+`
`}}class Ft{constructor({remotePath:t,localPath:e,force:n,matchPrefix:i}){Object.assign(this,{remotePath:t,localPath:e,force:n,matchPrefix:i})}static from(t){const[e,n,i,a,c]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),u=e==="+",d=i==="*";if(d!==(c==="*"))throw new k("Invalid refspec");return new Ft({remotePath:n,localPath:a,force:u,matchPrefix:d})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class Lt{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const n of t)e.push(Ft.from(n));return new Lt(e)}add(t){const e=Ft.from(t);this.rules.push(e)}translate(t){const e=[];for(const n of this.rules)for(const i of t){const a=n.translate(i);a&&e.push([i,a])}return e}translateOne(t){let e=null;for(const n of this.rules){const i=n.translate(t);i&&(e=i)}return e}localNamespaces(){return this.rules.filter(t=>t.matchPrefix).map(t=>t.localPath.replace(/\/$/,""))}}function ce(r,t){const e=r.replace(/\^\{\}$/,""),n=t.replace(/\^\{\}$/,""),i=-(e<n)||+(e>n);return i===0?r.endsWith("^{}")?1:-1:i}/*!
 * This code for `path.join` is directly copied from @zenfs/core/path for bundle size improvements.
 * SPDX-License-Identifier: LGPL-3.0-or-later
 * Copyright (c) James Prevett and other ZenFS contributors.
 */function he(r,t){let e="",n=0,i=-1,a=0,c="\0";for(let u=0;u<=r.length;++u){if(u<r.length)c=r[u];else{if(c==="/")break;c="/"}if(c==="/"){if(!(i===u-1||a===1))if(a===2){if(e.length<2||n!==2||e.at(-1)!=="."||e.at(-2)!=="."){if(e.length>2){const d=e.lastIndexOf("/");d===-1?(e="",n=0):(e=e.slice(0,d),n=e.length-1-e.lastIndexOf("/")),i=u,a=0;continue}else if(e.length!==0){e="",n=0,i=u,a=0;continue}}t&&(e+=e.length>0?"/..":"..",n=2)}else e.length>0?e+="/"+r.slice(i+1,u):e=r.slice(i+1,u),n=u-i-1;i=u,a=0}else c==="."&&a!==-1?++a:a=-1}return e}function y(r){if(!r.length)return".";const t=r[0]==="/",e=r.at(-1)==="/";return r=he(r,!t),r.length?(e&&(r+="/"),t?`/${r}`:r):t?"/":e?"./":"."}function o(...r){if(r.length===0)return".";let t;for(let e=0;e<r.length;++e){const n=r[e];n.length>0&&(t===void 0?t=n:t+="/"+n)}return t===void 0?".":y(t)}const f=r=>{if(typeof r=="number")return r;r=r.toLowerCase();let t=parseInt(r);return r.endsWith("k")&&(t*=1024),r.endsWith("m")&&(t*=1024*1024),r.endsWith("g")&&(t*=1024*1024*1024),t},S=r=>{if(typeof r=="boolean")return r;if(r=r.trim().toLowerCase(),r==="true"||r==="yes"||r==="on")return!0;if(r==="false"||r==="no"||r==="off")return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${r}`)},q={core:{filemode:S,bare:S,logallrefupdates:S,symlinks:S,ignorecase:S,bigFileThreshold:f}},nt=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,ct=/^[A-Za-z0-9-.]+$/,qt=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Gt=/^[A-Za-z][A-Za-z-]*$/,Vt=/^(.*?)( *[#;].*)$/,oe=r=>{const t=nt.exec(r);if(t!=null){const[e,n]=t.slice(1);return[e,n]}return null},te=r=>{const t=qt.exec(r);if(t!=null){const[e,n="true"]=t.slice(1),i=de(n),a=je(i);return[e,a]}return null},de=r=>{const t=Vt.exec(r);if(t==null)return r;const[e,n]=t.slice(1);return ke(e)&&ke(n)?`${e}${n}`:e},ke=r=>(r.match(/(?:^|[^\\])"/g)||[]).length%2!==0,je=r=>r.split("").reduce((t,e,n,i)=>{const a=e==='"'&&i[n-1]!=="\\",c=e==="\\"&&i[n+1]==='"';return a||c?t:t+e},""),v=r=>r!=null?r.toLowerCase():null,ft=(r,t,e)=>[v(r),t,v(e)].filter(n=>n!=null).join("."),pt=r=>{const t=r.split("."),e=t.shift(),n=t.pop(),i=t.length?t.join("."):void 0;return{section:e,subsection:i,name:n,path:ft(e,i,n),sectionPath:ft(e,i,null),isSection:!!e}},Rt=(r,t)=>r.reduce((e,n,i)=>t(n)?i:e,-1);class N{constructor(t){let e=null,n=null;this.parsedConfig=t?t.split(`
`).map(i=>{let a=null,c=null;const u=i.trim(),d=oe(u),w=d!=null;if(w)[e,n]=d;else{const _=te(u);_!=null&&([a,c]=_)}const l=ft(e,n,a);return{line:i,isSection:w,section:e,subsection:n,name:a,value:c,path:l}}):[]}static from(t){return new N(t)}async get(t,e=!1){const n=pt(t).path,i=this.parsedConfig.filter(a=>a.path===n).map(({section:a,name:c,value:u})=>{const d=q[a]&&q[a][c];return d?d(u):u});return e?i:i.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter(e=>e.isSection&&e.section===t).map(e=>e.subsection)}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter(n=>!(n.section===t&&n.subsection===e))}async append(t,e){return this.set(t,e,!0)}async set(t,e,n=!1){const{section:i,subsection:a,name:c,path:u,sectionPath:d,isSection:w}=pt(t),l=Rt(this.parsedConfig,_=>_.path===u);if(e==null)l!==-1&&this.parsedConfig.splice(l,1);else if(l!==-1){const _=this.parsedConfig[l],x=Object.assign({},_,{name:c,value:e,modified:!0});n?this.parsedConfig.splice(l+1,0,x):this.parsedConfig[l]=x}else{const _=this.parsedConfig.findIndex(B=>B.path===d),x={section:i,subsection:a,name:c,value:e,modified:!0,path:u};if(ct.test(i)&&Gt.test(c))if(_>=0)this.parsedConfig.splice(_+1,0,x);else{const B={isSection:w,section:i,subsection:a,modified:!0,path:d};this.parsedConfig.push(B,x)}}}toString(){return this.parsedConfig.map(({line:t,section:e,subsection:n,name:i,value:a,modified:c=!1})=>c?i!=null&&a!=null?typeof a=="string"&&/[#;]/.test(a)?`	${i} = "${a}"`:`	${i} = ${a}`:n!=null?`[${e} "${n}"]`:`[${e}]`:t).join(`
`)}}class Z{static async get({fs:t,gitdir:e}){const n=await t.read(`${e}/config`,{encoding:"utf8"});return N.from(n)}static async save({fs:t,gitdir:e,config:n}){await t.write(`${e}/config`,n.toString(),{encoding:"utf8"})}}const h=r=>[`${r}`,`refs/${r}`,`refs/tags/${r}`,`refs/heads/${r}`,`refs/remotes/${r}`,`refs/remotes/${r}/HEAD`],lt=["config","description","index","shallow","commondir"];let Ut;async function s(r,t){return Ut===void 0&&(Ut=new E),Ut.acquire(r,t)}class I{static async updateRemoteRefs({fs:t,gitdir:e,remote:n,refs:i,symrefs:a,tags:c,refspecs:u=void 0,prune:d=!1,pruneTags:w=!1}){for(const X of i.values())if(!X.match(/[0-9a-f]{40}/))throw new Xt(X);const l=await Z.get({fs:t,gitdir:e});if(!u){if(u=await l.getall(`remote.${n}.fetch`),u.length===0)throw new Ht(n);u.unshift(`+HEAD:refs/remotes/${n}/HEAD`)}const _=Lt.from(u),x=new Map;if(w){const X=await I.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await I.deleteRefs({fs:t,gitdir:e,refs:X.map(et=>`refs/tags/${et}`)})}if(c){for(const X of i.keys())if(X.startsWith("refs/tags")&&!X.endsWith("^{}")&&!await I.exists({fs:t,gitdir:e,ref:X})){const et=i.get(X);x.set(X,et)}}const B=_.translate([...i.keys()]);for(const[X,et]of B){const it=i.get(X);x.set(et,it)}const j=_.translate([...a.keys()]);for(const[X,et]of j){const it=a.get(X),bt=_.translateOne(it);bt&&x.set(et,`ref: ${bt}`)}const J=[];if(d){for(const X of _.localNamespaces()){const et=(await I.listRefs({fs:t,gitdir:e,filepath:X})).map(it=>`${X}/${it}`);for(const it of et)x.has(it)||J.push(it)}J.length>0&&await I.deleteRefs({fs:t,gitdir:e,refs:J})}for(const[X,et]of x)await s(X,async()=>t.write(o(e,X),`${et.trim()}
`,"utf8"));return{pruned:J}}static async writeRef({fs:t,gitdir:e,ref:n,value:i}){if(!i.match(/[0-9a-f]{40}/))throw new Xt(i);await s(n,async()=>t.write(o(e,n),`${i.trim()}
`,"utf8"))}static async writeSymbolicRef({fs:t,gitdir:e,ref:n,value:i}){await s(n,async()=>t.write(o(e,n),`ref: ${i.trim()}
`,"utf8"))}static async deleteRef({fs:t,gitdir:e,ref:n}){return I.deleteRefs({fs:t,gitdir:e,refs:[n]})}static async deleteRefs({fs:t,gitdir:e,refs:n}){await Promise.all(n.map(u=>t.rm(o(e,u))));let i=await s("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));const a=Kt.from(i),c=a.refs.size;for(const u of n)a.refs.has(u)&&a.delete(u);a.refs.size<c&&(i=a.toString(),await s("packed-refs",async()=>t.write(`${e}/packed-refs`,i,{encoding:"utf8"})))}static async resolve({fs:t,gitdir:e,ref:n,depth:i=void 0}){if(i!==void 0&&(i--,i===-1))return n;if(n.startsWith("ref: "))return n=n.slice(5),I.resolve({fs:t,gitdir:e,ref:n,depth:i});if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const a=await I.packedRefs({fs:t,gitdir:e}),c=h(n).filter(u=>!lt.includes(u));for(const u of c){const d=await s(u,async()=>await t.read(`${e}/${u}`,{encoding:"utf8"})||a.get(u));if(d)return I.resolve({fs:t,gitdir:e,ref:d.trim(),depth:i})}throw new Dt(n)}static async exists({fs:t,gitdir:e,ref:n}){try{return await I.expand({fs:t,gitdir:e,ref:n}),!0}catch{return!1}}static async expand({fs:t,gitdir:e,ref:n}){if(n.length===40&&/[0-9a-f]{40}/.test(n))return n;const i=await I.packedRefs({fs:t,gitdir:e}),a=h(n);for(const c of a)if(await s(c,async()=>t.exists(`${e}/${c}`))||i.has(c))return c;throw new Dt(n)}static async expandAgainstMap({ref:t,map:e}){const n=h(t);for(const i of n)if(await e.has(i))return i;throw new Dt(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:n=void 0,map:i}){if(n!==void 0&&(n--,n===-1))return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice(5),I.resolveAgainstMap({ref:t,fullref:e,depth:n,map:i});if(t.length===40&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const a=h(t);for(const c of a){const u=i.get(c);if(u)return I.resolveAgainstMap({ref:u.trim(),fullref:c,depth:n,map:i})}throw new Dt(t)}static async packedRefs({fs:t,gitdir:e}){const n=await s("packed-refs",async()=>t.read(`${e}/packed-refs`,{encoding:"utf8"}));return Kt.from(n).refs}static async listRefs({fs:t,gitdir:e,filepath:n}){const i=I.packedRefs({fs:t,gitdir:e});let a=null;try{a=await t.readdirDeep(`${e}/${n}`),a=a.map(c=>c.replace(`${e}/${n}/`,""))}catch{a=[]}for(let c of(await i).keys())c.startsWith(n)&&(c=c.replace(n+"/",""),a.includes(c)||a.push(c));return a.sort(ce),a}static async listBranches({fs:t,gitdir:e,remote:n}){return n?I.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${n}`}):I.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await I.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter(i=>!i.endsWith("^{}"))}}function Y(r,t){return Q(p(r),p(t))}function p(r){return r.mode==="040000"?r.path+"/":r.path}function O(r){switch(r){case"040000":return"tree";case"100644":return"blob";case"100755":return"blob";case"120000":return"blob";case"160000":return"commit"}throw new k(`Unexpected GitTree entry mode: ${r}`)}function z(r){const t=[];let e=0;for(;e<r.length;){const n=r.indexOf(32,e);if(n===-1)throw new k(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next space character.`);const i=r.indexOf(0,e);if(i===-1)throw new k(`GitTree: Error parsing buffer at byte location ${e}: Could not find the next null character.`);let a=r.slice(e,n).toString("utf8");a==="40000"&&(a="040000");const c=O(a),u=r.slice(n+1,i).toString("utf8");if(u.includes("\\")||u.includes("/"))throw new F(u);const d=r.slice(i+1,i+21).toString("hex");e=i+21,t.push({mode:a,path:u,oid:d,type:c})}return t}function Pt(r){if(typeof r=="number"&&(r=r.toString(8)),r.match(/^0?4.*/))return"040000";if(r.match(/^1006.*/))return"100644";if(r.match(/^1007.*/))return"100755";if(r.match(/^120.*/))return"120000";if(r.match(/^160.*/))return"160000";throw new k(`Could not understand file mode: ${r}`)}function At(r){return!r.oid&&r.sha&&(r.oid=r.sha),r.mode=Pt(r.mode),r.type||(r.type=O(r.mode)),r}class xt{constructor(t){if(Buffer.isBuffer(t))this._entries=z(t);else if(Array.isArray(t))this._entries=t.map(At);else throw new k("invalid type passed to GitTree constructor");this._entries.sort(ut)}static from(t){return new xt(t)}render(){return this._entries.map(t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`)}toObject(){const t=[...this._entries];return t.sort(Y),Buffer.concat(t.map(e=>{const n=Buffer.from(e.mode.replace(/^0/,"")),i=Buffer.from(" "),a=Buffer.from(e.path,"utf8"),c=Buffer.from([0]),u=Buffer.from(e.oid,"hex");return Buffer.concat([n,i,a,c,u])}))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class Zt{static wrap({type:t,object:e}){const n=`${t} ${e.length}\0`,i=n.length,a=i+e.length,c=new Uint8Array(a);for(let u=0;u<i;u++)c[u]=n.charCodeAt(u);return c.set(e,i),c}static unwrap(t){const e=t.indexOf(32),n=t.indexOf(0),i=t.slice(0,e).toString("utf8"),a=t.slice(e+1,n).toString("utf8"),c=t.length-(n+1);if(parseInt(a)!==c)throw new k(`Length mismatch: expected ${a} bytes but got ${c} instead.`);return{type:i,object:Buffer.from(t.slice(n+1))}}}async function Fe({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`,i=await r.read(`${t}/${n}`);return i?{object:i,format:"deflated",source:n}:null}function fe(r,t){const e=new M(r),n=Qt(e);if(n!==t.byteLength)throw new k(`applyDelta expected source buffer to be ${n} bytes but the provided buffer was ${t.length} bytes`);const i=Qt(e);let a;const c=ye(e,t);if(c.byteLength===i)a=c;else{a=Buffer.alloc(i);const u=new M(a);for(u.copy(c);!e.eof();)u.copy(ye(e,t));const d=u.tell();if(i!==d)throw new k(`applyDelta expected target buffer to be ${i} bytes but the resulting buffer was ${d} bytes`)}return a}function Qt(r){let t=0,e=0,n=null;do n=r.readUInt8(),t|=(n&127)<<e,e+=7;while(n&128);return t}function we(r,t,e){let n=0,i=0;for(;e--;)t&1&&(n|=r.readUInt8()<<i),t>>=1,i+=8;return n}function ye(r,t){const e=r.readUInt8(),n=128,i=15,a=112;if(e&n){const c=we(r,e&i,4);let u=we(r,(e&a)>>4,3);return u===0&&(u=65536),t.slice(c,c+u)}else return r.slice(e)}function Re(r){let t=[r];return{next(){return Promise.resolve({done:t.length===0,value:t.pop()})},return(){return t=[],{}},[Symbol.asyncIterator](){return this}}}function er(r){return r[Symbol.asyncIterator]?r[Symbol.asyncIterator]():r[Symbol.iterator]?r[Symbol.iterator]():r.next?r:Re(r)}class rr{constructor(t){if(typeof Buffer>"u")throw new Error("Missing Buffer dependency");this.stream=er(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),!(this.cursor===this.buffer.length&&(await this._loadnext(),this._ended))))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0,!e)?Buffer.alloc(0):(e&&(e=Buffer.from(e)),e)}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>me(e);){const n=await this._next();if(this._ended)break;e.push(n)}this.buffer=Buffer.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function me(r){return r.reduce((t,e)=>t+e.length,0)}async function Be(r,t){const e=new rr(r);let n=await e.read(4);if(n=n.toString("utf8"),n!=="PACK")throw new k(`Invalid PACK header '${n}'`);let i=await e.read(4);if(i=i.readUInt32BE(0),i!==2)throw new k(`Invalid packfile version: ${i}`);let a=await e.read(4);if(a=a.readUInt32BE(0),!(a<1))for(;!e.eof()&&a--;){const c=e.tell(),{type:u,length:d,ofs:w,reference:l}=await ve(e),_=new C.Inflate;for(;!_.result;){const x=await e.chunk();if(!x)break;if(_.push(x,!1),_.err)throw new k(`Pako error: ${_.msg}`);if(_.result){if(_.result.length!==d)throw new k("Inflated object size is different from that stated in packfile.");await e.undo(),await e.read(x.length-_.strm.avail_in);const B=e.tell();await t({data:_.result,type:u,num:a,offset:c,end:B,reference:l,ofs:w})}}}}async function ve(r){let t=await r.byte();const e=t>>4&7;let n=t&15;if(t&128){let c=4;do t=await r.byte(),n|=(t&127)<<c,c+=7;while(t&128)}let i,a;if(e===6){let c=0;i=0;const u=[];do t=await r.byte(),i|=(t&127)<<c,c+=7,u.push(t);while(t&128);a=Buffer.from(u)}return e===7&&(a=await r.read(20)),{type:e,length:n,ofs:i,reference:a}}async function De(r){return C.inflate(r)}function Ue(r){const t=[];let e=0,n=0;do{e=r.readUInt8();const i=e&127;t.push(i),n=e&128}while(n);return t.reduce((i,a)=>i+1<<7|a,-1)}function en(r,t){let e=t,n=4,i=null;do i=r.readUInt8(),e|=(i&127)<<n,n+=7;while(i&128);return e}class dr{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const n=new M(t);if(n.slice(4).toString("hex")!=="ff744f63")return;const a=n.readUInt32BE();if(a!==2)throw new k(`Unable to read version ${a} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2048*1024*1024)throw new k("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");n.seek(n.tell()+1020);const c=n.readUInt32BE(),u=[];for(let l=0;l<c;l++){const _=n.slice(20).toString("hex");u[l]=_}n.seek(n.tell()+4*c);const d=new Map;for(let l=0;l<c;l++)d.set(u[l],n.readUInt32BE());const w=n.slice(20).toString("hex");return new dr({hashes:u,crcs:{},offsets:d,packfileSha:w,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:n}){const i={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},a={},c=t.slice(-20).toString("hex"),u=[],d={},w=new Map;let l=null,_=null;await Be([t],async({data:X,type:et,reference:it,offset:bt,num:kt})=>{l===null&&(l=kt);const Bt=Math.floor((l-kt)*100/l);Bt!==_&&n&&await n({phase:"Receiving objects",loaded:l-kt,total:l}),_=Bt,et=i[et],["commit","tree","blob","tag"].includes(et)?a[bt]={type:et,offset:bt}:et==="ofs-delta"?a[bt]={type:et,offset:bt}:et==="ref-delta"&&(a[bt]={type:et,offset:bt})});const x=Object.keys(a).map(Number);for(const[X,et]of x.entries()){const it=X+1===x.length?t.byteLength-20:x[X+1],bt=a[et],kt=R.buf(t.slice(et,it))>>>0;bt.end=it,bt.crc=kt}const B=new dr({pack:Promise.resolve(t),packfileSha:c,crcs:d,hashes:u,offsets:w,getExternalRefDelta:e});_=null;let j=0;const J=[0,0,0,0,0,0,0,0,0,0,0,0];for(let X in a){X=Number(X);const et=Math.floor(j*100/l);et!==_&&n&&await n({phase:"Resolving deltas",loaded:j,total:l}),j++,_=et;const it=a[X];if(!it.oid)try{B.readDepth=0,B.externalReadDepth=0;const{type:bt,object:kt}=await B.readSlice({start:X});J[B.readDepth]+=1;const Bt=await wt(Zt.wrap({type:bt,object:kt}));it.oid=Bt,u.push(Bt),w.set(Bt,X),d[Bt]=it.crc}catch{continue}}return u.sort(),B}async toBuffer(){const t=[],e=(w,l)=>{t.push(Buffer.from(w,l))};e("ff744f63","hex"),e("00000002","hex");const n=new M(Buffer.alloc(256*4));for(let w=0;w<256;w++){let l=0;for(const _ of this.hashes)parseInt(_.slice(0,2),16)<=w&&l++;n.writeUInt32BE(l)}t.push(n.buffer);for(const w of this.hashes)e(w,"hex");const i=new M(Buffer.alloc(this.hashes.length*4));for(const w of this.hashes)i.writeUInt32BE(this.crcs[w]);t.push(i.buffer);const a=new M(Buffer.alloc(this.hashes.length*4));for(const w of this.hashes)a.writeUInt32BE(this.offsets.get(w));t.push(a.buffer),e(this.packfileSha,"hex");const c=Buffer.concat(t),u=await wt(c),d=Buffer.alloc(20);return d.write(u,"hex"),Buffer.concat([c,d])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new k(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;const e={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"};if(!this.pack)throw new k("Tried to read from a GitPackIndex with no packfile loaded into memory");const n=(await this.pack).slice(t),i=new M(n),a=i.readUInt8(),c=a&112;let u=e[c];if(u===void 0)throw new k("Unrecognized type: 0b"+c.toString(2));const d=a&15;let w=d;a&128&&(w=en(i,d));let _=null,x=null;if(u==="ofs_delta"){const j=Ue(i),J=t-j;({object:_,type:u}=await this.readSlice({start:J}))}if(u==="ref_delta"){const j=i.slice(20).toString("hex");({object:_,type:u}=await this.read({oid:j}))}const B=n.slice(i.tell());if(x=Buffer.from(await De(B)),x.byteLength!==w)throw new k(`Packfile told us object would have length ${w} but it had length ${x.byteLength}`);return _&&(x=Buffer.from(fe(x,_))),this.readDepth>3&&(this.offsetCache[t]={type:u,object:x}),{type:u,format:"content",object:x}}}const rn=Symbol("PackfileCache");async function ef({fs:r,filename:t,getExternalRefDelta:e,emitter:n,emitterPrefix:i}){const a=await r.read(t);return dr.fromIdx({idx:a,getExternalRefDelta:e})}function gn({fs:r,cache:t,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:a}){t[rn]||(t[rn]=new Map);let c=t[rn].get(e);return c||(c=ef({fs:r,filename:e,getExternalRefDelta:n,emitter:i,emitterPrefix:a}),t[rn].set(e,c)),c}async function rf({fs:r,cache:t,gitdir:e,oid:n,format:i="content",getExternalRefDelta:a}){let c=await r.readdir(o(e,"objects/pack"));c=c.filter(u=>u.endsWith(".idx"));for(const u of c){const d=`${e}/objects/pack/${u}`,w=await gn({fs:r,cache:t,filename:d,getExternalRefDelta:a});if(w.error)throw new k(w.error);if(w.offsets.has(n)){if(!w.pack){const _=d.replace(/idx$/,"pack");w.pack=r.read(_)}const l=await w.read({oid:n,getExternalRefDelta:a});return l.format="content",l.source=`objects/pack/${u.replace(/idx$/,"pack")}`,l}}return null}async function se({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const a=l=>se({fs:r,cache:t,gitdir:e,oid:l});let c;if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904"&&(c={format:"wrapped",object:Buffer.from("tree 0\0")}),c||(c=await Fe({fs:r,gitdir:e,oid:n})),!c){if(c=await rf({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:a}),!c)throw new Dt(n);return c}if(i==="deflated"||(c.format==="deflated"&&(c.object=Buffer.from(await De(c.object)),c.format="wrapped"),i==="wrapped"))return c;const u=await wt(c.object);if(u!==n)throw new k(`SHA check failed! Expected ${n}, computed ${u}`);const{object:d,type:w}=Zt.unwrap(c.object);if(c.type=w,c.object=d,c.format="content",i==="content")return c;throw new k(`invalid requested format "${i}"`)}class qe extends P{constructor(t,e,n=!0){super(`Failed to create ${t} at ${e} because it already exists.${n?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=qe.code,this.data={noun:t,where:e,canForce:n}}}qe.code="AlreadyExistsError";class kr extends P{constructor(t,e,n){super(`Found multiple ${t} matching "${e}" (${n.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=kr.code,this.data={nouns:t,short:e,matches:n}}}kr.code="AmbiguousError";class Rr extends P{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=Rr.code,this.data={filepaths:t}}}Rr.code="CheckoutConflictError";class Tr extends P{constructor(t,e){super(`Cannot cherry-pick merge commit ${t}. Merge commits have ${e} parents and require specifying which parent to use as the base.`),this.code=this.name=Tr.code,this.data={oid:t,parentCount:e}}}Tr.code="CherryPickMergeCommitError";class Ir extends P{constructor(t){super(`Cannot cherry-pick root commit ${t}. Root commits have no parents.`),this.code=this.name=Ir.code,this.data={oid:t}}}Ir.code="CherryPickRootCommitError";class Br extends P{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Br.code,this.data={ref:t,oid:e}}}Br.code="CommitNotFetchedError";class Or extends P{constructor(){super("Empty response from git server."),this.code=this.name=Or.code,this.data={}}}Or.code="EmptyServerResponseError";class $r extends P{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=$r.code,this.data={}}}$r.code="FastForwardError";class Cr extends P{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=Cr.code,this.data={prettyDetails:t,result:e}}}Cr.code="GitPushError";class pr extends P{constructor(t,e,n){super(`HTTP Error: ${t} ${e}`),this.code=this.name=pr.code,this.data={statusCode:t,statusMessage:e,response:n}}}pr.code="HttpError";class Ve extends P{constructor(t){let e="invalid filepath";t==="leading-slash"||t==="trailing-slash"?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':t==="directory"&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Ve.code,this.data={reason:t}}}Ve.code="InvalidFilepathError";class Le extends P{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=Le.code,this.data={ref:t,suggestion:e}}}Le.code="InvalidRefNameError";class Pr extends P{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=Pr.code,this.data={depth:t}}}Pr.code="MaxDepthError";class wr extends P{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=wr.code,this.data={}}}wr.code="MergeNotSupportedError";class nr extends P{constructor(t,e,n,i){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=nr.code,this.data={filepaths:t,bothModified:e,deleteByUs:n,deleteByTheirs:i}}}nr.code="MergeConflictError";class Ee extends P{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=Ee.code,this.data={role:t}}}Ee.code="MissingNameError";class Oe extends P{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=Oe.code,this.data={parameter:t}}}Oe.code="MissingParameterError";class Fr extends P{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=Fr.code,this.data={errors:t},this.errors=t}}Fr.code="MultipleGitError";class ir extends P{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=ir.code,this.data={expected:t,actual:e}}}ir.code="ParseError";class mr extends P{constructor(t){let e="";t==="not-fast-forward"?e=" because it was not a simple fast-forward":t==="tag-exists"&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=mr.code,this.data={reason:t}}}mr.code="PushRejectedError";class Ye extends P{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Ye.code,this.data={capability:t,parameter:e}}}Ye.code="RemoteCapabilityError";class Dr extends P{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=Dr.code,this.data={preview:t,response:e}}}Dr.code="SmartHttpError";class Ur extends P{constructor(t,e,n){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=Ur.code,this.data={url:t,transport:e,suggestion:n}}}Ur.code="UnknownTransportError";class Nr extends P{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=Nr.code,this.data={url:t}}}Nr.code="UrlParseError";class gr extends P{constructor(){super("The operation was canceled."),this.code=this.name=gr.code,this.data={}}}gr.code="UserCanceledError";class Mr extends P{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`),this.code=this.name=Mr.code,this.data={filepath:t}}}Mr.code="IndexResetError";class jr extends P{constructor(t){super(`"${t}" does not point to any commit. You're maybe working on a repository with no commits yet. `),this.code=this.name=jr.code,this.data={ref:t}}}jr.code="NoCommitError";var oa=Object.freeze({__proto__:null,AlreadyExistsError:qe,AmbiguousError:kr,CheckoutConflictError:Rr,CherryPickMergeCommitError:Tr,CherryPickRootCommitError:Ir,CommitNotFetchedError:Br,EmptyServerResponseError:Or,FastForwardError:$r,GitPushError:Cr,HttpError:pr,InternalError:k,InvalidFilepathError:Ve,InvalidOidError:Xt,InvalidRefNameError:Le,MaxDepthError:Pr,MergeNotSupportedError:wr,MergeConflictError:nr,MissingNameError:Ee,MissingParameterError:Oe,MultipleGitError:Fr,NoRefspecError:Ht,NotFoundError:Dt,ObjectTypeError:Nt,ParseError:ir,PushRejectedError:mr,RemoteCapabilityError:Ye,SmartHttpError:Dr,UnknownTransportError:Ur,UnsafeFilepathError:F,UrlParseError:Nr,UserCanceledError:gr,UnmergedPathsError:$,IndexResetError:Mr,NoCommitError:jr});function yn({name:r,email:t,timestamp:e,timezoneOffset:n}){return n=nf(n),`${r} <${t}> ${e} ${n}`}function nf(r){const t=af(of(r));r=Math.abs(r);const e=Math.floor(r/60);r-=e*60;let n=String(e),i=String(r);return n.length<2&&(n="0"+n),i.length<2&&(i="0"+i),(t===-1?"-":"+")+n+i}function af(r){return Math.sign(r)||(Object.is(r,-0)?-1:1)}function of(r){return r===0?r:-r}function We(r){return r=r.replace(/\r/g,""),r=r.replace(/^\n+/,""),r=r.replace(/\n+$/,"")+`
`,r}function nn(r){const[,t,e,n,i]=r.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:t,email:e,timestamp:Number(n),timezoneOffset:sf(i)}}function sf(r){let[,t,e,n]=r.match(/(\+|-)(\d\d)(\d\d)/);return n=(t==="+"?1:-1)*(Number(e)*60+Number(n)),cf(n)}function cf(r){return r===0?r:-r}class Ie{constructor(t){if(typeof t=="string")this._tag=t;else if(Buffer.isBuffer(t))this._tag=t.toString("utf8");else if(typeof t=="object")this._tag=Ie.render(t);else throw new k("invalid type passed to GitAnnotatedTag constructor")}static from(t){return new Ie(t)}static render(t){return`object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${yn(t.tagger)}

${t.message}
${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf(`

`))}message(){const t=this.withoutSignature();return t.slice(t.indexOf(`

`)+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={};for(const i of e){const a=i.slice(0,i.indexOf(" ")),c=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(c):n[a]=c}return n.tagger&&(n.tagger=nn(n.tagger)),n.committer&&(n.committer=nn(n.committer)),n}withoutSignature(){const t=We(this._tag);return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1?t:t.slice(0,t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`))}gpgsig(){if(this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`)===-1)return;const t=this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+27);return We(t)}payload(){return this.withoutSignature()+`
`}toObject(){return Buffer.from(this._tag,"utf8")}static async sign(t,e,n){const i=t.payload();let{signature:a}=await e({payload:i,secretKey:n});a=We(a);const c=i+a;return Ie.from(c)}}function vn(r){return r.trim().split(`
`).map(t=>" "+t).join(`
`)+`
`}function ff(r){return r.split(`
`).map(t=>t.replace(/^ /,"")).join(`
`)}class ue{constructor(t){if(typeof t=="string")this._commit=t;else if(Buffer.isBuffer(t))this._commit=t.toString("utf8");else if(typeof t=="object")this._commit=ue.render(t);else throw new k("invalid type passed to GitCommit constructor")}static fromPayloadSignature({payload:t,signature:e}){const n=ue.justHeaders(t),i=ue.justMessage(t),a=We(n+`
gpgsig`+vn(e)+`
`+i);return new ue(a)}static from(t){return new ue(t)}toObject(){return Buffer.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return ue.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return We(t.slice(t.indexOf(`

`)+2))}static justHeaders(t){return t.slice(0,t.indexOf(`

`))}parseHeaders(){const t=ue.justHeaders(this._commit).split(`
`),e=[];for(const i of t)i[0]===" "?e[e.length-1]+=`
`+i.slice(1):e.push(i);const n={parent:[]};for(const i of e){const a=i.slice(0,i.indexOf(" ")),c=i.slice(i.indexOf(" ")+1);Array.isArray(n[a])?n[a].push(c):n[a]=c}return n.author&&(n.author=nn(n.author)),n.committer&&(n.committer=nn(n.committer)),n}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}
`:e+=`tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`,t.parent){if(t.parent.length===void 0)throw new k("commit 'parent' property should be an array");for(const a of t.parent)e+=`parent ${a}
`}const n=t.author;e+=`author ${yn(n)}
`;const i=t.committer||t.author;return e+=`committer ${yn(i)}
`,t.gpgsig&&(e+="gpgsig"+vn(t.gpgsig)),e}static render(t){return ue.renderHeaders(t)+`
`+We(t.message)}render(){return this._commit}withoutSignature(){const t=We(this._commit);if(t.indexOf(`
gpgsig`)===-1)return t;const e=t.slice(0,t.indexOf(`
gpgsig`)),n=t.slice(t.indexOf(`-----END PGP SIGNATURE-----
`)+28);return We(e+`
`+n)}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+27);return ff(t)}static async sign(t,e,n){const i=t.withoutSignature(),a=ue.justMessage(t._commit);let{signature:c}=await e({payload:i,secretKey:n});c=We(c);const d=ue.justHeaders(t._commit)+`
gpgsig`+vn(c)+`
`+a;return ue.from(d)}}async function yr({fs:r,cache:t,gitdir:e,oid:n}){if(n==="4b825dc642cb6eb9a060e54bf8d69288fbee4904")return{tree:xt.from([]),oid:n};const{type:i,object:a}=await se({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,yr({fs:r,cache:t,gitdir:e,oid:n});if(i==="commit")return n=ue.from(a).parse().tree,yr({fs:r,cache:t,gitdir:e,oid:n});if(i!=="tree")throw new Nt(n,i,"tree");return{tree:xt.from(a),oid:n}}class uf{constructor({fs:t,gitdir:e,ref:n,cache:i}){this.fs=t,this.cache=i,this.gitdir=e,this.mapPromise=(async()=>{const c=new Map;let u;try{u=await I.resolve({fs:t,gitdir:e,ref:n})}catch(w){w instanceof Dt&&(u="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const d=await yr({fs:t,cache:this.cache,gitdir:e,oid:u});return d.type="tree",d.mode="40000",c.set(".",d),c})();const a=this;this.ConstructEntry=class{constructor(u){this._fullpath=u,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,cache:i,gitdir:a}=this,c=await this.mapPromise,u=c.get(e);if(!u)throw new Error(`No obj for ${e}`);const d=u.oid;if(!d)throw new Error(`No oid for obj ${JSON.stringify(u)}`);if(u.type!=="tree")return null;const{type:w,object:l}=await se({fs:n,cache:i,gitdir:a,oid:d});if(w!==u.type)throw new Nt(d,w,u.type);const _=xt.from(l);for(const x of _)c.set(o(e,x.path),x);return _.entries().map(x=>o(e,x.path))}async type(t){if(t._type===!1){const e=await this.mapPromise,{type:n}=e.get(t._fullpath);t._type=n}return t._type}async mode(t){if(t._mode===!1){const e=await this.mapPromise,{mode:n}=e.get(t._fullpath);t._mode=H(parseInt(n,8))}return t._mode}async stat(t){}async content(t){if(t._content===!1){const e=await this.mapPromise,{fs:n,cache:i,gitdir:a}=this,u=e.get(t._fullpath).oid,{type:d,object:w}=await se({fs:n,cache:i,gitdir:a,oid:u});d!=="blob"?t._content=void 0:t._content=new Uint8Array(w)}return t._content}async oid(t){if(t._oid===!1){const n=(await this.mapPromise).get(t._fullpath);t._oid=n.oid}return t._oid}}function Ce({ref:r="HEAD"}={}){const t=Object.create(null);return Object.defineProperty(t,ne,{value:function({fs:e,gitdir:n,cache:i}){return new uf({fs:e,gitdir:n,ref:r,cache:i})}}),Object.freeze(t),t}class lf{constructor({fs:t,dir:e,gitdir:n,cache:i}){this.fs=t,this.cache=i,this.dir=e,this.gitdir=n,this.config=null;const a=this;this.ConstructEntry=class{constructor(u){this._fullpath=u,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return a.type(this)}async mode(){return a.mode(this)}async stat(){return a.stat(this)}async content(){return a.content(this)}async oid(){return a.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:n,dir:i}=this,a=await n.readdir(o(i,e));return a===null?null:a.map(c=>o(e,c))}async type(t){return t._type===!1&&await t.stat(),t._type}async mode(t){return t._mode===!1&&await t.stat(),t._mode}async stat(t){if(t._stat===!1){const{fs:e,dir:n}=this;let i=await e.lstat(`${n}/${t._fullpath}`);if(!i)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let a=i.isDirectory()?"tree":"blob";a==="blob"&&!i.isFile()&&!i.isSymbolicLink()&&(a="special"),t._type=a,i=L(i),t._mode=i.mode,i.size===-1&&t._actualSize&&(i.size=t._actualSize),t._stat=i}return t._stat}async content(t){if(t._content===!1){const{fs:e,dir:n,gitdir:i}=this;if(await t.type()==="tree")t._content=void 0;else{let a;if(await t.mode()>>12===10)a=await e.readlink(`${n}/${t._fullpath}`);else{const u=await(await this._getGitConfig(e,i)).get("core.autocrlf");a=await e.read(`${n}/${t._fullpath}`,{autocrlf:u})}t._actualSize=a.length,t._stat&&t._stat.size===-1&&(t._stat.size=t._actualSize),t._content=new Uint8Array(a)}}return t._content}async oid(t){if(t._oid===!1){const e=this,{fs:n,gitdir:i,cache:a}=this;let c;await st.acquire({fs:n,gitdir:i,cache:a},async function(u){const d=u.entriesMap.get(t._fullpath),w=await t.stat(),_=await(await e._getGitConfig(n,i)).get("core.filemode"),x=typeof process<"u"?process.platform!=="win32":!0;if(!d||yt(w,d,_,x)){const B=await t.content();B===void 0?c=void 0:(c=await wt(Zt.wrap({type:"blob",object:B})),d&&c===d.oid&&(!_||w.mode===d.mode)&&yt(w,d,_,x)&&u.insert({filepath:t._fullpath,stats:w,oid:c}))}else c=d.oid}),t._oid=c}return t._oid}async _getGitConfig(t,e){return this.config?this.config:(this.config=await Z.get({fs:t,gitdir:e}),this.config)}}function vr(){const r=Object.create(null);return Object.defineProperty(r,ne,{value:function({fs:t,dir:e,gitdir:n,cache:i}){return new lf({fs:t,dir:e,gitdir:n,cache:i})}}),Object.freeze(r),r}function hf(r,t){const e=t-r;return Array.from({length:e},(n,i)=>r+i)}const sa=typeof Array.prototype.flat>"u"?r=>r.reduce((t,e)=>t.concat(e),[]):r=>r.flat();class df{constructor(){this.value=null}consider(t){t!=null&&(this.value===null?this.value=t:t<this.value&&(this.value=t))}reset(){this.value=null}}function*pf(r){const t=new df;let e;const n=[],i=r.length;for(let a=0;a<i;a++)n[a]=r[a].next().value,n[a]!==void 0&&t.consider(n[a]);if(t.value!==null)for(;;){const a=[];e=t.value,t.reset();for(let c=0;c<i;c++)n[c]!==void 0&&n[c]===e?(a[c]=n[c],n[c]=r[c].next().value):a[c]=null,n[c]!==void 0&&t.consider(n[c]);if(yield a,t.value===null)return}}async function Ke({fs:r,cache:t,dir:e,gitdir:n,trees:i,map:a=async(d,w)=>w,reduce:c=async(d,w)=>{const l=sa(w);return d!==void 0&&l.unshift(d),l},iterate:u=(d,w)=>Promise.all([...w].map(d))}){const d=i.map(B=>B[ne]({fs:r,dir:e,gitdir:n,cache:t})),w=new Array(d.length).fill("."),l=hf(0,d.length),_=async B=>{l.forEach(X=>{const et=B[X];B[X]=et&&new d[X].ConstructEntry(et)});const J=(await Promise.all(l.map(X=>{const et=B[X];return et?d[X].readdir(et):[]}))).map(X=>(X===null?[]:X)[Symbol.iterator]());return{entries:B,children:pf(J)}},x=async B=>{const{entries:j,children:J}=await _(B),X=j.find(it=>it&&it._fullpath)._fullpath,et=await a(X,j);if(et!==null){let it=await u(x,J);return it=it.filter(bt=>bt!==void 0),c(et,it)}};return x(w)}async function _n(r,t){const e=await r.readdir(t);e==null?await r.rm(t):e.length?await Promise.all(e.map(n=>{const i=o(t,n);return r.lstat(i).then(a=>{if(a)return a.isDirectory()?_n(r,i):r.rm(i)})})).then(()=>r.rmdir(t)):await r.rmdir(t)}function wf(r){return mf(r)&&ca(r.then)&&ca(r.catch)}function mf(r){return r&&typeof r=="object"}function ca(r){return typeof r=="function"}function fa(r){return wf((e=>{try{return e.readFile().catch(n=>n)}catch(n){return n}})(r))}const ua=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function la(r,t){if(fa(t))for(const e of ua)r[`_${e}`]=t[e].bind(t);else for(const e of ua)r[`_${e}`]=A(t[e].bind(t));fa(t)?(t.cp&&(r._cp=t.cp.bind(t)),t.rm?r._rm=t.rm.bind(t):t.rmdir.length>1?r._rm=t.rmdir.bind(t):r._rm=_n.bind(null,r)):(t.cp&&(r._cp=A(t.cp.bind(t))),t.rm?r._rm=A(t.rm.bind(t)):t.rmdir.length>2?r._rm=A(t.rmdir.bind(t)):r._rm=_n.bind(null,r))}class $t{constructor(t){if(typeof t._original_unwrapped_fs<"u")return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?la(this,t.promises):la(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(n){if(n.code==="ENOENT"||n.code==="ENOTDIR"||(n.code||"").includes("ENS"))return!1;throw n}}async read(t,e={}){try{let n=await this._readFile(t,e);if(e.autocrlf==="true")try{n=new TextDecoder("utf8",{fatal:!0}).decode(n),n=n.replace(/\r\n/g,`
`),n=new TextEncoder().encode(n)}catch{}return typeof n!="string"&&(n=Buffer.from(n)),n}catch{return null}}async write(t,e,n={}){try{await this._writeFile(t,e,n)}catch{await this.mkdir(It(t)),await this._writeFile(t,e,n)}}async mkdir(t,e=!1){try{await this._mkdir(t)}catch(n){if(n===null||n.code==="EEXIST")return;if(e)throw n;if(n.code==="ENOENT"){const i=It(t);if(i==="."||i==="/"||i===t)throw n;await this.mkdir(i),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if(e.code!=="ENOENT")throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(n){if(n.code!=="ENOENT")throw n}}async readdir(t){try{const e=await this._readdir(t);return e.sort(Q),e}catch(e){return e.code==="ENOTDIR"?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map(async i=>{const a=t+"/"+i;return(await this._stat(a)).isDirectory()?this.readdirDeep(a):a}))).reduce((i,a)=>i.concat(a),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if(e.code==="ENOENT"||(e.code||"").includes("ENS"))return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const n=await this._readlink(t,e);return Buffer.isBuffer(n)?n:Buffer.from(n)}catch(n){if(n.code==="ENOENT"||(n.code||"").includes("ENS"))return null;throw n}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function U(r,t){if(t===void 0)throw new Oe(r)}async function Ct({fsp:r,dotgit:t}){U("fsp",r),U("dotgit",t);const e=await r._stat(t).catch(()=>({isFile:()=>!1,isDirectory:()=>!1}));return e.isDirectory()?t:e.isFile()?r._readFile(t,"utf8").then(n=>n.trimRight().substr(8)).then(n=>o(It(t),n)):t}async function an(r,t){return!r&&!t?!1:r&&!t||!r&&t?!0:!(await r.type()==="tree"&&await t.type()==="tree"||await r.type()===await t.type()&&await r.mode()===await t.mode()&&await r.oid()===await t.oid())}async function ha({fs:r,dir:t,gitdir:e=o(t,".git"),commit:n="HEAD",cache:i={}}){try{U("fs",r),U("dir",t),U("gitdir",e);const a=new $t(r),c=[Ce({ref:n}),vr(),Wt()];let u=[];const d=await Ct({fsp:a,dotgit:e});await st.acquire({fs:a,gitdir:d,cache:i},async function(l){u=l.unmergedPaths});const w=await Ke({fs:a,cache:i,dir:t,gitdir:d,trees:c,map:async function(l,[_,x,B]){const j=!await an(x,B),J=u.includes(l),X=!await an(B,_);if(j||J)return _?{path:l,mode:await _.mode(),oid:await _.oid(),type:await _.type(),content:await _.content()}:void 0;if(X)return!1;throw new Mr(l)}});await st.acquire({fs:a,gitdir:d,cache:i},async function(l){for(const _ of w)if(_!==!1){if(!_){await a.rmdir(`${t}/${_.path}`,{recursive:!0}),l.delete({filepath:_.path});continue}if(_.type==="blob"){const x=new TextDecoder().decode(_.content);await a.write(`${t}/${_.path}`,x,{mode:_.mode}),l.insert({filepath:_.path,oid:_.oid,stage:0})}}})}catch(a){throw a.caller="git.abortMerge",a}}class _r{static async isIgnored({fs:t,dir:e,gitdir:n=o(e,".git"),filepath:i}){if(Mt(i)===".git")return!0;if(i===".")return!1;let a="";const c=o(n,"info","exclude");await t.exists(c)&&(a=await t.read(c,"utf8"));const u=[{gitignore:o(e,".gitignore"),filepath:i}],d=i.split("/").filter(Boolean);for(let l=1;l<d.length;l++){const _=d.slice(0,l).join("/"),x=d.slice(l).join("/");u.push({gitignore:o(e,_,".gitignore"),filepath:x})}let w=!1;for(const l of u){let _;try{_=await t.read(l.gitignore,"utf8")}catch(j){if(j.code==="NOENT")continue}const x=T().add(a);x.add(_);const B=It(l.filepath);if(B!=="."&&x.ignores(B))return!0;w?w=!x.test(l.filepath).unignored:w=x.test(l.filepath).ignored}return w}}async function gf({fs:r,gitdir:t,object:e,format:n,oid:i}){const a=`objects/${i.slice(0,2)}/${i.slice(2)}`,c=`${t}/${a}`;await r.exists(c)||await r.write(c,e)}let bn=null;async function da(r){return bn===null&&(bn=vf()),bn?yf(r):C.deflate(r)}async function yf(r){const t=new CompressionStream("deflate"),e=new Blob([r]).stream().pipeThrough(t);return new Uint8Array(await new Response(e).arrayBuffer())}function vf(){try{return new CompressionStream("deflate").writable.close(),new Blob([]).stream().cancel(),!0}catch{return!1}}async function $e({fs:r,gitdir:t,type:e,object:n,format:i="content",oid:a=void 0,dryRun:c=!1}){return i!=="deflated"&&(i!=="wrapped"&&(n=Zt.wrap({type:e,object:n})),a=await wt(n),n=Buffer.from(await da(n))),c||await gf({fs:r,gitdir:t,object:n,format:"deflated",oid:a}),a}function pa(r){let t;for(;~(t=r.indexOf(92));)r[t]=47;return r}async function wa({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n,cache:i={},force:a=!1,parallel:c=!0}){try{U("fs",r),U("dir",t),U("gitdir",e),U("filepath",n);const u=new $t(r),d=await Ct({fsp:u,dotgit:e});await st.acquire({fs:u,gitdir:d,cache:i},async w=>{const _=await(await Z.get({fs:u,gitdir:d})).get("core.autocrlf");return xn({dir:t,gitdir:d,fs:u,filepath:n,index:w,force:a,parallel:c,autocrlf:_})})}catch(u){throw u.caller="git.add",u}}async function xn({dir:r,gitdir:t,fs:e,filepath:n,index:i,force:a,parallel:c,autocrlf:u}){n=Array.isArray(n)?n:[n];const d=n.map(async x=>{if(!a&&await _r.isIgnored({fs:e,dir:r,gitdir:t,filepath:x}))return;const B=await e.lstat(o(r,x));if(!B)throw new Dt(x);if(B.isDirectory()){const j=await e.readdir(o(r,x));if(c){const J=j.map(X=>xn({dir:r,gitdir:t,fs:e,filepath:[o(x,X)],index:i,force:a,parallel:c,autocrlf:u}));await Promise.all(J)}else for(const J of j)await xn({dir:r,gitdir:t,fs:e,filepath:[o(x,J)],index:i,force:a,parallel:c,autocrlf:u})}else{const j=B.isSymbolicLink()?await e.readlink(o(r,x)).then(pa):await e.read(o(r,x),{autocrlf:u});if(j===null)throw new Dt(x);const J=await $e({fs:e,gitdir:t,type:"blob",object:j});i.insert({filepath:x,stats:B,oid:J})}}),w=await Promise.allSettled(d),l=w.filter(x=>x.status==="rejected").map(x=>x.reason);if(l.length>1)throw new Fr(l);if(l.length===1)throw l[0];return w.filter(x=>x.status==="fulfilled"&&x.value).map(x=>x.value)}async function qr({fs:r,gitdir:t,path:e}){return(await Z.get({fs:r,gitdir:t})).get(e)}function ma(r,...t){for(const e of t)if(e)for(const n of Object.keys(e)){const i=e[n];i!==void 0&&(r[n]=i)}return r}async function Je({fs:r,gitdir:t,author:e,commit:n}){const i=Math.floor(Date.now()/1e3),a={name:await qr({fs:r,gitdir:t,path:"user.name"}),email:await qr({fs:r,gitdir:t,path:"user.email"})||"",timestamp:i,timezoneOffset:new Date(i*1e3).getTimezoneOffset()},c=ma({},a,n?n.author:void 0,e);if(c.name!==void 0)return c}async function ar({fs:r,gitdir:t,author:e,committer:n,commit:i}){const a=Math.floor(Date.now()/1e3),c={name:await qr({fs:r,gitdir:t,path:"user.name"}),email:await qr({fs:r,gitdir:t,path:"user.email"})||"",timestamp:a,timezoneOffset:new Date(a*1e3).getTimezoneOffset()},u=ma({},c,i?i.committer:void 0,e,n);if(u.name!==void 0)return u}async function ga({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await se({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,ga({fs:r,cache:t,gitdir:e,oid:n});if(i!=="commit")throw new Nt(n,i,"commit");return{commit:ue.from(a),oid:n}}async function He({fs:r,cache:t,gitdir:e,oid:n}){const{commit:i,oid:a}=await ga({fs:r,cache:t,gitdir:e,oid:n});return{oid:a,commit:i.parse(),payload:i.withoutSignature()}}async function Lr({fs:r,cache:t,onSign:e,gitdir:n,message:i,author:a,committer:c,signingKey:u,amend:d=!1,dryRun:w=!1,noUpdateBranch:l=!1,ref:_,parent:x,tree:B}){let j=!1,J=!1;_||(J=!(await r.read(`${n}/HEAD`,{encoding:"utf8"})).startsWith("ref:"),_=await I.resolve({fs:r,gitdir:n,ref:"HEAD",depth:2}));let X,et;try{X=await I.resolve({fs:r,gitdir:n,ref:_}),et=await He({fs:r,gitdir:n,oid:X,cache:{}})}catch{j=!0}if(d&&j)throw new jr(_);const it=d?await Je({fs:r,gitdir:n,author:a,commit:et.commit}):await Je({fs:r,gitdir:n,author:a});if(!it)throw new Ee("author");const bt=d?await ar({fs:r,gitdir:n,author:it,committer:c,commit:et.commit}):await ar({fs:r,gitdir:n,author:it,committer:c});if(!bt)throw new Ee("committer");return st.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async function(kt){const Ot=jt(kt.entries).get(".");if(B||(B=await ya({fs:r,gitdir:n,inode:Ot,dryRun:w})),x?x=await Promise.all(x.map(Et=>I.resolve({fs:r,gitdir:n,ref:Et}))):d?x=et.commit.parent:x=X?[X]:[],!i)if(d)i=et.commit.message;else throw new Oe("message");let mt=ue.from({tree:B,parent:x,author:it,committer:bt,message:i});u&&(mt=await ue.sign(mt,e,u));const vt=await $e({fs:r,gitdir:n,type:"commit",object:mt.toObject(),dryRun:w});return!l&&!w&&await I.writeRef({fs:r,gitdir:n,ref:J?"HEAD":_,value:vt}),vt})}async function ya({fs:r,gitdir:t,inode:e,dryRun:n}){const i=e.children;for(const d of i)d.type==="tree"&&(d.metadata.mode="040000",d.metadata.oid=await ya({fs:r,gitdir:t,inode:d,dryRun:n}));const a=i.map(d=>({mode:d.metadata.mode,path:d.basename,oid:d.metadata.oid,type:d.type})),c=xt.from(a);return await $e({fs:r,gitdir:t,type:"tree",object:c.toObject(),dryRun:n})}async function zr({fs:r,cache:t,gitdir:e,oid:n,filepath:i}){if(i.startsWith("/"))throw new Ve("leading-slash");if(i.endsWith("/"))throw new Ve("trailing-slash");const a=n,c=await yr({fs:r,cache:t,gitdir:e,oid:n}),u=c.tree;if(i==="")n=c.oid;else{const d=i.split("/");n=await va({fs:r,cache:t,gitdir:e,tree:u,pathArray:d,oid:a,filepath:i})}return n}async function va({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:a,filepath:c}){const u=i.shift();for(const d of n)if(d.path===u){if(i.length===0)return d.oid;{const{type:w,object:l}=await se({fs:r,cache:t,gitdir:e,oid:d.oid});if(w!=="tree")throw new Nt(a,w,"tree",c);return n=xt.from(l),va({fs:r,cache:t,gitdir:e,tree:n,pathArray:i,oid:a,filepath:c})}}throw new Dt(`file or directory found at "${a}:${c}"`)}async function br({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){i!==void 0&&(n=await zr({fs:r,cache:t,gitdir:e,oid:n,filepath:i}));const{tree:a,oid:c}=await yr({fs:r,cache:t,gitdir:e,oid:n});return{oid:c,tree:a.entries()}}async function Hr({fs:r,gitdir:t,tree:e}){const n=xt.from(e).toObject();return await $e({fs:r,gitdir:t,type:"tree",object:n,format:"content"})}async function _f({fs:r,cache:t,onSign:e,gitdir:n,ref:i,oid:a,note:c,force:u,author:d,committer:w,signingKey:l}){let _;try{_=await I.resolve({gitdir:n,fs:r,ref:i})}catch(et){if(!(et instanceof Dt))throw et}let B=(await br({fs:r,cache:t,gitdir:n,oid:_||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;if(u)B=B.filter(et=>et.path!==a);else for(const et of B)if(et.path===a)throw new qe("note",a);typeof c=="string"&&(c=Buffer.from(c,"utf8"));const j=await $e({fs:r,gitdir:n,type:"blob",object:c,format:"content"});B.push({mode:"100644",path:a,oid:j,type:"blob"});const J=await Hr({fs:r,gitdir:n,tree:B});return await Lr({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:J,parent:_&&[_],message:`Note added by 'isomorphic-git addNote'
`,author:d,committer:w,signingKey:l})}async function _a({fs:r,onSign:t,dir:e,gitdir:n=o(e,".git"),ref:i="refs/notes/commits",oid:a,note:c,force:u,author:d,committer:w,signingKey:l,cache:_={}}){try{U("fs",r),U("gitdir",n),U("oid",a),U("note",c),l&&U("onSign",t);const x=new $t(r),B=await Je({fs:x,gitdir:n,author:d});if(!B)throw new Ee("author");const j=await ar({fs:x,gitdir:n,author:B,committer:w});if(!j)throw new Ee("committer");const J=await Ct({fsp:x,dotgit:n});return await _f({fs:x,cache:_,onSign:t,gitdir:J,ref:i,oid:a,note:c,force:u,author:B,committer:j,signingKey:l})}catch(x){throw x.caller="git.addNote",x}}const bf=/(^|[/.])([/.]|$)|^@$|@{|[\x00-\x20\x7f~^:?*[\\]|\.lock(\/|$)/;function Gr(r,t){if(typeof r!="string")throw new TypeError("Reference name must be a string");return!bf.test(r)&&!0}async function ba({fs:r,gitdir:t,remote:e,url:n,force:i}){if(!Gr(e))throw new Le(e,m.clean(e));const a=await Z.get({fs:r,gitdir:t});if(!i&&(await a.getSubsections("remote")).includes(e)&&n!==await a.get(`remote.${e}.url`))throw new qe("remote",e);await a.set(`remote.${e}.url`,n),await a.set(`remote.${e}.fetch`,`+refs/heads/*:refs/remotes/${e}/*`),await Z.save({fs:r,gitdir:t,config:a})}async function xa({fs:r,dir:t,gitdir:e=o(t,".git"),remote:n,url:i,force:a=!1}){try{U("fs",r),U("gitdir",e),U("remote",n),U("url",i);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await ba({fs:c,gitdir:u,remote:n,url:i,force:a})}catch(c){throw c.caller="git.addRemote",c}}async function xf({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tagger:a,message:c=i,gpgsig:u,object:d,signingKey:w,force:l=!1}){if(i=i.startsWith("refs/tags/")?i:`refs/tags/${i}`,!l&&await I.exists({fs:r,gitdir:n,ref:i}))throw new qe("tag",i);const _=await I.resolve({fs:r,gitdir:n,ref:d||"HEAD"}),{type:x}=await se({fs:r,cache:t,gitdir:n,oid:_});let B=Ie.from({object:_,type:x,tag:i.replace("refs/tags/",""),tagger:a,message:c,gpgsig:u});w&&(B=await Ie.sign(B,e,w));const j=await $e({fs:r,gitdir:n,type:"tag",object:B.toObject()});await I.writeRef({fs:r,gitdir:n,ref:i,value:j})}async function Ea({fs:r,onSign:t,dir:e,gitdir:n=o(e,".git"),ref:i,tagger:a,message:c=i,gpgsig:u,object:d,signingKey:w,force:l=!1,cache:_={}}){try{U("fs",r),U("gitdir",n),U("ref",i),w&&U("onSign",t);const x=new $t(r),B=await Ct({fsp:x,dotgit:n}),j=await Je({fs:x,gitdir:B,author:a});if(!j)throw new Ee("tagger");return await xf({fs:x,cache:_,onSign:t,gitdir:B,ref:i,tagger:j,message:c,gpgsig:u,object:d,signingKey:w,force:l})}catch(x){throw x.caller="git.annotatedTag",x}}async function Ef({fs:r,gitdir:t,ref:e,object:n,checkout:i=!1,force:a=!1}){if(!Gr(e))throw new Le(e,m.clean(e));const c=`refs/heads/${e}`;if(!a&&await I.exists({fs:r,gitdir:t,ref:c}))throw new qe("branch",e,!1);let u;try{u=await I.resolve({fs:r,gitdir:t,ref:n||"HEAD"})}catch{}u&&await I.writeRef({fs:r,gitdir:t,ref:c,value:u}),i&&await I.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:c})}async function Sa({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,object:i,checkout:a=!1,force:c=!1}){try{U("fs",r),U("gitdir",e),U("ref",n);const u=new $t(r),d=await Ct({fsp:u,dotgit:e});return await Ef({fs:u,gitdir:d,ref:n,object:i,checkout:a,force:c})}catch(u){throw u.caller="git.branch",u}}const Aa=(r,t)=>r==="."||t==null||t.length===0||t==="."?!0:t.length>=r.length?t.startsWith(r):r.startsWith(t);async function En({fs:r,cache:t,onProgress:e,onPostCheckout:n,dir:i,gitdir:a,remote:c,ref:u,filepaths:d,noCheckout:w,noUpdateHead:l,dryRun:_,force:x,track:B=!0,nonBlocking:j=!1,batchSize:J=100}){let X;if(n)try{X=await I.resolve({fs:r,gitdir:a,ref:"HEAD"})}catch{X="0000000000000000000000000000000000000000"}let et;try{et=await I.resolve({fs:r,gitdir:a,ref:u})}catch(it){if(u==="HEAD")throw it;const bt=`${c}/${u}`;if(et=await I.resolve({fs:r,gitdir:a,ref:bt}),B){const kt=await Z.get({fs:r,gitdir:a});await kt.set(`branch.${u}.remote`,c),await kt.set(`branch.${u}.merge`,`refs/heads/${u}`),await Z.save({fs:r,gitdir:a,config:kt})}await I.writeRef({fs:r,gitdir:a,ref:`refs/heads/${u}`,value:et})}if(!w){let it;try{it=await Sf({fs:r,cache:t,onProgress:e,dir:i,gitdir:a,ref:u,force:x,filepaths:d})}catch(mt){throw mt instanceof Dt&&mt.data.what===et?new Br(u,et):mt}const bt=it.filter(([mt])=>mt==="conflict").map(([mt,vt])=>vt);if(bt.length>0)throw new Rr(bt);const kt=it.filter(([mt])=>mt==="error").map(([mt,vt])=>vt);if(kt.length>0)throw new k(kt.join(", "));if(_){n&&await n({previousHead:X,newHead:et,type:d!=null&&d.length>0?"file":"branch"});return}let Bt=0;const Ot=it.length;if(await st.acquire({fs:r,gitdir:a,cache:t},async function(mt){await Promise.all(it.filter(([vt])=>vt==="delete"||vt==="delete-index").map(async function([vt,Et]){const zt=`${i}/${Et}`;vt==="delete"&&await r.rm(zt),mt.delete({filepath:Et}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:Ot})}))}),await st.acquire({fs:r,gitdir:a,cache:t},async function(mt){for(const[vt,Et]of it)if(vt==="rmdir"||vt==="rmdir-index"){const zt=`${i}/${Et}`;try{vt==="rmdir"&&await r.rmdir(zt),mt.delete({filepath:Et}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:Ot})}catch(ee){if(ee.code!=="ENOTEMPTY")throw ee}}}),await Promise.all(it.filter(([mt])=>mt==="mkdir"||mt==="mkdir-index").map(async function([mt,vt]){const Et=`${i}/${vt}`;await r.mkdir(Et),e&&await e({phase:"Updating workdir",loaded:++Bt,total:Ot})})),j){const mt=it.filter(([Et])=>Et==="create"||Et==="create-index"||Et==="update"||Et==="mkdir-index"),vt=await ka("Update Working Dir",mt.map(([Et,zt,ee,_e,re])=>()=>kf({fs:r,cache:t,gitdir:a,dir:i},[Et,zt,ee,_e,re])),e,J);await st.acquire({fs:r,gitdir:a,cache:t,allowUnmerged:!0},async function(Et){await ka("Update Index",vt.map(([zt,ee,_e])=>()=>Af({index:Et,fullpath:zt,oid:ee,stats:_e})),e,J)})}else await st.acquire({fs:r,gitdir:a,cache:t,allowUnmerged:!0},async function(mt){await Promise.all(it.filter(([vt])=>vt==="create"||vt==="create-index"||vt==="update"||vt==="mkdir-index").map(async function([vt,Et,zt,ee,_e]){const re=`${i}/${Et}`;try{if(vt!=="create-index"&&vt!=="mkdir-index"){const{object:Se}=await se({fs:r,cache:t,gitdir:a,oid:zt});if(_e&&await r.rm(re),ee===33188)await r.write(re,Se);else if(ee===33261)await r.write(re,Se,{mode:511});else if(ee===40960)await r.writelink(re,Se);else throw new k(`Invalid mode 0o${ee.toString(8)} detected in blob ${zt}`)}const xe=await r.lstat(re);ee===33261&&(xe.mode=493),vt==="mkdir-index"&&(xe.mode=57344),mt.insert({filepath:Et,stats:xe,oid:zt}),e&&await e({phase:"Updating workdir",loaded:++Bt,total:Ot})}catch{}}))});n&&await n({previousHead:X,newHead:et,type:d!=null&&d.length>0?"file":"branch"})}if(!l){const it=await I.expand({fs:r,gitdir:a,ref:u});it.startsWith("refs/heads")?await I.writeSymbolicRef({fs:r,gitdir:a,ref:"HEAD",value:it}):await I.writeRef({fs:r,gitdir:a,ref:"HEAD",value:et})}}async function Sf({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,ref:a,force:c,filepaths:u}){let d=0;return Ke({fs:r,cache:t,dir:n,gitdir:i,trees:[Ce({ref:a}),vr(),Wt()],map:async function(w,[l,_,x]){if(w===".")return;if(u&&!u.some(j=>Aa(w,j)))return null;switch(e&&await e({phase:"Analyzing workdir",loaded:++d}),[!!x,!!l,!!_].map(Number).join("")){case"000":return;case"001":return c&&u&&u.includes(w)?["delete",w]:void 0;case"010":switch(await l.type()){case"tree":return["mkdir",w];case"blob":return["create",w,await l.oid(),await l.mode()];case"commit":return["mkdir-index",w,await l.oid(),await l.mode()];default:return["error",`new entry Unhandled type ${await l.type()}`]}case"011":switch(`${await l.type()}-${await _.type()}`){case"tree-tree":return;case"tree-blob":case"blob-tree":return["conflict",w];case"blob-blob":return await l.oid()!==await _.oid()?c?["update",w,await l.oid(),await l.mode(),await l.mode()!==await _.mode()]:["conflict",w]:await l.mode()!==await _.mode()?c?["update",w,await l.oid(),await l.mode(),!0]:["conflict",w]:["create-index",w,await l.oid(),await l.mode()];case"commit-tree":return;case"commit-blob":return["conflict",w];default:return["error",`new entry Unhandled type ${l.type}`]}case"100":return["delete-index",w];case"101":switch(await x.type()){case"tree":return["rmdir-index",w];case"blob":return await x.oid()!==await _.oid()?c?["delete",w]:["conflict",w]:["delete",w];case"commit":return["rmdir-index",w];default:return["error",`delete entry Unhandled type ${await x.type()}`]}case"110":case"111":switch(`${await x.type()}-${await l.type()}`){case"tree-tree":return;case"blob-blob":{if(await x.oid()===await l.oid()&&await x.mode()===await l.mode()&&!c)return;if(_){if(await _.oid()!==await x.oid()&&await _.oid()!==await l.oid())return c?["update",w,await l.oid(),await l.mode(),await l.mode()!==await _.mode()]:["conflict",w]}else if(c)return["update",w,await l.oid(),await l.mode(),await l.mode()!==await x.mode()];return await l.mode()!==await x.mode()?["update",w,await l.oid(),await l.mode(),!0]:await l.oid()!==await x.oid()?["update",w,await l.oid(),await l.mode(),!1]:void 0}case"tree-blob":return["update-dir-to-blob",w,await l.oid()];case"blob-tree":return["update-blob-to-tree",w];case"commit-commit":return["mkdir-index",w,await l.oid(),await l.mode()];default:return["error",`update entry Unhandled type ${await x.type()}-${await l.type()}`]}}},reduce:async function(w,l){return l=sa(l),w?w&&w[0]==="rmdir"?(l.push(w),l):(l.unshift(w),l):l}})}async function Af({index:r,fullpath:t,stats:e,oid:n}){try{r.insert({filepath:t,stats:e,oid:n})}catch{}}async function kf({fs:r,cache:t,gitdir:e,dir:n},[i,a,c,u,d]){const w=`${n}/${a}`;if(i!=="create-index"&&i!=="mkdir-index"){const{object:_}=await se({fs:r,cache:t,gitdir:e,oid:c});if(d&&await r.rm(w),u===33188)await r.write(w,_);else if(u===33261)await r.write(w,_,{mode:511});else if(u===40960)await r.writelink(w,_);else throw new k(`Invalid mode 0o${u.toString(8)} detected in blob ${c}`)}const l=await r.lstat(w);return u===33261&&(l.mode=493),i==="mkdir-index"&&(l.mode=57344),[a,c,l]}async function ka(r,t,e,n){const i=[];try{for(let a=0;a<t.length;a+=n){const c=t.slice(a,a+n).map(d=>d());(await Promise.allSettled(c)).forEach(d=>{d.status==="fulfilled"&&i.push(d.value)}),e&&await e({phase:"Updating workdir",loaded:a+c.length,total:t.length})}return i}catch{}return i}async function Sn({fs:r,onProgress:t,onPostCheckout:e,dir:n,gitdir:i=o(n,".git"),remote:a="origin",ref:c,filepaths:u,noCheckout:d=!1,noUpdateHead:w=c===void 0,dryRun:l=!1,force:_=!1,track:x=!0,cache:B={},nonBlocking:j=!1,batchSize:J=100}){try{U("fs",r),U("dir",n),U("gitdir",i);const X=c||"HEAD",et=new $t(r),it=await Ct({fsp:et,dotgit:i});return await En({fs:et,cache:B,onProgress:t,onPostCheckout:e,dir:n,gitdir:it,remote:a,ref:X,filepaths:u,noCheckout:d,noUpdateHead:w,dryRun:l,force:_,track:x,nonBlocking:j,batchSize:J})}catch(X){throw X.caller="git.checkout",X}}const An=/^.*(\r?\n|$)/gm;function Rf({branches:r,contents:t}){const e=r[1],n=r[2],i=t[0],a=t[1],c=t[2],u=a.match(An),d=i.match(An),w=c.match(An),l=g(u,d,w),_=7;let x="",B=!0;for(const j of l)j.ok&&(x+=j.ok.join("")),j.conflict&&(B=!1,x+=`${"<".repeat(_)} ${e}
`,x+=j.conflict.a.join(""),x+=`${"=".repeat(_)}
`,x+=j.conflict.b.join(""),x+=`${">".repeat(_)} ${n}
`);return{cleanMerge:B,mergedText:x}}async function Ra({fs:r,cache:t,dir:e,gitdir:n=o(e,".git"),index:i,ourOid:a,baseOid:c,theirOid:u,ourName:d="ours",baseName:w="base",theirName:l="theirs",dryRun:_=!1,abortOnConflict:x=!0,mergeDriver:B}){const j=Ce({ref:a}),J=Ce({ref:c}),X=Ce({ref:u}),et=[],it=[],bt=[],kt=[],Bt=await Ke({fs:r,cache:t,dir:e,gitdir:n,trees:[j,J,X],map:async function(Ot,[mt,vt,Et]){const zt=Mt(Ot),ee=await an(mt,vt),_e=await an(Et,vt);switch(`${ee}-${_e}`){case"false-false":return{mode:await vt.mode(),path:zt,oid:await vt.oid(),type:await vt.type()};case"false-true":return!Et&&await mt.type()==="tree"?{mode:await mt.mode(),path:zt,oid:await mt.oid(),type:await mt.type()}:Et?{mode:await Et.mode(),path:zt,oid:await Et.oid(),type:await Et.type()}:void 0;case"true-false":return!mt&&await Et.type()==="tree"?{mode:await Et.mode(),path:zt,oid:await Et.oid(),type:await Et.type()}:mt?{mode:await mt.mode(),path:zt,oid:await mt.oid(),type:await mt.type()}:void 0;case"true-true":{if(mt&&Et&&await mt.type()==="tree"&&await Et.type()==="tree")return{mode:await mt.mode(),path:zt,oid:await mt.oid(),type:"tree"};if(mt&&Et&&await mt.type()==="blob"&&await Et.type()==="blob")return Tf({fs:r,gitdir:n,path:zt,ours:mt,base:vt,theirs:Et,ourName:d,baseName:w,theirName:l,mergeDriver:B}).then(async re=>{if(re.cleanMerge)x||i.insert({filepath:Ot,oid:re.mergeResult.oid,stage:0});else if(et.push(Ot),it.push(Ot),!x){let xe="";vt&&await vt.type()==="blob"&&(xe=await vt.oid());const Se=await mt.oid(),cr=await Et.oid();i.delete({filepath:Ot}),xe&&i.insert({filepath:Ot,oid:xe,stage:1}),i.insert({filepath:Ot,oid:Se,stage:2}),i.insert({filepath:Ot,oid:cr,stage:3})}return re.mergeResult});if(vt&&!mt&&Et&&await vt.type()==="blob"&&await Et.type()==="blob"){if(et.push(Ot),bt.push(Ot),!x){const re=await vt.oid(),xe=await Et.oid();i.delete({filepath:Ot}),i.insert({filepath:Ot,oid:re,stage:1}),i.insert({filepath:Ot,oid:xe,stage:3})}return{mode:await Et.mode(),oid:await Et.oid(),type:"blob",path:zt}}if(vt&&mt&&!Et&&await vt.type()==="blob"&&await mt.type()==="blob"){if(et.push(Ot),kt.push(Ot),!x){const re=await vt.oid(),xe=await mt.oid();i.delete({filepath:Ot}),i.insert({filepath:Ot,oid:re,stage:1}),i.insert({filepath:Ot,oid:xe,stage:2})}return{mode:await mt.mode(),oid:await mt.oid(),type:"blob",path:zt}}if(vt&&!mt&&!Et&&(await vt.type()==="blob"||await vt.type()==="tree"))return;throw new wr}}},reduce:et.length!==0&&(!e||x)?void 0:async(Ot,mt)=>{const vt=mt.filter(Boolean);if(Ot&&!(Ot&&Ot.type==="tree"&&vt.length===0&&Ot.path!==".")){if(vt.length>0||Ot.path==="."&&vt.length===0){const zt=new xt(vt).toObject(),ee=await $e({fs:r,gitdir:n,type:"tree",object:zt,dryRun:_});Ot.oid=ee}return Ot}}});return et.length!==0?(e&&!x&&await Ke({fs:r,cache:t,dir:e,gitdir:n,trees:[Ce({ref:Bt.oid})],map:async function(Ot,[mt]){const vt=`${e}/${Ot}`;if(await mt.type()==="blob"){const Et=await mt.mode(),zt=new TextDecoder().decode(await mt.content());await r.write(vt,zt,{mode:Et})}return!0}}),new nr(et,it,bt,kt)):Bt.oid}async function Tf({fs:r,gitdir:t,path:e,ours:n,base:i,theirs:a,ourName:c,theirName:u,baseName:d,dryRun:w,mergeDriver:l=Rf}){const _="blob";let x="100755",B="",j="";i&&await i.type()==="blob"&&(x=await i.mode(),B=await i.oid(),j=Buffer.from(await i.content()).toString("utf8"));const J=x===await n.mode()?await a.mode():await n.mode();if(await n.oid()===await a.oid())return{cleanMerge:!0,mergeResult:{mode:J,path:e,oid:await n.oid(),type:_}};if(await n.oid()===B)return{cleanMerge:!0,mergeResult:{mode:J,path:e,oid:await a.oid(),type:_}};if(await a.oid()===B)return{cleanMerge:!0,mergeResult:{mode:J,path:e,oid:await n.oid(),type:_}};const X=Buffer.from(await n.content()).toString("utf8"),et=Buffer.from(await a.content()).toString("utf8"),{mergedText:it,cleanMerge:bt}=await l({branches:[d,c,u],contents:[j,X,et],path:e}),kt=await $e({fs:r,gitdir:t,type:"blob",object:Buffer.from(it,"utf8"),dryRun:w});return{cleanMerge:bt,mergeResult:{mode:J,path:e,oid:kt,type:_}}}const If={stage:Wt,workdir:vr};let kn;async function xr(r,t){return kn===void 0&&(kn=new E),kn.acquire(r,t)}async function Bf(r,t,e,n,i=null){const a=o(e,n),c=await r.lstat(a);if(!c)throw new Dt(a);if(c.isDirectory())throw new k(`${a}: file expected, but found directory`);const u=i?await Fe({fs:r,gitdir:t,oid:i}):void 0;let d=u?i:void 0;return u||await xr({fs:r,gitdir:t,currentFilepath:a},async()=>{const w=c.isSymbolicLink()?await r.readlink(a).then(pa):await r.read(a);if(w===null)throw new Dt(a);d=await $e({fs:r,gitdir:t,type:"blob",object:w})}),d}async function Of({fs:r,dir:t,gitdir:e,entries:n}){async function i(a){if(a.type==="tree"){if(!a.oid){const c=await Promise.all(a.children.map(i));a.oid=await Hr({fs:r,gitdir:e,tree:c}),a.mode=16384}}else a.type==="blob"&&(a.oid=await Bf(r,e,t,a.path,a.oid),a.mode=33188);return a.path=a.path.split("/").pop(),a}return Promise.all(n.map(i))}async function Ta({fs:r,dir:t,gitdir:e,treePair:n}){const i=n[1]==="stage",a=n.map(B=>typeof B=="string"?If[B]():B),c=[],l=await Ke({fs:r,cache:{},dir:t,gitdir:e,trees:a,map:async(B,[j,J])=>{if(!(B==="."||await _r.isIgnored({fs:r,dir:t,gitdir:e,filepath:B}))&&J)return(!j||await j.oid()!==await J.oid()&&await J.oid()!==void 0)&&c.push([j,J]),{mode:await J.mode(),path:B,oid:await J.oid(),type:await J.type()}},reduce:async(B,j)=>(j=j.filter(Boolean),B?(B.children=j,B):j.length>0?j:void 0),iterate:async(B,j)=>{const J=[];for(const X of j){const[et,it]=X;i?it&&(await r.exists(`${t}/${it.toString()}`)?J.push(X):c.push([null,it])):et&&(it?J.push(X):c.push([et,null]))}return J.length?Promise.all(J.map(B)):[]}});if(c.length===0||l.length===0)return null;const x=(await Of({fs:r,dir:t,gitdir:e,entries:l})).filter(Boolean).map(B=>({mode:B.mode,path:B.path,oid:B.oid,type:B.type}));return Hr({fs:r,gitdir:e,tree:x})}async function Ia({fs:r,dir:t,gitdir:e,stashCommit:n,parentCommit:i,wasStaged:a}){const c=[],u=[],d=await Ke({fs:r,cache:{},dir:t,gitdir:e,trees:[Ce({ref:i}),Ce({ref:n})],map:async(w,[l,_])=>{if(w==="."||await _r.isIgnored({fs:r,dir:t,gitdir:e,filepath:w}))return;const x=_?await _.type():await l.type();if(x!=="tree"&&x!=="blob")return;if(!_&&l){const j=x==="tree"?"rmdir":"rm";return x==="tree"&&c.push(w),x==="blob"&&a&&u.push({filepath:w,oid:await l.oid()}),{method:j,filepath:w}}const B=await _.oid();if(!l||await l.oid()!==B)return x==="tree"?{method:"mkdir",filepath:w}:(a&&u.push({filepath:w,oid:B,stats:await r.lstat(o(t,w))}),{method:"write",filepath:w,oid:B})}});await xr({fs:r,gitdir:e,dirRemoved:c,ops:d},async()=>{for(const w of d){const l=o(t,w.filepath);switch(w.method){case"rmdir":await r.rmdir(l);break;case"mkdir":await r.mkdir(l);break;case"rm":await r.rm(l);break;case"write":if(!c.some(_=>l.startsWith(_))){const{object:_}=await se({fs:r,cache:{},gitdir:e,oid:w.oid});await r.exists(l)&&await r.rm(l),await r.write(l,_)}break}}}),await st.acquire({fs:r,gitdir:e,cache:{}},async w=>{u.forEach(({filepath:l,stats:_,oid:x})=>{w.insert({filepath:l,stats:_,oid:x})})})}async function Ba({fs:r,cache:t,dir:e,gitdir:n,oid:i,dryRun:a=!1,noUpdateBranch:c=!1,abortOnConflict:u=!0,committer:d,mergeDriver:w}){const{commit:l,oid:_}=await He({fs:r,cache:t,gitdir:n,oid:i});if(l.parent.length>1)throw new Tr(_,l.parent.length);if(l.parent.length===0)throw new Ir(_);const x=await I.resolve({fs:r,gitdir:n,ref:"HEAD"}),{commit:B}=await He({fs:r,cache:t,gitdir:n,oid:x}),j=l.parent[0],{commit:J}=await He({fs:r,cache:t,gitdir:n,oid:j}),X=await st.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async it=>Ra({fs:r,cache:t,dir:e,gitdir:n,index:it,ourOid:B.tree,baseOid:J.tree,theirOid:l.tree,ourName:"HEAD",baseName:`parent of ${_.slice(0,7)}`,theirName:_.slice(0,7),dryRun:a,abortOnConflict:u,mergeDriver:w}));if(X instanceof nr)throw X;const et=await Lr({fs:r,cache:t,gitdir:n,message:l.message,tree:X,parent:[x],author:l.author,committer:d,dryRun:a,noUpdateBranch:c});return e&&!a&&!c&&await Ia({fs:r,dir:e,gitdir:n,stashCommit:et,parentCommit:x,wasStaged:!0}),et}async function Oa({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,cache:i={},committer:a,dryRun:c=!1,noUpdateBranch:u=!1,abortOnConflict:d=!0,mergeDriver:w}){try{U("fs",r),U("gitdir",e),U("oid",n);const l=new $t(r),_=await Ct({fsp:l,dotgit:e}),{commit:x}=await He({fs:l,cache:i,gitdir:_,oid:n});if(x.parent&&x.parent.length>1)return await Ba({fs:l,cache:i,dir:t,gitdir:_,oid:n,dryRun:c,noUpdateBranch:u,abortOnConflict:d,committer:void 0,mergeDriver:w});const B=await ar({fs:l,gitdir:_,committer:a});if(!B)throw new Ee("committer");return await Ba({fs:l,cache:i,dir:t,gitdir:_,oid:n,dryRun:c,noUpdateBranch:u,abortOnConflict:d,committer:B,mergeDriver:w})}catch(l){throw l.caller="git.cherryPick",l}}const $f=/^refs\/(heads\/|tags\/|remotes\/)?(.*)/;function or(r){const t=$f.exec(r);return t?t[1]==="remotes/"&&r.endsWith("/HEAD")?t[2].slice(0,-5):t[2]:r}async function Qe({fs:r,gitdir:t,fullname:e=!1,test:n=!1}){const i=await I.resolve({fs:r,gitdir:t,ref:"HEAD",depth:2});if(n)try{await I.resolve({fs:r,gitdir:t,ref:i})}catch{return}if(i.startsWith("refs/"))return e?i:or(i)}function Cf(r){return r=r.replace(/^git@([^:]+):/,"https://$1/"),r=r.replace(/^ssh:\/\//,"https://"),r}function $a({username:r="",password:t=""}){return`Basic ${Buffer.from(`${r}:${t}`).toString("base64")}`}async function Zr(r,t){const e=er(r);for(;;){const{value:n,done:i}=await e.next();if(n&&await t(n),i)break}e.return&&e.return()}async function on(r){let t=0;const e=[];await Zr(r,a=>{e.push(a),t+=a.byteLength});const n=new Uint8Array(t);let i=0;for(const a of e)n.set(a,i),i+=a.byteLength;return n}function Ca(r){let t=r.match(/^https?:\/\/([^/]+)@/);if(t==null)return{url:r,auth:{}};t=t[1];const[e,n]=t.split(":");return r=r.replace(`${t}@`,""),{url:r,auth:{username:e,password:n}}}function Rn(r,t){const e=t.toString(16);return"0".repeat(r-e.length)+e}class ge{static flush(){return Buffer.from("0000","utf8")}static delim(){return Buffer.from("0001","utf8")}static encode(t){typeof t=="string"&&(t=Buffer.from(t));const e=t.length+4,n=Rn(4,e);return Buffer.concat([Buffer.from(n,"utf8"),t])}static streamReader(t){const e=new rr(t);return async function(){try{let i=await e.read(4);if(i==null)return!0;if(i=parseInt(i.toString("utf8"),16),i===0||i===1)return null;const a=await e.read(i-4);return a??!0}catch(i){return t.error=i,!0}}}}async function Pa(r){const t={};let e;for(;e=await r(),e!==!0;){if(e===null)continue;e=e.toString("utf8").replace(/\n$/,"");const n=e.indexOf("=");if(n>-1){const i=e.slice(0,n),a=e.slice(n+1);t[i]=a}else t[e]=!0}return{protocolVersion:2,capabilities2:t}}async function Fa(r,{service:t}){const e=new Set,n=new Map,i=new Map,a=ge.streamReader(r);let c=await a();for(;c===null;)c=await a();if(c===!0)throw new Or;if(c.includes("version 2"))return Pa(a);if(c.toString("utf8").replace(/\n$/,"")!==`# service=${t}`)throw new ir(`# service=${t}\\n`,c.toString("utf8"));let u=await a();for(;u===null;)u=await a();if(u===!0)return{capabilities:e,refs:n,symrefs:i};if(u=u.toString("utf8"),u.includes("version 2"))return Pa(a);const[d,w]=Tn(u,"\0","\\x00");if(w.split(" ").map(l=>e.add(l)),d!=="0000000000000000000000000000000000000000 capabilities^{}"){const[l,_]=Tn(d," "," ");for(n.set(_,l);;){const x=await a();if(x===!0)break;if(x!==null){const[B,j]=Tn(x.toString("utf8")," "," ");n.set(j,B)}}}for(const l of e)if(l.startsWith("symref=")){const _=l.match(/symref=([^:]+):(.*)/);_.length===3&&i.set(_[1],_[2])}return{protocolVersion:1,capabilities:e,refs:n,symrefs:i}}function Tn(r,t,e){const n=r.trim().split(t);if(n.length!==2)throw new ir(`Two strings separated by '${e}'`,r.toString("utf8"));return n}const Da=(r,t)=>r.endsWith("?")?`${r}${t}`:`${r}/${t.replace(/^https?:\/\//,"")}`,Ua=(r,t)=>{(t.username||t.password)&&(r.Authorization=$a(t)),t.headers&&Object.assign(r,t.headers)},In=async r=>{try{const t=Buffer.from(await on(r.body)),e=t.toString("utf8");return{preview:e.length<256?e:e.slice(0,256)+"...",response:e,data:t}}catch{return{}}};class sn{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:n,onAuthSuccess:i,onAuthFailure:a,corsProxy:c,service:u,url:d,headers:w,protocolVersion:l}){let{url:_,auth:x}=Ca(d);const B=c?Da(c,_):_;(x.username||x.password)&&(w.Authorization=$a(x)),l===2&&(w["Git-Protocol"]="version=2");let j,J,X=!1;do if(j=await t.request({onProgress:e,method:"GET",url:`${B}/info/refs?service=${u}`,headers:w}),J=!1,j.statusCode===401||j.statusCode===203){const et=X?a:n;if(et){if(x=await et(_,{...x,headers:{...w}}),x&&x.cancel)throw new gr;x&&(Ua(w,x),X=!0,J=!0)}}else j.statusCode===200&&X&&i&&await i(_,x);while(J);if(j.statusCode!==200){const{response:et}=await In(j);throw new pr(j.statusCode,j.statusMessage,et)}if(j.headers["content-type"]===`application/x-${u}-advertisement`){const et=await Fa(j.body,{service:u});return et.auth=x,et}else{const{preview:et,response:it,data:bt}=await In(j);try{const kt=await Fa([bt],{service:u});return kt.auth=x,kt}catch{throw new Dr(et,it)}}}static async connect({http:t,onProgress:e,corsProxy:n,service:i,url:a,auth:c,body:u,headers:d}){const w=Ca(a);w&&(a=w.url),n&&(a=Da(n,a)),d["content-type"]=`application/x-${i}-request`,d.accept=`application/x-${i}-result`,Ua(d,c);const l=await t.request({onProgress:e,method:"POST",url:`${a}/${i}`,body:u,headers:d});if(l.statusCode!==200){const{response:_}=In(l);throw new pr(l.statusCode,l.statusMessage,_)}return l}}class cn{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",sn),e.set("https",sn);const n=Pf({url:t});if(!n)throw new Nr(t);if(e.has(n.transport))return e.get(n.transport);throw new Ur(t,n.transport,n.transport==="ssh"?Cf(t):void 0)}}function Pf({url:r}){if(r.startsWith("git@"))return{transport:"ssh",address:r};const t=r.match(/(\w+)(:\/\/|::)(.*)/);if(t!==null){if(t[2]==="://")return{transport:t[1],address:t[0]};if(t[2]==="::")return{transport:t[1],address:t[3]}}}let sr=null;class Wr{static async read({fs:t,gitdir:e}){sr===null&&(sr=new E);const n=o(e,"shallow"),i=new Set;return await sr.acquire(n,async function(){const a=await t.read(n,{encoding:"utf8"});if(a===null||a.trim()==="")return i;a.trim().split(`
`).map(c=>i.add(c))}),i}static async write({fs:t,gitdir:e,oids:n}){sr===null&&(sr=new E);const i=o(e,"shallow");if(n.size>0){const a=[...n].join(`
`)+`
`;await sr.acquire(i,async function(){await t.write(i,a,{encoding:"utf8"})})}else await sr.acquire(i,async function(){await t.rm(i)})}}async function Ff({fs:r,gitdir:t,oid:e}){const n=`objects/${e.slice(0,2)}/${e.slice(2)}`;return r.exists(`${t}/${n}`)}async function Df({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){let a=await r.readdir(o(e,"objects/pack"));a=a.filter(c=>c.endsWith(".idx"));for(const c of a){const u=`${e}/objects/pack/${c}`,d=await gn({fs:r,cache:t,filename:u,getExternalRefDelta:i});if(d.error)throw new k(d.error);if(d.offsets.has(n))return!0}return!1}async function Na({fs:r,cache:t,gitdir:e,oid:n,format:i="content"}){const a=u=>se({fs:r,cache:t,gitdir:e,oid:u});let c=await Ff({fs:r,gitdir:e,oid:n});return c||(c=await Df({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:a})),c}function Uf(r){const i="5041434b"+"00000002"+"00000000";return r.slice(0,12).toString("hex")===i}function Ma(r,t){const e=r.map(n=>n.split("=",1)[0]);return t.filter(n=>{const i=n.split("=",1)[0];return e.includes(i)})}const fn={name:"isomorphic-git",version:"1.37.1",agent:"git/isomorphic-git@1.37.1"};class un{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this.error=t,this.end()}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise(t=>{this._waiting=t})}}function Nf(r){const t=r.indexOf("\r"),e=r.indexOf(`
`);return t===-1&&e===-1?-1:t===-1?e+1:e===-1?t+1:e===t+1?e+1:Math.min(t,e)+1}function ja(r){const t=new un;let e="";return(async()=>(await Zr(r,n=>{for(n=n.toString("utf8"),e+=n;;){const i=Nf(e);if(i===-1)break;t.write(e.slice(0,i)),e=e.slice(i)}}),e.length>0&&t.write(e),t.end()))(),t}class qa{static demux(t){const e=ge.streamReader(t),n=new un,i=new un,a=new un,c=async function(){const u=await e();if(u===null)return c();if(u===!0){n.end(),a.end(),t.error?i.destroy(t.error):i.end();return}switch(u[0]){case 1:{i.write(u.slice(1));break}case 2:{a.write(u.slice(1));break}case 3:{const d=u.slice(1);a.write(d),n.end(),a.end(),i.destroy(new Error(d.toString("utf8")));return}default:n.write(u)}c()};return c(),{packetlines:n,packfile:i,progress:a}}}async function Mf(r){const{packetlines:t,packfile:e,progress:n}=qa.demux(r),i=[],a=[],c=[];let u=!1,d=!1;return new Promise((w,l)=>{Zr(t,_=>{const x=_.toString("utf8").trim();if(x.startsWith("shallow")){const B=x.slice(-41).trim();B.length!==40&&l(new Xt(B)),i.push(B)}else if(x.startsWith("unshallow")){const B=x.slice(-41).trim();B.length!==40&&l(new Xt(B)),a.push(B)}else if(x.startsWith("ACK")){const[,B,j]=x.split(" ");c.push({oid:B,status:j}),j||(d=!0)}else x.startsWith("NAK")?(u=!0,d=!0):(d=!0,u=!0);d&&(r.error?l(r.error):w({shallows:i,unshallows:a,acks:c,nak:u,packfile:e,progress:n}))}).finally(()=>{d||(r.error?l(r.error):w({shallows:i,unshallows:a,acks:c,nak:u,packfile:e,progress:n}))})})}function jf({capabilities:r=[],wants:t=[],haves:e=[],shallows:n=[],depth:i=null,since:a=null,exclude:c=[]}){const u=[];t=[...new Set(t)];let d=` ${r.join(" ")}`;for(const w of t)u.push(ge.encode(`want ${w}${d}
`)),d="";for(const w of n)u.push(ge.encode(`shallow ${w}
`));i!==null&&u.push(ge.encode(`deepen ${i}
`)),a!==null&&u.push(ge.encode(`deepen-since ${Math.floor(a.valueOf()/1e3)}
`));for(const w of c)u.push(ge.encode(`deepen-not ${w}
`));u.push(ge.flush());for(const w of e)u.push(ge.encode(`have ${w}
`));return u.push(ge.encode(`done
`)),u}async function Bn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,gitdir:d,ref:w,remoteRef:l,remote:_,url:x,corsProxy:B,depth:j=null,since:J=null,exclude:X=[],relative:et=!1,tags:it=!1,singleBranch:bt=!1,headers:kt={},prune:Bt=!1,pruneTags:Ot=!1}){const mt=w||await Qe({fs:r,gitdir:d,test:!0}),vt=await Z.get({fs:r,gitdir:d}),Et=_||mt&&await vt.get(`branch.${mt}.remote`)||"origin",zt=x||await vt.get(`remote.${Et}.url`);if(typeof zt>"u")throw new Oe("remote OR url");const ee=l||mt&&await vt.get(`branch.${mt}.merge`)||w||"HEAD";B===void 0&&(B=await vt.get("http.corsProxy"));const _e=cn.getRemoteHelperFor({url:zt}),re=await _e.discover({http:e,onAuth:a,onAuthSuccess:c,onAuthFailure:u,corsProxy:B,service:"git-upload-pack",url:zt,headers:kt,protocolVersion:1}),xe=re.auth,Se=re.refs;if(Se.size===0)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(j!==null&&!re.capabilities.has("shallow"))throw new Ye("shallow","depth");if(J!==null&&!re.capabilities.has("deepen-since"))throw new Ye("deepen-since","since");if(X.length>0&&!re.capabilities.has("deepen-not"))throw new Ye("deepen-not","exclude");if(et===!0&&!re.capabilities.has("deepen-relative"))throw new Ye("deepen-relative","relative");const{oid:cr,fullref:fr}=I.resolveAgainstMap({ref:ee,map:Se});for(const ie of Se.keys())ie===fr||ie==="HEAD"||ie.startsWith("refs/heads/")||it&&ie.startsWith("refs/tags/")||Se.delete(ie);const Er=Ma([...re.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${fn.agent}`]);et&&Er.push("deepen-relative");const Pn=bt?[cr]:Se.values(),Fn=bt?[mt]:await I.listRefs({fs:r,gitdir:d,filepath:"refs"});let Pe=[];for(let ie of Fn)try{ie=await I.expand({fs:r,gitdir:d,ref:ie});const Ae=await I.resolve({fs:r,gitdir:d,ref:ie});await Na({fs:r,cache:t,gitdir:d,oid:Ae})&&Pe.push(Ae)}catch{}Pe=[...new Set(Pe)];const pe=await Wr.read({fs:r,gitdir:d}),Ge=re.capabilities.has("shallow")?[...pe]:[],Te=jf({capabilities:Er,wants:Pn,haves:Pe,shallows:Ge,depth:j,since:J,exclude:X}),Xr=Buffer.from(await on(Te)),ur=await _e.connect({http:e,onProgress:n,corsProxy:B,service:"git-upload-pack",url:zt,auth:xe,body:[Xr],headers:kt}),be=await Mf(ur.body);ur.headers&&(be.headers=ur.headers);for(const ie of be.shallows)if(!pe.has(ie))try{const{object:Ae}=await se({fs:r,cache:t,gitdir:d,oid:ie}),Ne=new ue(Ae),Ze=await Promise.all(Ne.headers().parent.map(Yr=>Na({fs:r,cache:t,gitdir:d,oid:Yr})));Ze.length===0||Ze.every(Yr=>Yr)||pe.add(ie)}catch{pe.add(ie)}for(const ie of be.unshallows)pe.delete(ie);if(await Wr.write({fs:r,gitdir:d,oids:pe}),bt){const ie=new Map([[fr,cr]]),Ae=new Map;let Ne=10,Ze=fr;for(;Ne--;){const Un=re.symrefs.get(Ze);if(Un===void 0)break;Ae.set(Ze,Un),Ze=Un}const Dn=Se.get(Ze);Dn&&ie.set(Ze,Dn);const{pruned:Yr}=await I.updateRemoteRefs({fs:r,gitdir:d,remote:Et,refs:ie,symrefs:Ae,tags:it,prune:Bt});Bt&&(be.pruned=Yr)}else{const{pruned:ie}=await I.updateRemoteRefs({fs:r,gitdir:d,remote:Et,refs:Se,symrefs:re.symrefs,tags:it,prune:Bt,pruneTags:Ot});Bt&&(be.pruned=ie)}if(be.HEAD=re.symrefs.get("HEAD"),be.HEAD===void 0){const{oid:ie}=I.resolveAgainstMap({ref:"HEAD",map:Se});for(const[Ae,Ne]of Se.entries())if(Ae!=="HEAD"&&Ne===ie){be.HEAD=Ae;break}}const Eu=fr.startsWith("refs/tags")?"tag":"branch";if(be.FETCH_HEAD={oid:cr,description:`${Eu} '${or(fr)}' of ${zt}`},n||i){const ie=ja(be.progress);Zr(ie,async Ae=>{if(i&&await i(Ae),n){const Ne=Ae.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);Ne&&await n({phase:Ne[1].trim(),loaded:parseInt(Ne[2],10),total:parseInt(Ne[3],10)})}})}const hn=Buffer.from(await on(be.packfile));if(ur.body.error)throw ur.body.error;const ls=hn.slice(-20).toString("hex"),Vr={defaultBranch:be.HEAD,fetchHead:be.FETCH_HEAD.oid,fetchHeadDescription:be.FETCH_HEAD.description};if(be.headers&&(Vr.headers=be.headers),Bt&&(Vr.pruned=be.pruned),ls!==""&&!Uf(hn)){Vr.packfile=`objects/pack/pack-${ls}.pack`;const ie=o(d,Vr.packfile);await r.write(ie,hn);const Ae=Ze=>se({fs:r,cache:t,gitdir:d,oid:Ze}),Ne=await dr.fromPack({pack:hn,getExternalRefDelta:Ae,onProgress:n});await r.write(ie.replace(/\.pack$/,".idx"),await Ne.toBuffer())}return Vr}async function La({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:o(e,".git"),defaultBranch:i="master"}){if(await r.exists(n+"/config"))return;let a=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];a=a.map(c=>n+"/"+c);for(const c of a)await r.mkdir(c);await r.write(n+"/config",`[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${t}
`+(t?"":`	logallrefupdates = true
`)+`	symlinks = false
	ignorecase = true
`),await r.write(n+"/HEAD",`ref: refs/heads/${i}
`)}async function qf({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,onPostCheckout:d,dir:w,gitdir:l,url:_,corsProxy:x,ref:B,remote:j,depth:J,since:X,exclude:et,relative:it,singleBranch:bt,noCheckout:kt,noTags:Bt,headers:Ot,nonBlocking:mt,batchSize:vt=100}){try{if(await La({fs:r,gitdir:l}),await ba({fs:r,gitdir:l,remote:j,url:_,force:!1}),x){const ee=await Z.get({fs:r,gitdir:l});await ee.set("http.corsProxy",x),await Z.save({fs:r,gitdir:l,config:ee})}const{defaultBranch:Et,fetchHead:zt}=await Bn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,gitdir:l,ref:B,remote:j,corsProxy:x,depth:J,since:X,exclude:et,relative:it,singleBranch:bt,headers:Ot,tags:!Bt});if(zt===null)return;B=B||Et,B=B.replace("refs/heads/",""),await En({fs:r,cache:t,onProgress:n,onPostCheckout:d,dir:w,gitdir:l,ref:B,remote:j,noCheckout:kt,nonBlocking:mt,batchSize:vt})}catch(Et){throw await r.rmdir(l,{recursive:!0,maxRetries:10}).catch(()=>{}),Et}}async function za({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPostCheckout:u,dir:d,gitdir:w=o(d,".git"),url:l,corsProxy:_=void 0,ref:x=void 0,remote:B="origin",depth:j=void 0,since:J=void 0,exclude:X=[],relative:et=!1,singleBranch:it=!1,noCheckout:bt=!1,noTags:kt=!1,headers:Bt={},cache:Ot={},nonBlocking:mt=!1,batchSize:vt=100}){try{U("fs",r),U("http",t),U("gitdir",w),bt||U("dir",d),U("url",l);const Et=new $t(r),zt=await Ct({fsp:Et,dotgit:w});return await qf({fs:Et,cache:Ot,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPostCheckout:u,dir:d,gitdir:zt,url:l,corsProxy:_,ref:x,remote:B,depth:j,since:J,exclude:X,relative:et,singleBranch:it,noCheckout:bt,noTags:kt,headers:Bt,nonBlocking:mt,batchSize:vt})}catch(Et){throw Et.caller="git.clone",Et}}async function Ha({fs:r,onSign:t,dir:e,gitdir:n=o(e,".git"),message:i,author:a,committer:c,signingKey:u,amend:d=!1,dryRun:w=!1,noUpdateBranch:l=!1,ref:_,parent:x,tree:B,cache:j={}}){try{U("fs",r),d||U("message",i),u&&U("onSign",t);const J=new $t(r),X=await Ct({fsp:J,dotgit:n});return await Lr({fs:J,cache:j,onSign:t,gitdir:X,message:i,author:a,committer:c,signingKey:u,amend:d,dryRun:w,noUpdateBranch:l,ref:_,parent:x,tree:B})}catch(J){throw J.caller="git.commit",J}}async function Ga({fs:r,dir:t,gitdir:e=o(t,".git"),fullname:n=!1,test:i=!1}){try{U("fs",r),U("gitdir",e);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await Qe({fs:a,gitdir:c,fullname:n,test:i})}catch(a){throw a.caller="git.currentBranch",a}}async function Lf({fs:r,gitdir:t,ref:e}){if(e=e.startsWith("refs/heads/")?e:`refs/heads/${e}`,!await I.exists({fs:r,gitdir:t,ref:e}))throw new Dt(e);const i=await I.expand({fs:r,gitdir:t,ref:e}),a=await Qe({fs:r,gitdir:t,fullname:!0});if(i===a){const d=await I.resolve({fs:r,gitdir:t,ref:i});await I.writeRef({fs:r,gitdir:t,ref:"HEAD",value:d})}await I.deleteRef({fs:r,gitdir:t,ref:i});const c=or(e),u=await Z.get({fs:r,gitdir:t});await u.deleteSection("branch",c),await Z.save({fs:r,gitdir:t,config:u})}async function Za({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n}){try{U("fs",r),U("ref",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await Lf({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteBranch",i}}async function Wa({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n}){try{U("fs",r),U("ref",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});await I.deleteRef({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteRef",i}}async function zf({fs:r,gitdir:t,remote:e}){const n=await Z.get({fs:r,gitdir:t});await n.deleteSection("remote",e),await Z.save({fs:r,gitdir:t,config:n})}async function Xa({fs:r,dir:t,gitdir:e=o(t,".git"),remote:n}){try{U("fs",r),U("remote",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await zf({fs:i,gitdir:a,remote:n})}catch(i){throw i.caller="git.deleteRemote",i}}async function Hf({fs:r,gitdir:t,ref:e}){e=e.startsWith("refs/tags/")?e:`refs/tags/${e}`,await I.deleteRef({fs:r,gitdir:t,ref:e})}async function Va({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n}){try{U("fs",r),U("ref",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await Hf({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.deleteTag",i}}async function Gf({fs:r,gitdir:t,oid:e}){const n=e.slice(0,2);return(await r.readdir(`${t}/objects/${n}`)).map(a=>`${n}${a}`).filter(a=>a.startsWith(e))}async function Zf({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i}){const a=[];let c=await r.readdir(o(e,"objects/pack"));c=c.filter(u=>u.endsWith(".idx"));for(const u of c){const d=`${e}/objects/pack/${u}`,w=await gn({fs:r,cache:t,filename:d,getExternalRefDelta:i});if(w.error)throw new k(w.error);for(const l of w.offsets.keys())l.startsWith(n)&&a.push(l)}return a}async function Wf({fs:r,cache:t,gitdir:e,oid:n}){const i=u=>se({fs:r,cache:t,gitdir:e,oid:u}),a=await Gf({fs:r,gitdir:e,oid:n}),c=await Zf({fs:r,cache:t,gitdir:e,oid:n,getExternalRefDelta:i});for(const u of c)a.indexOf(u)===-1&&a.push(u);if(a.length===1)return a[0];throw a.length>1?new kr("oids",n,a):new Dt(`an object matching "${n}"`)}async function Ya({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await Wf({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.expandOid",a}}async function Ka({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n}){try{U("fs",r),U("gitdir",e),U("ref",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await I.expand({fs:i,gitdir:a,ref:n})}catch(i){throw i.caller="git.expandRef",i}}async function On({fs:r,cache:t,gitdir:e,oids:n}){const i={},a=n.length;let c=n.map((u,d)=>({index:d,oid:u}));for(;c.length;){const u=new Set;for(const{oid:w,index:l}of c)i[w]||(i[w]=new Set),i[w].add(l),i[w].size===a&&u.add(w);if(u.size>0)return[...u];const d=new Map;for(const{oid:w,index:l}of c)try{const{object:_}=await se({fs:r,cache:t,gitdir:e,oid:w}),x=ue.from(_),{parent:B}=x.parseHeaders();for(const j of B)(!i[j]||!i[j].has(l))&&d.set(j+":"+l,{oid:j,index:l})}catch{}c=Array.from(d.values())}return[]}async function Ja({fs:r,cache:t,dir:e,gitdir:n,ours:i,theirs:a,fastForward:c=!0,fastForwardOnly:u=!1,dryRun:d=!1,noUpdateBranch:w=!1,abortOnConflict:l=!0,message:_,author:x,committer:B,signingKey:j,onSign:J,mergeDriver:X,allowUnrelatedHistories:et=!1}){i===void 0&&(i=await Qe({fs:r,gitdir:n,fullname:!0})),i=await I.expand({fs:r,gitdir:n,ref:i}),a=await I.expand({fs:r,gitdir:n,ref:a});const it=await I.resolve({fs:r,gitdir:n,ref:i}),bt=await I.resolve({fs:r,gitdir:n,ref:a}),kt=await On({fs:r,cache:t,gitdir:n,oids:[it,bt]});if(kt.length!==1)if(kt.length===0&&et)kt.push("4b825dc642cb6eb9a060e54bf8d69288fbee4904");else throw new wr;const Bt=kt[0];if(Bt===bt)return{oid:it,alreadyMerged:!0};if(c&&Bt===it)return!d&&!w&&await I.writeRef({fs:r,gitdir:n,ref:i,value:bt}),{oid:bt,fastForward:!0};{if(u)throw new $r;const Ot=await st.acquire({fs:r,gitdir:n,cache:t,allowUnmerged:!1},async vt=>Ra({fs:r,cache:t,dir:e,gitdir:n,index:vt,ourOid:it,theirOid:bt,baseOid:Bt,ourName:or(i),baseName:"base",theirName:or(a),dryRun:d,abortOnConflict:l,mergeDriver:X}));if(Ot instanceof nr)throw Ot;return _||(_=`Merge branch '${or(a)}' into ${or(i)}`),{oid:await Lr({fs:r,cache:t,gitdir:n,message:_,ref:i,tree:Ot,parent:[it,bt],author:x,committer:B,signingKey:j,onSign:J,dryRun:d,noUpdateBranch:w}),tree:Ot,mergeCommit:!0}}}async function Qa({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,dir:d,gitdir:w,ref:l,url:_,remote:x,remoteRef:B,prune:j,pruneTags:J,fastForward:X,fastForwardOnly:et,corsProxy:it,singleBranch:bt,headers:kt,author:Bt,committer:Ot,signingKey:mt}){try{if(!l){const zt=await Qe({fs:r,gitdir:w});if(!zt)throw new Oe("ref");l=zt}const{fetchHead:vt,fetchHeadDescription:Et}=await Bn({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,gitdir:w,corsProxy:it,ref:l,url:_,remote:x,remoteRef:B,singleBranch:bt,headers:kt,prune:j,pruneTags:J});await Ja({fs:r,cache:t,gitdir:w,ours:l,theirs:vt,fastForward:X,fastForwardOnly:et,message:`Merge ${Et}`,author:Bt,committer:Ot,signingKey:mt,dryRun:!1,noUpdateBranch:!1}),await En({fs:r,cache:t,onProgress:n,dir:d,gitdir:w,ref:l,remote:x,noCheckout:!1})}catch(vt){throw vt.caller="git.pull",vt}}async function to({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:u,gitdir:d=o(u,".git"),ref:w,url:l,remote:_,remoteRef:x,corsProxy:B,singleBranch:j,headers:J={},cache:X={}}){try{U("fs",r),U("http",t),U("gitdir",d);const et={name:"",email:"",timestamp:Date.now(),timezoneOffset:0},it=new $t(r),bt=await Ct({fsp:it,dotgit:d});return await Qa({fs:it,cache:X,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:u,gitdir:bt,ref:w,url:l,remote:_,remoteRef:x,fastForwardOnly:!0,corsProxy:B,singleBranch:j,headers:J,author:et,committer:et})}catch(et){throw et.caller="git.fastForward",et}}async function eo({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:u,gitdir:d=o(u,".git"),ref:w,remote:l,remoteRef:_,url:x,corsProxy:B,depth:j=null,since:J=null,exclude:X=[],relative:et=!1,tags:it=!1,singleBranch:bt=!1,headers:kt={},prune:Bt=!1,pruneTags:Ot=!1,cache:mt={}}){try{U("fs",r),U("http",t),U("gitdir",d);const vt=new $t(r),Et=await Ct({fsp:vt,dotgit:d});return await Bn({fs:vt,cache:mt,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,gitdir:Et,ref:w,remote:l,remoteRef:_,url:x,corsProxy:B,depth:j,since:J,exclude:X,relative:et,tags:it,singleBranch:bt,headers:kt,prune:Bt,pruneTags:Ot})}catch(vt){throw vt.caller="git.fetch",vt}}async function ro({fs:r,dir:t,gitdir:e=o(t,".git"),oids:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("oids",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await On({fs:a,cache:i,gitdir:c,oids:n})}catch(a){throw a.caller="git.findMergeBase",a}}async function no({fs:r,filepath:t}){if(await r.exists(o(t,".git")))return t;{const e=It(t);if(e===t)throw new Dt(`git root for ${t}`);return no({fs:r,filepath:e})}}async function io({fs:r,filepath:t}){try{return U("fs",r),U("filepath",t),await no({fs:new $t(r),filepath:t})}catch(e){throw e.caller="git.findRoot",e}}async function ao({fs:r,dir:t,gitdir:e=o(t,".git"),path:n}){try{U("fs",r),U("gitdir",e),U("path",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await qr({fs:i,gitdir:a,path:n})}catch(i){throw i.caller="git.getConfig",i}}async function Xf({fs:r,gitdir:t,path:e}){return(await Z.get({fs:r,gitdir:t})).getall(e)}async function oo({fs:r,dir:t,gitdir:e=o(t,".git"),path:n}){try{U("fs",r),U("gitdir",e),U("path",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await Xf({fs:i,gitdir:a,path:n})}catch(i){throw i.caller="git.getConfigAll",i}}async function so({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:u=!1}){try{U("http",r),U("url",a);const w=await cn.getRemoteHelperFor({url:a}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:u?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:1}),l={capabilities:[...w.capabilities]};for(const[_,x]of w.refs){const B=_.split("/"),j=B.pop();let J=l;for(const X of B)J[X]=J[X]||{},J=J[X];J[j]=x}for(const[_,x]of w.symrefs){const B=_.split("/"),j=B.pop();let J=l;for(const X of B)J[X]=J[X]||{},J=J[X];J[j]=x}return l}catch(d){throw d.caller="git.getRemoteInfo",d}}function co(r,t,e,n){const i=[];for(const[a,c]of r.refs){if(t&&!a.startsWith(t))continue;if(a.endsWith("^{}")){if(n){const d=a.replace("^{}",""),w=i[i.length-1],l=w.ref===d?w:i.find(_=>_.ref===d);if(l===void 0)throw new Error("I did not expect this to happen");l.peeled=c}continue}const u={ref:a,oid:c};e&&r.symrefs.has(a)&&(u.target=r.symrefs.get(a)),i.push(u)}return i}async function fo({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:u=!1,protocolVersion:d=2}){try{U("http",r),U("url",a);const l=await cn.getRemoteHelperFor({url:a}).discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:u?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:d});if(l.protocolVersion===2)return{protocolVersion:l.protocolVersion,capabilities:l.capabilities2};const _={};for(const x of l.capabilities){const[B,j]=x.split("=");j?_[B]=j:_[B]=!0}return{protocolVersion:1,capabilities:_,refs:co(l,void 0,!0,!0)}}catch(w){throw w.caller="git.getRemoteInfo2",w}}async function Vf({type:r,object:t,format:e="content",oid:n=void 0}){return e!=="deflated"&&(e!=="wrapped"&&(t=Zt.wrap({type:r,object:t})),n=await wt(t)),{oid:n,object:t}}async function uo({object:r}){try{U("object",r),typeof r=="string"?r=Buffer.from(r,"utf8"):r instanceof Uint8Array||(r=new Uint8Array(r));const t="blob",{oid:e,object:n}=await Vf({type:t,format:"content",object:r});return{oid:e,type:t,object:n,format:"wrapped"}}catch(t){throw t.caller="git.hashBlob",t}}async function Yf({fs:r,cache:t,onProgress:e,dir:n,gitdir:i,filepath:a}){try{a=o(n,a);const c=await r.read(a),u=w=>se({fs:r,cache:t,gitdir:i,oid:w}),d=await dr.fromPack({pack:c,getExternalRefDelta:u,onProgress:e});return await r.write(a.replace(/\.pack$/,".idx"),await d.toBuffer()),{oids:[...d.hashes]}}catch(c){throw c.caller="git.indexPack",c}}async function lo({fs:r,onProgress:t,dir:e,gitdir:n=o(e,".git"),filepath:i,cache:a={}}){try{U("fs",r),U("dir",e),U("gitdir",e),U("filepath",i);const c=new $t(r),u=await Ct({fsp:c,dotgit:n});return await Yf({fs:c,cache:a,onProgress:t,dir:e,gitdir:u,filepath:i})}catch(c){throw c.caller="git.indexPack",c}}async function ho({fs:r,bare:t=!1,dir:e,gitdir:n=t?e:o(e,".git"),defaultBranch:i="master"}){try{U("fs",r),U("gitdir",n),t||U("dir",e);const a=new $t(r),c=await Ct({fsp:a,dotgit:n});return await La({fs:a,bare:t,dir:e,gitdir:c,defaultBranch:i})}catch(a){throw a.caller="git.init",a}}async function po({fs:r,cache:t,gitdir:e,oid:n,ancestor:i,depth:a}){const c=await Wr.read({fs:r,gitdir:e});if(!n)throw new Oe("oid");if(!i)throw new Oe("ancestor");if(n===i)return!1;const u=[n],d=new Set;let w=0;for(;u.length;){if(w++===a)throw new Pr(a);const l=u.shift(),{type:_,object:x}=await se({fs:r,cache:t,gitdir:e,oid:l});if(_!=="commit")throw new Nt(l,_,"commit");const B=ue.from(x).parse();for(const j of B.parent)if(j===i)return!0;if(!c.has(l))for(const j of B.parent)d.has(j)||(u.push(j),d.add(j))}return!1}async function wo({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,ancestor:i,depth:a=-1,cache:c={}}){try{U("fs",r),U("gitdir",e),U("oid",n),U("ancestor",i);const u=new $t(r),d=await Ct({fsp:u,dotgit:e});return await po({fs:u,cache:c,gitdir:d,oid:n,ancestor:i,depth:a})}catch(u){throw u.caller="git.isDescendent",u}}async function mo({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n}){try{U("fs",r),U("dir",t),U("gitdir",e),U("filepath",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return _r.isIgnored({fs:i,dir:t,gitdir:a,filepath:n})}catch(i){throw i.caller="git.isIgnored",i}}async function go({fs:r,dir:t,gitdir:e=o(t,".git"),remote:n}){try{U("fs",r),U("gitdir",e);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return I.listBranches({fs:i,gitdir:a,remote:n})}catch(i){throw i.caller="git.listBranches",i}}async function Kf({fs:r,gitdir:t,ref:e,cache:n}){if(e){const i=await I.resolve({gitdir:t,fs:r,ref:e}),a=[];return await yo({fs:r,cache:n,gitdir:t,oid:i,filenames:a,prefix:""}),a}else return st.acquire({fs:r,gitdir:t,cache:n},async function(i){return i.entries.map(a=>a.path)})}async function yo({fs:r,cache:t,gitdir:e,oid:n,filenames:i,prefix:a}){const{tree:c}=await br({fs:r,cache:t,gitdir:e,oid:n});for(const u of c)u.type==="tree"?await yo({fs:r,cache:t,gitdir:e,oid:u.oid,filenames:i,prefix:o(a,u.path)}):i.push(o(a,u.path))}async function vo({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,cache:i={}}){try{U("fs",r),U("gitdir",e);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await Kf({fs:a,cache:i,gitdir:c,ref:n})}catch(a){throw a.caller="git.listFiles",a}}async function Jf({fs:r,cache:t,gitdir:e,ref:n}){let i;try{i=await I.resolve({gitdir:e,fs:r,ref:n})}catch(u){if(u instanceof Dt)return[]}return(await br({fs:r,cache:t,gitdir:e,oid:i})).tree.map(u=>({target:u.path,note:u.oid}))}async function _o({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n="refs/notes/commits",cache:i={}}){try{U("fs",r),U("gitdir",e),U("ref",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await Jf({fs:a,cache:i,gitdir:c,ref:n})}catch(a){throw a.caller="git.listNotes",a}}async function bo({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n}){try{U("fs",r),U("gitdir",e);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return I.listRefs({fs:i,gitdir:a,filepath:n})}catch(i){throw i.caller="git.listRefs",i}}async function Qf({fs:r,gitdir:t}){const e=await Z.get({fs:r,gitdir:t}),n=await e.getSubsections("remote");return Promise.all(n.map(async a=>{const c=await e.get(`remote.${a}.url`);return{remote:a,url:c}}))}async function xo({fs:r,dir:t,gitdir:e=o(t,".git")}){try{U("fs",r),U("gitdir",e);const n=new $t(r),i=await Ct({fsp:n,dotgit:e});return await Qf({fs:n,gitdir:i})}catch(n){throw n.caller="git.listRemotes",n}}async function tu(r){const t=ge.streamReader(r),e=[];let n;for(;n=await t(),n!==!0;){if(n===null)continue;n=n.toString("utf8").replace(/\n$/,"");const[i,a,...c]=n.split(" "),u={ref:a,oid:i};for(const d of c){const[w,l]=d.split(":");w==="symref-target"?u.target=l:w==="peeled"&&(u.peeled=l)}e.push(u)}return e}async function eu({prefix:r,symrefs:t,peelTags:e}){const n=[];return n.push(ge.encode(`command=ls-refs
`)),n.push(ge.encode(`agent=${fn.agent}
`)),(e||t||r)&&n.push(ge.delim()),e&&n.push(ge.encode("peel")),t&&n.push(ge.encode("symrefs")),r&&n.push(ge.encode(`ref-prefix ${r}`)),n.push(ge.flush()),n}async function Eo({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,url:a,headers:c={},forPush:u=!1,protocolVersion:d=2,prefix:w,symrefs:l,peelTags:_}){try{U("http",r),U("url",a);const x=await sn.discover({http:r,onAuth:t,onAuthSuccess:e,onAuthFailure:n,corsProxy:i,service:u?"git-receive-pack":"git-upload-pack",url:a,headers:c,protocolVersion:d});if(x.protocolVersion===1)return co(x,w,l,_);const B=await eu({prefix:w,symrefs:l,peelTags:_}),j=await sn.connect({http:r,auth:x.auth,headers:c,corsProxy:i,service:u?"git-receive-pack":"git-upload-pack",url:a,body:B});return tu(j.body)}catch(x){throw x.caller="git.listServerRefs",x}}async function So({fs:r,dir:t,gitdir:e=o(t,".git")}){try{U("fs",r),U("gitdir",e);const n=new $t(r),i=await Ct({fsp:n,dotgit:e});return I.listTags({fs:n,gitdir:i})}catch(n){throw n.caller="git.listTags",n}}function ru(r,t){return r.committer.timestamp-t.committer.timestamp}const nu="e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";async function Ao({fs:r,cache:t,gitdir:e,oid:n,fileId:i}){if(i===nu)return;const a=n;let c;const u=await yr({fs:r,cache:t,gitdir:e,oid:n}),d=u.tree;return i===u.oid?c=u.path:(c=await ko({fs:r,cache:t,gitdir:e,tree:d,fileId:i,oid:a}),Array.isArray(c)&&(c.length===0?c=void 0:c.length===1&&(c=c[0]))),c}async function ko({fs:r,cache:t,gitdir:e,tree:n,fileId:i,oid:a,filepaths:c=[],parentPath:u=""}){const d=n.entries().map(function(w){let l;return w.oid===i?(l=o(u,w.path),c.push(l)):w.type==="tree"&&(l=se({fs:r,cache:t,gitdir:e,oid:w.oid}).then(function({object:_}){return ko({fs:r,cache:t,gitdir:e,tree:xt.from(_),fileId:i,oid:a,filepaths:c,parentPath:o(u,w.path)})})),l});return await Promise.all(d),c}async function iu({fs:r,cache:t,gitdir:e,filepath:n,ref:i,depth:a,since:c,force:u,follow:d}){const w=typeof c>"u"?void 0:Math.floor(c.valueOf()/1e3),l=[],_=await Wr.read({fs:r,gitdir:e}),x=await I.resolve({fs:r,gitdir:e,ref:i}),B=[await He({fs:r,cache:t,gitdir:e,oid:x})];let j,J,X;function et(it){X&&n&&l.push(it)}for(;B.length>0;){const it=B.pop();if(w!==void 0&&it.commit.committer.timestamp<=w)break;if(n){let bt;try{bt=await zr({fs:r,cache:t,gitdir:e,oid:it.commit.tree,filepath:n}),J&&j!==bt&&l.push(J),j=bt,J=it,X=!0}catch(kt){if(kt instanceof Dt){let Bt=d&&j;if(Bt&&(Bt=await Ao({fs:r,cache:t,gitdir:e,oid:it.commit.tree,fileId:j}),Bt))if(Array.isArray(Bt)){if(J){const Ot=await Ao({fs:r,cache:t,gitdir:e,oid:J.commit.tree,fileId:j});if(Array.isArray(Ot))if(Bt=Bt.filter(mt=>Ot.indexOf(mt)===-1),Bt.length===1)Bt=Bt[0],n=Bt,J&&l.push(J);else{Bt=!1,J&&l.push(J);break}}}else n=Bt,J&&l.push(J);if(!Bt){if(X&&j&&(l.push(J),!u))break;if(!u&&!d)throw kt}J=it,X=!1}else throw kt}}else l.push(it);if(a!==void 0&&l.length===a){et(it);break}if(!_.has(it.oid))for(const bt of it.commit.parent){const kt=await He({fs:r,cache:t,gitdir:e,oid:bt});B.map(Bt=>Bt.oid).includes(kt.oid)||B.push(kt)}B.length===0&&et(it),B.sort((bt,kt)=>ru(bt.commit,kt.commit))}return l}async function Ro({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n,ref:i="HEAD",depth:a,since:c,force:u,follow:d,cache:w={}}){try{U("fs",r),U("gitdir",e),U("ref",i);const l=new $t(r),_=await Ct({fsp:l,dotgit:e});return await iu({fs:l,cache:w,gitdir:_,filepath:n,ref:i,depth:a,since:c,force:u,follow:d})}catch(l){throw l.caller="git.log",l}}async function To({fs:r,onSign:t,dir:e,gitdir:n=o(e,".git"),ours:i,theirs:a,fastForward:c=!0,fastForwardOnly:u=!1,dryRun:d=!1,noUpdateBranch:w=!1,abortOnConflict:l=!0,message:_,author:x,committer:B,signingKey:j,cache:J={},mergeDriver:X,allowUnrelatedHistories:et=!1}){try{U("fs",r),j&&U("onSign",t);const it=new $t(r),bt=await Ct({fsp:it,dotgit:n}),kt=await Je({fs:it,gitdir:bt,author:x});if(!kt&&(!u||!c))throw new Ee("author");const Bt=await ar({fs:it,gitdir:bt,author:kt,committer:B});if(!Bt&&(!u||!c))throw new Ee("committer");return await Ja({fs:it,cache:J,dir:e,gitdir:bt,ours:i,theirs:a,fastForward:c,fastForwardOnly:u,dryRun:d,noUpdateBranch:w,abortOnConflict:l,message:_,author:kt,committer:Bt,signingKey:j,onSign:t,mergeDriver:X,allowUnrelatedHistories:et})}catch(it){throw it.caller="git.merge",it}}const au={commit:16,tree:32,blob:48,tag:64,ofs_delta:96,ref_delta:112};async function Io({fs:r,cache:t,dir:e,gitdir:n=o(e,".git"),oids:i}){const a=new D,c=[];function u(l,_){const x=Buffer.from(l,_);c.push(x),a.update(x)}async function d({stype:l,object:_}){const x=au[l];let B=_.length,j=B>15?128:0;const J=B&15;B=B>>>4;let X=(j|x|J).toString(16);for(u(X,"hex");j;)j=B>127?128:0,X=j|B&127,u(Rn(2,X),"hex"),B=B>>>7;u(Buffer.from(await da(_)))}u("PACK"),u("00000002","hex"),u(Rn(8,i.length),"hex");for(const l of i){const{type:_,object:x}=await se({fs:r,cache:t,gitdir:n,oid:l});await d({object:x,stype:_})}const w=a.digest();return c.push(w),c}async function ou({fs:r,cache:t,gitdir:e,oids:n,write:i}){const a=await Io({fs:r,cache:t,gitdir:e,oids:n}),c=Buffer.from(await on(a)),d=`pack-${c.slice(-20).toString("hex")}.pack`;return i?(await r.write(o(e,`objects/pack/${d}`),c),{filename:d}):{filename:d,packfile:new Uint8Array(c)}}async function Bo({fs:r,dir:t,gitdir:e=o(t,".git"),oids:n,write:i=!1,cache:a={}}){try{U("fs",r),U("gitdir",e),U("oids",n);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await ou({fs:c,cache:a,gitdir:u,oids:n,write:i})}catch(c){throw c.caller="git.packObjects",c}}async function Oo({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:u,gitdir:d=o(u,".git"),ref:w,url:l,remote:_,remoteRef:x,prune:B=!1,pruneTags:j=!1,fastForward:J=!0,fastForwardOnly:X=!1,corsProxy:et,singleBranch:it,headers:bt={},author:kt,committer:Bt,signingKey:Ot,cache:mt={}}){try{U("fs",r),U("gitdir",d);const vt=new $t(r),Et=await Ct({fsp:vt,dotgit:d}),zt=await Je({fs:vt,gitdir:Et,author:kt});if(!zt)throw new Ee("author");const ee=await ar({fs:vt,gitdir:Et,author:zt,committer:Bt});if(!ee)throw new Ee("committer");return await Qa({fs:vt,cache:mt,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,dir:u,gitdir:Et,ref:w,url:l,remote:_,remoteRef:x,fastForward:J,fastForwardOnly:X,corsProxy:et,singleBranch:it,headers:bt,author:zt,committer:ee,signingKey:Ot,prune:B,pruneTags:j})}catch(vt){throw vt.caller="git.pull",vt}}async function su({fs:r,cache:t,dir:e,gitdir:n=o(e,".git"),start:i,finish:a}){const c=await Wr.read({fs:r,gitdir:n}),u=new Set,d=new Set;for(const _ of i)u.add(await I.resolve({fs:r,gitdir:n,ref:_}));for(const _ of a)try{const x=await I.resolve({fs:r,gitdir:n,ref:_});d.add(x)}catch{}const w=new Set;async function l(_){w.add(_);const{type:x,object:B}=await se({fs:r,cache:t,gitdir:n,oid:_});if(x==="tag"){const J=Ie.from(B).headers().object;return l(J)}if(x!=="commit")throw new Nt(_,x,"commit");if(!c.has(_)){const J=ue.from(B).headers().parent;for(_ of J)!d.has(_)&&!w.has(_)&&await l(_)}}for(const _ of u)await l(_);return w}async function $n({fs:r,cache:t,dir:e,gitdir:n=o(e,".git"),oids:i}){const a=new Set;async function c(u){if(a.has(u))return;a.add(u);const{type:d,object:w}=await se({fs:r,cache:t,gitdir:n,oid:u});if(d==="tag"){const _=Ie.from(w).headers().object;await c(_)}else if(d==="commit"){const _=ue.from(w).headers().tree;await c(_)}else if(d==="tree"){const l=xt.from(w);for(const _ of l)_.type==="blob"&&a.add(_.oid),_.type==="tree"&&await c(_.oid)}}for(const u of i)await c(u);return a}async function cu(r){const t={};let e="";const n=ge.streamReader(r);let i=await n();for(;i!==!0;)i!==null&&(e+=i.toString("utf8")+`
`),i=await n();const a=e.toString("utf8").split(`
`);if(i=a.shift(),!i.startsWith("unpack "))throw new ir('unpack ok" or "unpack [error message]',i);t.ok=i==="unpack ok",t.ok||(t.error=i.slice(7)),t.refs={};for(const c of a){if(c.trim()==="")continue;const u=c.slice(0,2),d=c.slice(3);let w=d.indexOf(" ");w===-1&&(w=d.length);const l=d.slice(0,w),_=d.slice(w+1);t.refs[l]={ok:u==="ok",error:_}}return t}async function fu({capabilities:r=[],triplets:t=[]}){const e=[];let n=`\0 ${r.join(" ")}`;for(const i of t)e.push(ge.encode(`${i.oldoid} ${i.oid} ${i.fullRef}${n}
`)),n="";return e.push(ge.flush()),e}async function uu({fs:r,cache:t,http:e,onProgress:n,onMessage:i,onAuth:a,onAuthSuccess:c,onAuthFailure:u,onPrePush:d,gitdir:w,ref:l,remoteRef:_,remote:x,url:B,force:j=!1,delete:J=!1,corsProxy:X,headers:et={}}){const it=l||await Qe({fs:r,gitdir:w});if(typeof it>"u")throw new Oe("ref");const bt=await Z.get({fs:r,gitdir:w});x=x||await bt.get(`branch.${it}.pushRemote`)||await bt.get("remote.pushDefault")||await bt.get(`branch.${it}.remote`)||"origin";const kt=B||await bt.get(`remote.${x}.pushurl`)||await bt.get(`remote.${x}.url`);if(typeof kt>"u")throw new Oe("remote OR url");const Bt=_||await bt.get(`branch.${it}.merge`);if(typeof kt>"u")throw new Oe("remoteRef");X===void 0&&(X=await bt.get("http.corsProxy"));const Ot=await I.expand({fs:r,gitdir:w,ref:it}),mt=J?"0000000000000000000000000000000000000000":await I.resolve({fs:r,gitdir:w,ref:Ot}),vt=cn.getRemoteHelperFor({url:kt}),Et=await vt.discover({http:e,onAuth:a,onAuthSuccess:c,onAuthFailure:u,corsProxy:X,service:"git-receive-pack",url:kt,headers:et,protocolVersion:1}),zt=Et.auth;let ee;if(!Bt)ee=Ot;else try{ee=await I.expandAgainstMap({ref:Bt,map:Et.refs})}catch(pe){if(pe instanceof Dt)ee=Bt.startsWith("refs/")?Bt:`refs/heads/${Bt}`;else throw pe}const _e=Et.refs.get(ee)||"0000000000000000000000000000000000000000";if(d&&!await d({remote:x,url:kt,localRef:{ref:J?"(delete)":Ot,oid:mt},remoteRef:{ref:ee,oid:_e}}))throw new gr;const re=!Et.capabilities.has("no-thin");let xe=new Set;if(!J){const pe=[...Et.refs.values()];let Ge=new Set;if(_e!=="0000000000000000000000000000000000000000"){const Te=await On({fs:r,cache:t,gitdir:w,oids:[mt,_e]});for(const Xr of Te)pe.push(Xr);re&&(Ge=await $n({fs:r,cache:t,gitdir:w,oids:Te}))}if(!pe.includes(mt)){const Te=await su({fs:r,cache:t,gitdir:w,start:[mt],finish:pe});xe=await $n({fs:r,cache:t,gitdir:w,oids:Te})}if(re){try{const Te=await I.resolve({fs:r,gitdir:w,ref:`refs/remotes/${x}/HEAD`,depth:2}),{oid:Xr}=await I.resolveAgainstMap({ref:Te.replace(`refs/remotes/${x}/`,""),fullref:Te,map:Et.refs}),ur=[Xr];for(const be of await $n({fs:r,cache:t,gitdir:w,oids:ur}))Ge.add(be)}catch{}for(const Te of Ge)xe.delete(Te)}if(mt===_e&&(j=!0),!j){if(Ot.startsWith("refs/tags")&&_e!=="0000000000000000000000000000000000000000")throw new mr("tag-exists");if(mt!=="0000000000000000000000000000000000000000"&&_e!=="0000000000000000000000000000000000000000"&&!await po({fs:r,cache:t,gitdir:w,oid:mt,ancestor:_e,depth:-1}))throw new mr("not-fast-forward")}}const Se=Ma([...Et.capabilities],["report-status","side-band-64k",`agent=${fn.agent}`]),cr=await fu({capabilities:Se,triplets:[{oldoid:_e,oid:mt,fullRef:ee}]}),fr=J?[]:await Io({fs:r,cache:t,gitdir:w,oids:[...xe]}),Er=await vt.connect({http:e,onProgress:n,corsProxy:X,service:"git-receive-pack",url:kt,auth:zt,headers:et,body:[...cr,...fr]}),{packfile:Pn,progress:Fn}=await qa.demux(Er.body);if(i){const pe=ja(Fn);Zr(pe,async Ge=>{await i(Ge)})}const Pe=await cu(Pn);if(Er.headers&&(Pe.headers=Er.headers),x&&Pe.ok&&Pe.refs[ee].ok&&!Ot.startsWith("refs/tags")){const pe=`refs/remotes/${x}/${ee.replace("refs/heads","")}`;J?await I.deleteRef({fs:r,gitdir:w,ref:pe}):await I.writeRef({fs:r,gitdir:w,ref:pe,value:mt})}if(Pe.ok&&Object.values(Pe.refs).every(pe=>pe.ok))return Pe;{const pe=Object.entries(Pe.refs).filter(([Ge,Te])=>!Te.ok).map(([Ge,Te])=>`
  - ${Ge}: ${Te.error}`).join("");throw new Cr(pe,Pe)}}async function $o({fs:r,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPrePush:u,dir:d,gitdir:w=o(d,".git"),ref:l,remoteRef:_,remote:x="origin",url:B,force:j=!1,delete:J=!1,corsProxy:X,headers:et={},cache:it={}}){try{U("fs",r),U("http",t),U("gitdir",w);const bt=new $t(r),kt=await Ct({fsp:bt,dotgit:w});return await uu({fs:bt,cache:it,http:t,onProgress:e,onMessage:n,onAuth:i,onAuthSuccess:a,onAuthFailure:c,onPrePush:u,gitdir:kt,ref:l,remoteRef:_,remote:x,url:B,force:j,delete:J,corsProxy:X,headers:et})}catch(bt){throw bt.caller="git.push",bt}}async function Co({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await se({fs:r,cache:t,gitdir:e,oid:n});if(i==="tag")return n=Ie.from(a).parse().object,Co({fs:r,cache:t,gitdir:e,oid:n});if(i!=="blob")throw new Nt(n,i,"blob");return{oid:n,blob:new Uint8Array(a)}}async function Po({fs:r,cache:t,gitdir:e,oid:n,filepath:i=void 0}){return i!==void 0&&(n=await zr({fs:r,cache:t,gitdir:e,oid:n,filepath:i})),await Co({fs:r,cache:t,gitdir:e,oid:n})}async function Fo({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,filepath:i,cache:a={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await Po({fs:c,cache:a,gitdir:u,oid:n,filepath:i})}catch(c){throw c.caller="git.readBlob",c}}async function Cn({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await He({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.readCommit",a}}async function lu({fs:r,cache:t,gitdir:e,ref:n="refs/notes/commits",oid:i}){const a=await I.resolve({gitdir:e,fs:r,ref:n}),{blob:c}=await Po({fs:r,cache:t,gitdir:e,oid:a,filepath:i});return c}async function Do({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n="refs/notes/commits",oid:i,cache:a={}}){try{U("fs",r),U("gitdir",e),U("ref",n),U("oid",i);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await lu({fs:c,cache:a,gitdir:u,ref:n,oid:i})}catch(c){throw c.caller="git.readNote",c}}async function Uo({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,format:i="parsed",filepath:a=void 0,encoding:c=void 0,cache:u={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const d=new $t(r),w=await Ct({fsp:d,dotgit:e});a!==void 0&&(n=await zr({fs:d,cache:u,gitdir:w,oid:n,filepath:a}));const _=await se({fs:d,cache:u,gitdir:w,oid:n,format:i==="parsed"?"content":i});if(_.oid=n,i==="parsed")switch(_.format="parsed",_.type){case"commit":_.object=ue.from(_.object).parse();break;case"tree":_.object=xt.from(_.object).entries();break;case"blob":c?_.object=_.object.toString(c):(_.object=new Uint8Array(_.object),_.format="content");break;case"tag":_.object=Ie.from(_.object).parse();break;default:throw new Nt(_.oid,_.type,"blob|commit|tag|tree")}else(_.format==="deflated"||_.format==="wrapped")&&(_.type=_.format);return _}catch(d){throw d.caller="git.readObject",d}}async function hu({fs:r,cache:t,gitdir:e,oid:n}){const{type:i,object:a}=await se({fs:r,cache:t,gitdir:e,oid:n,format:"content"});if(i!=="tag")throw new Nt(n,i,"tag");const c=Ie.from(a);return{oid:n,tag:c.parse(),payload:c.payload()}}async function No({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await hu({fs:a,cache:i,gitdir:c,oid:n})}catch(a){throw a.caller="git.readTag",a}}async function Mo({fs:r,dir:t,gitdir:e=o(t,".git"),oid:n,filepath:i=void 0,cache:a={}}){try{U("fs",r),U("gitdir",e),U("oid",n);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await br({fs:c,cache:a,gitdir:u,oid:n,filepath:i})}catch(c){throw c.caller="git.readTree",c}}async function jo({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("filepath",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});await st.acquire({fs:a,gitdir:c,cache:i},async function(u){u.delete({filepath:n})})}catch(a){throw a.caller="git.remove",a}}async function du({fs:r,cache:t,onSign:e,gitdir:n,ref:i="refs/notes/commits",oid:a,author:c,committer:u,signingKey:d}){let w;try{w=await I.resolve({gitdir:n,fs:r,ref:i})}catch(j){if(!(j instanceof Dt))throw j}let _=(await br({fs:r,cache:t,gitdir:n,oid:w||"4b825dc642cb6eb9a060e54bf8d69288fbee4904"})).tree;_=_.filter(j=>j.path!==a);const x=await Hr({fs:r,gitdir:n,tree:_});return await Lr({fs:r,cache:t,onSign:e,gitdir:n,ref:i,tree:x,parent:w&&[w],message:`Note removed by 'isomorphic-git removeNote'
`,author:c,committer:u,signingKey:d})}async function qo({fs:r,onSign:t,dir:e,gitdir:n=o(e,".git"),ref:i="refs/notes/commits",oid:a,author:c,committer:u,signingKey:d,cache:w={}}){try{U("fs",r),U("gitdir",n),U("oid",a);const l=new $t(r),_=await Ct({fsp:l,dotgit:n}),x=await Je({fs:l,gitdir:_,author:c});if(!x)throw new Ee("author");const B=await ar({fs:l,gitdir:_,author:x,committer:u});if(!B)throw new Ee("committer");return await du({fs:l,cache:w,onSign:t,gitdir:_,ref:i,oid:a,author:x,committer:B,signingKey:d})}catch(l){throw l.caller="git.removeNote",l}}async function pu({fs:r,gitdir:t,oldref:e,ref:n,checkout:i=!1}){if(!Gr(n))throw new Le(n,m.clean(n));if(!Gr(e))throw new Le(e,m.clean(e));const a=`refs/heads/${e}`,c=`refs/heads/${n}`;if(await I.exists({fs:r,gitdir:t,ref:c}))throw new qe("branch",n,!1);const d=await I.resolve({fs:r,gitdir:t,ref:a,depth:1});await I.writeRef({fs:r,gitdir:t,ref:c,value:d}),await I.deleteRef({fs:r,gitdir:t,ref:a});const l=await Qe({fs:r,gitdir:t,fullname:!0})===a;(i||l)&&await I.writeSymbolicRef({fs:r,gitdir:t,ref:"HEAD",value:c})}async function Lo({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,oldref:i,checkout:a=!1}){try{U("fs",r),U("gitdir",e),U("ref",n),U("oldref",i);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});return await pu({fs:c,gitdir:u,ref:n,oldref:i,checkout:a})}catch(c){throw c.caller="git.renameBranch",c}}async function zo({gitdir:r,type:t,object:e}){return wt(Zt.wrap({type:t,object:e}))}async function Ho({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n,ref:i,cache:a={}}){try{U("fs",r),U("gitdir",e),U("filepath",n);const c=new $t(r),u=await Ct({fsp:c,dotgit:e});let d,w;try{d=await I.resolve({fs:c,gitdir:u,ref:i||"HEAD"})}catch(x){if(i)throw x}if(d)try{d=await zr({fs:c,cache:a,gitdir:u,oid:d,filepath:n})}catch{d=null}let l={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:0,uid:0,gid:0,size:0};const _=t&&await c.read(o(t,n));_&&(w=await zo({gitdir:u,type:"blob",object:_}),d===w&&(l=await c.lstat(o(t,n)))),await st.acquire({fs:c,gitdir:u,cache:a},async function(x){x.delete({filepath:n}),d&&x.insert({filepath:n,stats:l,oid:d})})}catch(c){throw c.caller="git.reset",c}}async function Go({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,depth:i}){try{U("fs",r),U("gitdir",e),U("ref",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});return await I.resolve({fs:a,gitdir:c,ref:n,depth:i})}catch(a){throw a.caller="git.resolveRef",a}}async function Zo({fs:r,dir:t,gitdir:e=o(t,".git"),path:n,value:i,append:a=!1}){try{U("fs",r),U("gitdir",e),U("path",n);const c=new $t(r),u=await Ct({fsp:c,dotgit:e}),d=await Z.get({fs:c,gitdir:u});a?await d.append(n,i):await d.set(n,i),await Z.save({fs:c,gitdir:u,config:d})}catch(c){throw c.caller="git.setConfig",c}}async function Wo({fs:r,gitdir:t,commit:e}){const n=ue.from(e).toObject();return await $e({fs:r,gitdir:t,type:"commit",object:n,format:"content"})}class ln{static get timezoneOffsetForRefLogEntry(){const t=new Date().getTimezoneOffset(),e=Math.abs(Math.floor(t/60)),n=Math.abs(t%60).toString().padStart(2,"0");return`${t>0?"-":"+"}${e.toString().padStart(2,"0")}${n}`}static createStashReflogEntry(t,e,n){const i=t.name.replace(/\s/g,""),a="0000000000000000000000000000000000000000",c=Math.floor(Date.now()/1e3),u=ln.timezoneOffsetForRefLogEntry;return`${a} ${e} ${i} ${t.email} ${c} ${u}	${n}
`}static getStashReflogEntry(t,e=!1){return t.split(`
`).filter(a=>a).reverse().map((a,c)=>e?`stash@{${c}}: ${a.split("	")[1]}`:a)}}class Xe{constructor({fs:t,dir:e,gitdir:n=o(e,".git")}){Object.assign(this,{fs:t,dir:e,gitdir:n,_author:null})}static get refStash(){return"refs/stash"}static get refLogsStash(){return"logs/refs/stash"}get refStashPath(){return o(this.gitdir,Xe.refStash)}get refLogsStashPath(){return o(this.gitdir,Xe.refLogsStash)}async getAuthor(){if(!this._author&&(this._author=await Je({fs:this.fs,gitdir:this.gitdir,author:{}}),!this._author))throw new Ee("author");return this._author}async getStashSHA(t,e){return await this.fs.exists(this.refStashPath)?(e||await this.readStashReflogs({parsed:!1}))[t].split(" ")[1]:null}async writeStashCommit({message:t,tree:e,parent:n}){return Wo({fs:this.fs,gitdir:this.gitdir,commit:{message:t,tree:e,parent:n,author:await this.getAuthor(),committer:await this.getAuthor()}})}async readStashCommit(t){const e=await this.readStashReflogs({parsed:!1});if(t!==0&&(t<0||t>e.length-1))throw new Le(`stash@${t}`,"number that is in range of [0, num of stash pushed]");const n=await this.getStashSHA(t,e);return n?He({fs:this.fs,cache:{},gitdir:this.gitdir,oid:n}):{}}async writeStashRef(t){return I.writeRef({fs:this.fs,gitdir:this.gitdir,ref:Xe.refStash,value:t})}async writeStashReflogEntry({stashCommit:t,message:e}){const n=await this.getAuthor(),i=ln.createStashReflogEntry(n,t,e),a=this.refLogsStashPath;await xr({filepath:a,entry:i},async()=>{const c=await this.fs.exists(a)?await this.fs.read(a,"utf8"):"";await this.fs.write(a,c+i,"utf8")})}async readStashReflogs({parsed:t=!1}){if(!await this.fs.exists(this.refLogsStashPath))return[];const e=await this.fs.read(this.refLogsStashPath,"utf8");return ln.getStashReflogEntry(e,t)}}async function Xo({fs:r,dir:t,gitdir:e,message:n=""}){const i=new Xe({fs:r,dir:t,gitdir:e});await i.getAuthor();const a=await Qe({fs:r,gitdir:e,fullname:!1}),c=await I.resolve({fs:r,gitdir:e,ref:"HEAD"}),d=(await Cn({fs:r,dir:t,gitdir:e,oid:c})).commit.message,w=[c];let l=null,_=Ce({ref:"HEAD"});const x=await Ta({fs:r,dir:t,gitdir:e,treePair:[Ce({ref:"HEAD"}),"stage"]});if(x){const X=await i.writeStashCommit({message:`stash-Index: WIP on ${a} - ${new Date().toISOString()}`,tree:x,parent:w});w.push(X),l=x,_=Wt()}const B=await Ta({fs:r,dir:t,gitdir:e,treePair:[_,"workdir"]});if(B){const X=await i.writeStashCommit({message:`stash-WorkDir: WIP on ${a} - ${new Date().toISOString()}`,tree:B,parent:[w[w.length-1]]});w.push(X),l=B}if(!l||!x&&!B)throw new Dt("changes, nothing to stash");const j=(n.trim()||`WIP on ${a}`)+`: ${c.substring(0,7)} ${d}`;return{stashCommit:await i.writeStashCommit({message:j,tree:l,parent:w}),stashMsg:j,branch:a,stashMgr:i}}async function wu({fs:r,dir:t,gitdir:e,message:n=""}){const{stashCommit:i,stashMsg:a,branch:c,stashMgr:u}=await Xo({fs:r,dir:t,gitdir:e,message:n});return await u.writeStashRef(i),await u.writeStashReflogEntry({stashCommit:i,message:a}),await Sn({fs:r,dir:t,gitdir:e,ref:c,track:!1,force:!0}),i}async function mu({fs:r,dir:t,gitdir:e,message:n=""}){const{stashCommit:i}=await Xo({fs:r,dir:t,gitdir:e,message:n});return i}async function Vo({fs:r,dir:t,gitdir:e,refIdx:n=0}){const a=await new Xe({fs:r,dir:t,gitdir:e}).readStashCommit(n),{parent:c=null}=a.commit?a.commit:{};if(!(!c||!Array.isArray(c)))for(let u=0;u<c.length-1;u++){const w=(await He({fs:r,cache:{},gitdir:e,oid:c[u+1]})).commit.message.startsWith("stash-Index");await Ia({fs:r,dir:t,gitdir:e,stashCommit:c[u+1],parentCommit:c[u],wasStaged:w})}}async function Yo({fs:r,dir:t,gitdir:e,refIdx:n=0}){const i=new Xe({fs:r,dir:t,gitdir:e});if(!(await i.readStashCommit(n)).commit)return;const c=i.refStashPath;await xr(c,async()=>{await r.exists(c)&&await r.rm(c)});const u=await i.readStashReflogs({parsed:!1});if(!u.length)return;u.splice(n,1);const d=i.refLogsStashPath;await xr({reflogEntries:u,stashReflogPath:d,stashMgr:i},async()=>{if(u.length){await r.write(d,u.reverse().join(`
`)+`
`,"utf8");const w=u[u.length-1].split(" ")[1];await i.writeStashRef(w)}else await r.rm(d)})}async function gu({fs:r,dir:t,gitdir:e}){return new Xe({fs:r,dir:t,gitdir:e}).readStashReflogs({parsed:!0})}async function yu({fs:r,dir:t,gitdir:e}){const n=new Xe({fs:r,dir:t,gitdir:e}),i=[n.refStashPath,n.refLogsStashPath];await xr(i,async()=>{await Promise.all(i.map(async a=>{if(await r.exists(a))return r.rm(a)}))})}async function vu({fs:r,dir:t,gitdir:e,refIdx:n=0}){await Vo({fs:r,dir:t,gitdir:e,refIdx:n}),await Yo({fs:r,dir:t,gitdir:e,refIdx:n})}async function Ko({fs:r,dir:t,gitdir:e=o(t,".git"),op:n="push",message:i="",refIdx:a=0}){U("fs",r),U("dir",t),U("gitdir",e),U("op",n);const c={push:wu,apply:Vo,drop:Yo,list:gu,clear:yu,pop:vu,create:mu},u=["apply","drop","pop"];try{const d=new $t(r),w=await Ct({fsp:d,dotgit:e});["refs","logs","logs/refs"].map(x=>o(w,x)).forEach(async x=>{await d.exists(x)||await d.mkdir(x)});const _=c[n];if(_){if(u.includes(n)&&a<0)throw new Le(`stash@${a}`,"number that is in range of [0, num of stash pushed]");return await _({fs:d,dir:t,gitdir:w,message:i,refIdx:a})}throw new Error(`To be implemented: ${n}`)}catch(d){throw d.caller="git.stash",d}}async function Jo({fs:r,dir:t,gitdir:e=o(t,".git"),filepath:n,cache:i={}}){try{U("fs",r),U("gitdir",e),U("filepath",n);const a=new $t(r),c=await Ct({fsp:a,dotgit:e});if(await _r.isIgnored({fs:a,gitdir:c,dir:t,filepath:n}))return"ignored";const d=await _u({fs:a,cache:i,gitdir:c}),w=await Qo({fs:a,cache:i,gitdir:c,tree:d,path:n}),l=await st.acquire({fs:a,gitdir:c,cache:i},async function(X){for(const et of X)if(et.path===n)return et;return null}),_=await a.lstat(o(t,n)),x=w!==null,B=l!==null,j=_!==null,J=async()=>{if(B&&!yt(l,_))return l.oid;{const X=await a.read(o(t,n)),et=await zo({gitdir:c,type:"blob",object:X});return B&&l.oid===et&&_.size!==-1&&st.acquire({fs:a,gitdir:c,cache:i},async function(it){it.insert({filepath:n,stats:_,oid:et})}),et}};if(!x&&!j&&!B)return"absent";if(!x&&!j&&B)return"*absent";if(!x&&j&&!B)return"*added";if(!x&&j&&B)return await J()===l.oid?"added":"*added";if(x&&!j&&!B)return"deleted";if(x&&!j&&B)return w===l.oid,"*deleted";if(x&&j&&!B)return await J()===w?"*undeleted":"*undeletemodified";if(x&&j&&B){const X=await J();return X===w?X===l.oid?"unmodified":"*unmodified":X===l.oid?"modified":"*modified"}}catch(a){throw a.caller="git.status",a}}async function Qo({fs:r,cache:t,gitdir:e,tree:n,path:i}){typeof i=="string"&&(i=i.split("/"));const a=i.shift();for(const c of n)if(c.path===a){if(i.length===0)return c.oid;const{type:u,object:d}=await se({fs:r,cache:t,gitdir:e,oid:c.oid});if(u==="tree"){const w=xt.from(d);return Qo({fs:r,cache:t,gitdir:e,tree:w,path:i})}if(u==="blob")throw new Nt(c.oid,u,"blob",i.join("/"))}return null}async function _u({fs:r,cache:t,gitdir:e}){let n;try{n=await I.resolve({fs:r,gitdir:e,ref:"HEAD"})}catch(a){if(a instanceof Dt)return[]}const{tree:i}=await br({fs:r,cache:t,gitdir:e,oid:n});return i}async function ts({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n="HEAD",filepaths:i=["."],filter:a,cache:c={},ignored:u=!1}){try{U("fs",r),U("gitdir",e),U("ref",n);const d=new $t(r),w=await Ct({fsp:d,dotgit:e});return await Ke({fs:d,cache:c,dir:t,gitdir:w,trees:[Ce({ref:n}),vr(),Wt()],map:async function(l,[_,x,B]){if(!_&&!B&&x&&!u&&await _r.isIgnored({fs:d,dir:t,filepath:l})||!i.some(mt=>Aa(l,mt)))return null;if(a&&!a(l))return;const[j,J,X]=await Promise.all([_&&_.type(),x&&x.type(),B&&B.type()]),et=[j,J,X].includes("blob");if((j==="tree"||j==="special")&&!et)return;if(j==="commit")return null;if((J==="tree"||J==="special")&&!et)return;if(X==="commit")return null;if((X==="tree"||X==="special")&&!et)return;const it=j==="blob"?await _.oid():void 0,bt=X==="blob"?await B.oid():void 0;let kt;j!=="blob"&&J==="blob"&&X!=="blob"?kt="42":J==="blob"&&(kt=await x.oid());const Bt=[void 0,it,kt,bt],Ot=Bt.map(mt=>Bt.indexOf(mt));return Ot.shift(),[l,...Ot]}})}catch(d){throw d.caller="git.statusMatrix",d}}async function es({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,object:i,force:a=!1}){try{U("fs",r),U("gitdir",e),U("ref",n);const c=new $t(r);if(n===void 0)throw new Oe("ref");n=n.startsWith("refs/tags/")?n:`refs/tags/${n}`;const u=await Ct({fsp:c,dotgit:e}),d=await I.resolve({fs:c,gitdir:u,ref:i||"HEAD"});if(!a&&await I.exists({fs:c,gitdir:u,ref:n}))throw new qe("tag",n);await I.writeRef({fs:c,gitdir:u,ref:n,value:d})}catch(c){throw c.caller="git.tag",c}}async function rs({fs:r,dir:t,gitdir:e=o(t,".git"),cache:n={},filepath:i,oid:a,mode:c,add:u,remove:d,force:w}){try{U("fs",r),U("gitdir",e),U("filepath",i);const l=new $t(r),_=await Ct({fsp:l,dotgit:e});if(d)return await st.acquire({fs:l,gitdir:_,cache:n},async function(B){if(!w){const j=await l.lstat(o(t,i));if(j){if(j.isDirectory())throw new Ve("directory");return}}B.has({filepath:i})&&B.delete({filepath:i})});let x;if(!a){if(x=await l.lstat(o(t,i)),!x)throw new Dt(`file at "${i}" on disk and "remove" not set`);if(x.isDirectory())throw new Ve("directory")}return await st.acquire({fs:l,gitdir:_,cache:n},async function(B){if(!u&&!B.has({filepath:i}))throw new Dt(`file at "${i}" in index and "add" not set`);let j;if(a)j={ctime:new Date(0),mtime:new Date(0),dev:0,ino:0,mode:c,uid:0,gid:0,size:0};else{j=x;const J=j.isSymbolicLink()?await l.readlink(o(t,i)):await l.read(o(t,i));a=await $e({fs:l,gitdir:_,type:"blob",format:"content",object:J})}return B.insert({filepath:i,oid:a,stats:j}),a})}catch(l){throw l.caller="git.updateIndex",l}}function ns(){try{return fn.version}catch(r){throw r.caller="git.version",r}}async function is({fs:r,dir:t,gitdir:e=o(t,".git"),trees:n,map:i,reduce:a,iterate:c,cache:u={}}){try{U("fs",r),U("gitdir",e),U("trees",n);const d=new $t(r),w=await Ct({fsp:d,dotgit:e});return await Ke({fs:d,cache:u,dir:t,gitdir:w,trees:n,map:i,reduce:a,iterate:c})}catch(d){throw d.caller="git.walk",d}}async function as({fs:r,dir:t,gitdir:e=o(t,".git"),blob:n}){try{U("fs",r),U("gitdir",e),U("blob",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await $e({fs:i,gitdir:a,type:"blob",object:n,format:"content"})}catch(i){throw i.caller="git.writeBlob",i}}async function os({fs:r,dir:t,gitdir:e=o(t,".git"),commit:n}){try{U("fs",r),U("gitdir",e),U("commit",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await Wo({fs:i,gitdir:a,commit:n})}catch(i){throw i.caller="git.writeCommit",i}}async function ss({fs:r,dir:t,gitdir:e=o(t,".git"),type:n,object:i,format:a="parsed",oid:c,encoding:u=void 0}){try{const d=new $t(r),w=await Ct({fsp:d,dotgit:e});if(a==="parsed"){switch(n){case"commit":i=ue.from(i).toObject();break;case"tree":i=xt.from(i).toObject();break;case"blob":i=Buffer.from(i,u);break;case"tag":i=Ie.from(i).toObject();break;default:throw new Nt(c||"",n,"blob|commit|tag|tree")}a="content"}return c=await $e({fs:d,gitdir:w,type:n,object:i,oid:c,format:a}),c}catch(d){throw d.caller="git.writeObject",d}}async function cs({fs:r,dir:t,gitdir:e=o(t,".git"),ref:n,value:i,force:a=!1,symbolic:c=!1}){try{U("fs",r),U("gitdir",e),U("ref",n),U("value",i);const u=new $t(r);if(!Gr(n,!0))throw new Le(n,m.clean(n));const d=await Ct({fsp:u,dotgit:e});if(!a&&await I.exists({fs:u,gitdir:d,ref:n}))throw new qe("ref",n);c?await I.writeSymbolicRef({fs:u,gitdir:d,ref:n,value:i}):(i=await I.resolve({fs:u,gitdir:d,ref:i}),await I.writeRef({fs:u,gitdir:d,ref:n,value:i}))}catch(u){throw u.caller="git.writeRef",u}}async function bu({fs:r,gitdir:t,tag:e}){const n=Ie.from(e).toObject();return await $e({fs:r,gitdir:t,type:"tag",object:n,format:"content"})}async function fs({fs:r,dir:t,gitdir:e=o(t,".git"),tag:n}){try{U("fs",r),U("gitdir",e),U("tag",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await bu({fs:i,gitdir:a,tag:n})}catch(i){throw i.caller="git.writeTag",i}}async function us({fs:r,dir:t,gitdir:e=o(t,".git"),tree:n}){try{U("fs",r),U("gitdir",e),U("tree",n);const i=new $t(r),a=await Ct({fsp:i,dotgit:e});return await Hr({fs:i,gitdir:a,tree:n})}catch(i){throw i.caller="git.writeTree",i}}var xu={Errors:oa,STAGE:Wt,TREE:Ce,WORKDIR:vr,add:wa,abortMerge:ha,addNote:_a,addRemote:xa,annotatedTag:Ea,branch:Sa,cherryPick:Oa,checkout:Sn,clone:za,commit:Ha,getConfig:ao,getConfigAll:oo,setConfig:Zo,currentBranch:Ga,deleteBranch:Za,deleteRef:Wa,deleteRemote:Xa,deleteTag:Va,expandOid:Ya,expandRef:Ka,fastForward:to,fetch:eo,findMergeBase:ro,findRoot:io,getRemoteInfo:so,getRemoteInfo2:fo,hashBlob:uo,indexPack:lo,init:ho,isDescendent:wo,isIgnored:mo,listBranches:go,listFiles:vo,listNotes:_o,listRefs:bo,listRemotes:xo,listServerRefs:Eo,listTags:So,log:Ro,merge:To,packObjects:Bo,pull:Oo,push:$o,readBlob:Fo,readCommit:Cn,readNote:Do,readObject:Uo,readTag:No,readTree:Mo,remove:jo,removeNote:qo,renameBranch:Lo,resetIndex:Ho,updateIndex:rs,resolveRef:Go,status:Jo,statusMatrix:ts,tag:es,version:ns,walk:is,writeBlob:as,writeCommit:os,writeObject:ss,writeRef:cs,writeTag:fs,writeTree:us,stash:Ko};return St.Errors=oa,St.STAGE=Wt,St.TREE=Ce,St.WORKDIR=vr,St.abortMerge=ha,St.add=wa,St.addNote=_a,St.addRemote=xa,St.annotatedTag=Ea,St.branch=Sa,St.checkout=Sn,St.cherryPick=Oa,St.clone=za,St.commit=Ha,St.currentBranch=Ga,St.default=xu,St.deleteBranch=Za,St.deleteRef=Wa,St.deleteRemote=Xa,St.deleteTag=Va,St.expandOid=Ya,St.expandRef=Ka,St.fastForward=to,St.fetch=eo,St.findMergeBase=ro,St.findRoot=io,St.getConfig=ao,St.getConfigAll=oo,St.getRemoteInfo=so,St.getRemoteInfo2=fo,St.hashBlob=uo,St.indexPack=lo,St.init=ho,St.isDescendent=wo,St.isIgnored=mo,St.listBranches=go,St.listFiles=vo,St.listNotes=_o,St.listRefs=bo,St.listRemotes=xo,St.listServerRefs=Eo,St.listTags=So,St.log=Ro,St.merge=To,St.packObjects=Bo,St.pull=Oo,St.push=$o,St.readBlob=Fo,St.readCommit=Cn,St.readNote=Do,St.readObject=Uo,St.readTag=No,St.readTree=Mo,St.remove=jo,St.removeNote=qo,St.renameBranch=Lo,St.resetIndex=Ho,St.resolveRef=Go,St.setConfig=Zo,St.stash=Ko,St.status=Jo,St.statusMatrix=ts,St.tag=es,St.updateIndex=rs,St.version=ns,St.walk=is,St.writeBlob=as,St.writeCommit=os,St.writeObject=ss,St.writeRef=cs,St.writeTag=fs,St.writeTree=us,St}var Il=Tl();const jl=Su(Il);function Bl(b){let E=[b];return{next(){return Promise.resolve({done:E.length===0,value:E.pop()})},return(){return E=[],{}},[Symbol.asyncIterator](){return this}}}function Ol(b){return b[Symbol.asyncIterator]?b[Symbol.asyncIterator]():b[Symbol.iterator]?b[Symbol.iterator]():b.next?b:Bl(b)}async function $l(b,E){const D=Ol(b);for(;;){const{value:R,done:C}=await D.next();if(R&&await E(R),C)break}D.return&&D.return()}async function Cl(b){let E=0;const D=[];await $l(b,A=>{D.push(A),E+=A.byteLength});const R=new Uint8Array(E);let C=0;for(const A of D)R.set(A,C),C+=A.byteLength;return R}function Pl(b){if(b[Symbol.asyncIterator])return b;const E=b.getReader();return{next(){return E.read()},return(){return E.releaseLock(),{}},[Symbol.asyncIterator](){return this}}}async function Fl({onProgress:b,url:E,method:D="GET",headers:R={},body:C}){C&&(C=await Cl(C));const A=await fetch(E,{method:D,headers:R,body:C}),T=A.body&&A.body.getReader?Pl(A.body):[new Uint8Array(await A.arrayBuffer())];R={};for(const[m,g]of A.headers.entries())R[m]=g;return{url:A.url,method:A.method,statusCode:A.status,statusMessage:A.statusText,body:T,headers:R}}var ql={request:Fl};export{jl as g,ql as i};
